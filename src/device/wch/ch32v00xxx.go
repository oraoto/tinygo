// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from CH32V003xx.svd, see lib/wch

//go:build wch && ch32v00xxx

// CH32V00xxx View File
//

package wch

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device = "CH32V00xxx"
)

// Interrupt numbers.
const (
	// Window watchdog
	IRQ_WWDG = 16

	// Power control
	IRQ_PVD = 17

	// FLASH
	IRQ_FLASH = 18

	// Reset and clock control
	IRQ_RCC = 19

	// EXTI
	IRQ_EXTI7_0 = 20

	// Power control
	IRQ_AWU = 21

	// DMA1 controller
	IRQ_DMA1_Channel1 = 22

	// DMA1 controller
	IRQ_DMA1_Channel2 = 23

	// DMA1 controller
	IRQ_DMA1_Channel3 = 24

	// DMA1 controller
	IRQ_DMA1_Channel4 = 25

	// DMA1 controller
	IRQ_DMA1_Channel5 = 26

	// DMA1 controller
	IRQ_DMA1_Channel6 = 27

	// DMA1 controller
	IRQ_DMA1_Channel7 = 28

	// Analog to digital converter
	IRQ_ADC = 29

	// Inter integrated circuit
	IRQ_I2C1_EV = 30

	// Inter integrated circuit
	IRQ_I2C1_ER = 31

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 32

	// Serial peripheral interface
	IRQ_SPI1 = 33

	// Advanced timer
	IRQ_TIM1_BRK = 34

	// Advanced timer
	IRQ_TIM1_UP = 35

	// Advanced timer
	IRQ_TIM1_TRG_COM = 36

	// Advanced timer
	IRQ_TIM1_CC = 37

	// General purpose timer
	IRQ_TIM2 = 38

	// Highest interrupt number on this device.
	IRQ_max = 38
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDG_IRQHandler
func interruptWWDG() {
	callHandlers(IRQ_WWDG)
}

//export PVD_IRQHandler
func interruptPVD() {
	callHandlers(IRQ_PVD)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI7_0_IRQHandler
func interruptEXTI7_0() {
	callHandlers(IRQ_EXTI7_0)
}

//export AWU_IRQHandler
func interruptAWU() {
	callHandlers(IRQ_AWU)
}

//export DMA1_Channel1_IRQHandler
func interruptDMA1_Channel1() {
	callHandlers(IRQ_DMA1_Channel1)
}

//export DMA1_Channel2_IRQHandler
func interruptDMA1_Channel2() {
	callHandlers(IRQ_DMA1_Channel2)
}

//export DMA1_Channel3_IRQHandler
func interruptDMA1_Channel3() {
	callHandlers(IRQ_DMA1_Channel3)
}

//export DMA1_Channel4_IRQHandler
func interruptDMA1_Channel4() {
	callHandlers(IRQ_DMA1_Channel4)
}

//export DMA1_Channel5_IRQHandler
func interruptDMA1_Channel5() {
	callHandlers(IRQ_DMA1_Channel5)
}

//export DMA1_Channel6_IRQHandler
func interruptDMA1_Channel6() {
	callHandlers(IRQ_DMA1_Channel6)
}

//export DMA1_Channel7_IRQHandler
func interruptDMA1_Channel7() {
	callHandlers(IRQ_DMA1_Channel7)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export I2C1_EV_IRQHandler
func interruptI2C1_EV() {
	callHandlers(IRQ_I2C1_EV)
}

//export I2C1_ER_IRQHandler
func interruptI2C1_ER() {
	callHandlers(IRQ_I2C1_ER)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export TIM1_BRK_IRQHandler
func interruptTIM1_BRK() {
	callHandlers(IRQ_TIM1_BRK)
}

//export TIM1_UP_IRQHandler
func interruptTIM1_UP() {
	callHandlers(IRQ_TIM1_UP)
}

//export TIM1_TRG_COM_IRQHandler
func interruptTIM1_TRG_COM() {
	callHandlers(IRQ_TIM1_TRG_COM)
}

//export TIM1_CC_IRQHandler
func interruptTIM1_CC() {
	callHandlers(IRQ_TIM1_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

// Peripherals.
var (
	// Power control
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Extend configuration
	EXTEND = (*EXTEND_Type)(unsafe.Pointer(uintptr(0x40023800)))

	// General purpose I/O
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40010800)))

	// Alternate function I/O
	AFIO = (*AFIO_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// EXTI
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x40010400)))

	// DMA1 controller
	DMA1 = (*DMA1_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Independent watchdog
	IWDG = (*IWDG_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Window watchdog
	WWDG = (*WWDG_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Advanced timer
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40012c00)))

	// General purpose timer
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Inter integrated circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Serial peripheral interface
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40013800)))

	// Analog to digital converter
	ADC1 = (*ADC1_Type)(unsafe.Pointer(uintptr(0x40012400)))

	// Debug support
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0xe000d000)))

	// Device electronic signature
	ESIG = (*ESIG_Type)(unsafe.Pointer(uintptr(0x1ffff7e0)))

	// FLASH
	FLASH = (*FLASH_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Programmable Fast Interrupt Controller
	PFIC = (*PFIC_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// General purpose I/O
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// General purpose I/O
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40011400)))
)

// Power control
type PWR_Type struct {
	CTLR   volatile.Register32 // 0x0
	CSR    volatile.Register32 // 0x4
	AWUCSR volatile.Register32 // 0x8
	AWUAPR volatile.Register32 // 0xC
	AWUPSC volatile.Register32 // 0x10
}

// PWR.CTLR: Power control register (PWR_CTRL)
func (o *PWR_Type) SetCTLR_PDDS(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCTLR_PDDS() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCTLR_PVDE(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCTLR_PVDE() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCTLR_PLS(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0xe0)|value<<5)
}
func (o *PWR_Type) GetCTLR_PLS() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0xe0) >> 5
}

// PWR.CSR: Power control state register (PWR_CSR)
func (o *PWR_Type) SetCSR_PVDO(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCSR_PVDO() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}

// PWR.AWUCSR: Automatic wake-up control state register (PWR_AWUCSR)
func (o *PWR_Type) SetAWUCSR_AWUEN(value uint32) {
	volatile.StoreUint32(&o.AWUCSR.Reg, volatile.LoadUint32(&o.AWUCSR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetAWUCSR_AWUEN() uint32 {
	return (volatile.LoadUint32(&o.AWUCSR.Reg) & 0x2) >> 1
}

// PWR.AWUAPR: Automatic wake window comparison value register (PWR_AWUAPR)
func (o *PWR_Type) SetAWUAPR(value uint32) {
	volatile.StoreUint32(&o.AWUAPR.Reg, volatile.LoadUint32(&o.AWUAPR.Reg)&^(0x3f)|value)
}
func (o *PWR_Type) GetAWUAPR() uint32 {
	return volatile.LoadUint32(&o.AWUAPR.Reg) & 0x3f
}

// PWR.AWUPSC: Automatic wake-up prescaler register (PWR_AWUPSC)
func (o *PWR_Type) SetAWUPSC(value uint32) {
	volatile.StoreUint32(&o.AWUPSC.Reg, volatile.LoadUint32(&o.AWUPSC.Reg)&^(0xf)|value)
}
func (o *PWR_Type) GetAWUPSC() uint32 {
	return volatile.LoadUint32(&o.AWUPSC.Reg) & 0xf
}

// Reset and clock control
type RCC_Type struct {
	CTLR      volatile.Register32 // 0x0
	CFGR0     volatile.Register32 // 0x4
	INTR      volatile.Register32 // 0x8
	APB2PRSTR volatile.Register32 // 0xC
	APB1PRSTR volatile.Register32 // 0x10
	AHBPCENR  volatile.Register32 // 0x14
	APB2PCENR volatile.Register32 // 0x18
	APB1PCENR volatile.Register32 // 0x1C
	_         [4]byte
	RSTSCKR   volatile.Register32 // 0x24
}

// RCC.CTLR: Clock control register
func (o *RCC_Type) SetCTLR_HSION(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCTLR_HSION() uint32 {
	return volatile.LoadUint32(&o.CTLR.Reg) & 0x1
}
func (o *RCC_Type) SetCTLR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCTLR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCTLR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0xf8)|value<<3)
}
func (o *RCC_Type) GetCTLR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0xf8) >> 3
}
func (o *RCC_Type) SetCTLR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0xff00)|value<<8)
}
func (o *RCC_Type) GetCTLR_HSICAL() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0xff00) >> 8
}
func (o *RCC_Type) SetCTLR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCTLR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCTLR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCTLR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCTLR_HSEBYP(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCTLR_HSEBYP() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCTLR_CSSON(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCTLR_CSSON() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCTLR_PLLON(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCTLR_PLLON() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCTLR_PLLRDY(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCTLR_PLLRDY() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x2000000) >> 25
}

// RCC.CFGR0: Clock configuration register (RCC_CFGR0)
func (o *RCC_Type) SetCFGR0_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCFGR0_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR0.Reg) & 0x3
}
func (o *RCC_Type) SetCFGR0_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCFGR0_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCFGR0_HPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCFGR0_HPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCFGR0_PPRE1(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x700)|value<<8)
}
func (o *RCC_Type) GetCFGR0_PPRE1() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x700) >> 8
}
func (o *RCC_Type) SetCFGR0_PPRE2(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x3800)|value<<11)
}
func (o *RCC_Type) GetCFGR0_PPRE2() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x3800) >> 11
}
func (o *RCC_Type) SetCFGR0_ADCPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0xc000)|value<<14)
}
func (o *RCC_Type) GetCFGR0_ADCPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0xc000) >> 14
}
func (o *RCC_Type) SetCFGR0_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCFGR0_PLLSRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCFGR0_MCO(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x7000000)|value<<24)
}
func (o *RCC_Type) GetCFGR0_MCO() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x7000000) >> 24
}

// RCC.INTR: Clock interrupt register (RCC_INTR)
func (o *RCC_Type) SetINTR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetINTR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}
func (o *RCC_Type) SetINTR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetINTR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetINTR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetINTR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetINTR_PLLRDYF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetINTR_PLLRDYF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetINTR_CSSF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetINTR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetINTR_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetINTR_LSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetINTR_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetINTR_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetINTR_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetINTR_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetINTR_PLLRDYIE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetINTR_PLLRDYIE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetINTR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetINTR_LSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetINTR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetINTR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetINTR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetINTR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetINTR_PLLRDYC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetINTR_PLLRDYC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetINTR_CSSC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetINTR_CSSC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800000) >> 23
}

// RCC.APB2PRSTR: APB2 peripheral reset register (RCC_APB2PRSTR)
func (o *RCC_Type) SetAPB2PRSTR_AFIORST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2PRSTR_AFIORST() uint32 {
	return volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2PRSTR_IOPARST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB2PRSTR_IOPARST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB2PRSTR_IOPCRST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2PRSTR_IOPCRST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2PRSTR_IOPDRST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2PRSTR_IOPDRST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2PRSTR_ADC1RST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2PRSTR_ADC1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB2PRSTR_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2PRSTR_TIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2PRSTR_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2PRSTR_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2PRSTR_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APB2PRSTR.Reg, volatile.LoadUint32(&o.APB2PRSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2PRSTR_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2PRSTR.Reg) & 0x4000) >> 14
}

// RCC.APB1PRSTR: APB1 peripheral reset register (RCC_APB1PRSTR)
func (o *RCC_Type) SetAPB1PRSTR_WWDGRST(value uint32) {
	volatile.StoreUint32(&o.APB1PRSTR.Reg, volatile.LoadUint32(&o.APB1PRSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1PRSTR_WWDGRST() uint32 {
	return (volatile.LoadUint32(&o.APB1PRSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1PRSTR_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APB1PRSTR.Reg, volatile.LoadUint32(&o.APB1PRSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1PRSTR_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1PRSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1PRSTR_PWRRST(value uint32) {
	volatile.StoreUint32(&o.APB1PRSTR.Reg, volatile.LoadUint32(&o.APB1PRSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1PRSTR_PWRRST() uint32 {
	return (volatile.LoadUint32(&o.APB1PRSTR.Reg) & 0x10000000) >> 28
}

// RCC.AHBPCENR: AHB Peripheral Clock enable register (RCC_AHBPCENR)
func (o *RCC_Type) SetAHBPCENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.AHBPCENR.Reg, volatile.LoadUint32(&o.AHBPCENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHBPCENR_DMA1EN() uint32 {
	return volatile.LoadUint32(&o.AHBPCENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHBPCENR_SRAMEN(value uint32) {
	volatile.StoreUint32(&o.AHBPCENR.Reg, volatile.LoadUint32(&o.AHBPCENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHBPCENR_SRAMEN() uint32 {
	return (volatile.LoadUint32(&o.AHBPCENR.Reg) & 0x4) >> 2
}

// RCC.APB2PCENR: APB2 peripheral clock enable register (RCC_APB2PCENR)
func (o *RCC_Type) SetAPB2PCENR_AFIOEN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2PCENR_AFIOEN() uint32 {
	return volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2PCENR_IOPAEN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB2PCENR_IOPAEN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB2PCENR_IOPCEN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2PCENR_IOPCEN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2PCENR_IOPDEN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2PCENR_IOPDEN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2PCENR_ADC1EN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2PCENR_ADC1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB2PCENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2PCENR_TIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2PCENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2PCENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2PCENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APB2PCENR.Reg, volatile.LoadUint32(&o.APB2PCENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2PCENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2PCENR.Reg) & 0x4000) >> 14
}

// RCC.APB1PCENR: APB1 peripheral clock enable register (RCC_APB1PCENR)
func (o *RCC_Type) SetAPB1PCENR_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1PCENR.Reg, volatile.LoadUint32(&o.APB1PCENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1PCENR_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APB1PCENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1PCENR_WWDGEN(value uint32) {
	volatile.StoreUint32(&o.APB1PCENR.Reg, volatile.LoadUint32(&o.APB1PCENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1PCENR_WWDGEN() uint32 {
	return (volatile.LoadUint32(&o.APB1PCENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1PCENR_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APB1PCENR.Reg, volatile.LoadUint32(&o.APB1PCENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1PCENR_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1PCENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1PCENR_PWREN(value uint32) {
	volatile.StoreUint32(&o.APB1PCENR.Reg, volatile.LoadUint32(&o.APB1PCENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1PCENR_PWREN() uint32 {
	return (volatile.LoadUint32(&o.APB1PCENR.Reg) & 0x10000000) >> 28
}

// RCC.RSTSCKR: Control/status register (RCC_RSTSCKR)
func (o *RCC_Type) SetRSTSCKR_LSION(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetRSTSCKR_LSION() uint32 {
	return volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x1
}
func (o *RCC_Type) SetRSTSCKR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetRSTSCKR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetRSTSCKR_RMVF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetRSTSCKR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetRSTSCKR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetRSTSCKR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetRSTSCKR_PORRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetRSTSCKR_PORRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetRSTSCKR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetRSTSCKR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetRSTSCKR_IWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetRSTSCKR_IWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetRSTSCKR_WWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetRSTSCKR_WWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetRSTSCKR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.RSTSCKR.Reg, volatile.LoadUint32(&o.RSTSCKR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetRSTSCKR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.RSTSCKR.Reg) & 0x80000000) >> 31
}

// Extend configuration
type EXTEND_Type struct {
	EXTEND_CTR volatile.Register32 // 0x0
	EXTEND_KR  volatile.Register32 // 0x4
}

// EXTEND.EXTEND_CTR: Configure the extended control register
func (o *EXTEND_Type) SetEXTEND_CTR_PLL_CFG(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0xf)|value)
}
func (o *EXTEND_Type) GetEXTEND_CTR_PLL_CFG() uint32 {
	return volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0xf
}
func (o *EXTEND_Type) SetEXTEND_CTR_LOCKUP_EN(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x40)|value<<6)
}
func (o *EXTEND_Type) GetEXTEND_CTR_LOCKUP_EN() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x40) >> 6
}
func (o *EXTEND_Type) SetEXTEND_CTR_LOCKUP_RESET(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x80)|value<<7)
}
func (o *EXTEND_Type) GetEXTEND_CTR_LOCKUP_RESET() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x80) >> 7
}
func (o *EXTEND_Type) SetEXTEND_CTR_LDO_TRIM(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x400)|value<<10)
}
func (o *EXTEND_Type) GetEXTEND_CTR_LDO_TRIM() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x400) >> 10
}
func (o *EXTEND_Type) SetEXTEND_CTR_FLASH_CLK_TRIM(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x3800)|value<<11)
}
func (o *EXTEND_Type) GetEXTEND_CTR_FLASH_CLK_TRIM() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x3800) >> 11
}
func (o *EXTEND_Type) SetEXTEND_CTR_WR_EN(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTEND_Type) GetEXTEND_CTR_WR_EN() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x4000) >> 14
}
func (o *EXTEND_Type) SetEXTEND_CTR_WR_LOCK(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTEND_Type) GetEXTEND_CTR_WR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x8000) >> 15
}
func (o *EXTEND_Type) SetEXTEND_CTR_OPA_EN(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTEND_Type) GetEXTEND_CTR_OPA_EN() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x10000) >> 16
}
func (o *EXTEND_Type) SetEXTEND_CTR_OPA_NSEL(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTEND_Type) GetEXTEND_CTR_OPA_NSEL() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x20000) >> 17
}
func (o *EXTEND_Type) SetEXTEND_CTR_OPA_PSEL(value uint32) {
	volatile.StoreUint32(&o.EXTEND_CTR.Reg, volatile.LoadUint32(&o.EXTEND_CTR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTEND_Type) GetEXTEND_CTR_OPA_PSEL() uint32 {
	return (volatile.LoadUint32(&o.EXTEND_CTR.Reg) & 0x40000) >> 18
}

// EXTEND.EXTEND_KR: Configure the extended key register
func (o *EXTEND_Type) SetEXTEND_KR(value uint32) {
	volatile.StoreUint32(&o.EXTEND_KR.Reg, value)
}
func (o *EXTEND_Type) GetEXTEND_KR() uint32 {
	return volatile.LoadUint32(&o.EXTEND_KR.Reg)
}

// General purpose I/O
type GPIO_Type struct {
	CFGLR volatile.Register32 // 0x0
	_     [4]byte
	INDR  volatile.Register32 // 0x8
	OUTDR volatile.Register32 // 0xC
	BSHR  volatile.Register32 // 0x10
	BCR   volatile.Register32 // 0x14
	LCKR  volatile.Register32 // 0x18
}

// GPIO.CFGLR: Port configuration register low (GPIOn_CFGLR)
func (o *GPIO_Type) SetCFGLR_MODE0(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetCFGLR_MODE0() uint32 {
	return volatile.LoadUint32(&o.CFGLR.Reg) & 0x3
}
func (o *GPIO_Type) SetCFGLR_CNF0(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetCFGLR_CNF0() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetCFGLR_MODE1(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetCFGLR_MODE1() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetCFGLR_CNF1(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetCFGLR_CNF1() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetCFGLR_MODE2(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetCFGLR_MODE2() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetCFGLR_CNF2(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetCFGLR_CNF2() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetCFGLR_MODE3(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetCFGLR_MODE3() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetCFGLR_CNF3(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetCFGLR_CNF3() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetCFGLR_MODE4(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetCFGLR_MODE4() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetCFGLR_CNF4(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetCFGLR_CNF4() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetCFGLR_MODE5(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetCFGLR_MODE5() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetCFGLR_CNF5(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetCFGLR_CNF5() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetCFGLR_MODE6(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetCFGLR_MODE6() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetCFGLR_CNF6(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetCFGLR_CNF6() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetCFGLR_MODE7(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetCFGLR_MODE7() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetCFGLR_CNF7(value uint32) {
	volatile.StoreUint32(&o.CFGLR.Reg, volatile.LoadUint32(&o.CFGLR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetCFGLR_CNF7() uint32 {
	return (volatile.LoadUint32(&o.CFGLR.Reg) & 0xc0000000) >> 30
}

// GPIO.INDR: Port input data register (GPIOn_INDR)
func (o *GPIO_Type) SetINDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetINDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.INDR.Reg) & 0x1
}
func (o *GPIO_Type) SetINDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetINDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetINDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetINDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetINDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetINDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetINDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetINDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetINDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetINDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetINDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetINDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetINDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.INDR.Reg, volatile.LoadUint32(&o.INDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetINDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.INDR.Reg) & 0x80) >> 7
}

// GPIO.OUTDR: Port output data register (GPIOn_OUTDR)
func (o *GPIO_Type) SetOUTDR_ODR0(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTDR_ODR0() uint32 {
	return volatile.LoadUint32(&o.OUTDR.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTDR_ODR1(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTDR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTDR_ODR2(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTDR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTDR_ODR3(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTDR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTDR_ODR4(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTDR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTDR_ODR5(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTDR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTDR_ODR6(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTDR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTDR_ODR7(value uint32) {
	volatile.StoreUint32(&o.OUTDR.Reg, volatile.LoadUint32(&o.OUTDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTDR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.OUTDR.Reg) & 0x80) >> 7
}

// GPIO.BSHR: Port bit set/reset register (GPIOn_BSHR)
func (o *GPIO_Type) SetBSHR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSHR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSHR.Reg) & 0x1
}
func (o *GPIO_Type) SetBSHR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSHR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSHR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSHR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSHR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSHR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSHR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSHR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSHR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSHR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSHR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSHR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSHR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSHR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSHR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSHR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSHR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSHR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSHR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSHR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSHR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSHR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSHR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSHR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSHR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSHR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSHR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSHR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSHR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSHR.Reg, volatile.LoadUint32(&o.BSHR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSHR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSHR.Reg) & 0x800000) >> 23
}

// GPIO.BCR: Port bit reset register (GPIOn_BCR)
func (o *GPIO_Type) SetBCR_BR0(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBCR_BR0() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}
func (o *GPIO_Type) SetBCR_BR1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBCR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBCR_BR2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBCR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBCR_BR3(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBCR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBCR_BR4(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBCR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBCR_BR5(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBCR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBCR_BR6(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBCR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBCR_BR7(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBCR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x80) >> 7
}

// GPIO.LCKR: Port configuration lock register
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}

// Alternate function I/O
type AFIO_Type struct {
	_      [4]byte
	PCFR   volatile.Register32 // 0x4
	EXTICR volatile.Register32 // 0x8
}

// AFIO.PCFR: AF remap and debug I/O configuration register (AFIO_PCFR)
func (o *AFIO_Type) SetPCFR_SPI1RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x1)|value)
}
func (o *AFIO_Type) GetPCFR_SPI1RM() uint32 {
	return volatile.LoadUint32(&o.PCFR.Reg) & 0x1
}
func (o *AFIO_Type) SetPCFR_I2C1RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x2)|value<<1)
}
func (o *AFIO_Type) GetPCFR_I2C1RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x2) >> 1
}
func (o *AFIO_Type) SetPCFR_USART1RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x4)|value<<2)
}
func (o *AFIO_Type) GetPCFR_USART1RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x4) >> 2
}
func (o *AFIO_Type) SetPCFR_TIM1RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0xc0)|value<<6)
}
func (o *AFIO_Type) GetPCFR_TIM1RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0xc0) >> 6
}
func (o *AFIO_Type) SetPCFR_TIM2RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x300)|value<<8)
}
func (o *AFIO_Type) GetPCFR_TIM2RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x300) >> 8
}
func (o *AFIO_Type) SetPCFR_PA12RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x8000)|value<<15)
}
func (o *AFIO_Type) GetPCFR_PA12RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x8000) >> 15
}
func (o *AFIO_Type) SetPCFR_ADC1_ETRGINJ_RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x20000)|value<<17)
}
func (o *AFIO_Type) GetPCFR_ADC1_ETRGINJ_RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x20000) >> 17
}
func (o *AFIO_Type) SetPCFR_ADC1_ETRGREG_RM(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x40000)|value<<18)
}
func (o *AFIO_Type) GetPCFR_ADC1_ETRGREG_RM() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x40000) >> 18
}
func (o *AFIO_Type) SetPCFR_USART1REMAP1(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x200000)|value<<21)
}
func (o *AFIO_Type) GetPCFR_USART1REMAP1() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x200000) >> 21
}
func (o *AFIO_Type) SetPCFR_I2C1REMAP1(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x400000)|value<<22)
}
func (o *AFIO_Type) GetPCFR_I2C1REMAP1() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x400000) >> 22
}
func (o *AFIO_Type) SetPCFR_TIM1_IREMAP(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x800000)|value<<23)
}
func (o *AFIO_Type) GetPCFR_TIM1_IREMAP() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x800000) >> 23
}
func (o *AFIO_Type) SetPCFR_SWCFG(value uint32) {
	volatile.StoreUint32(&o.PCFR.Reg, volatile.LoadUint32(&o.PCFR.Reg)&^(0x7000000)|value<<24)
}
func (o *AFIO_Type) GetPCFR_SWCFG() uint32 {
	return (volatile.LoadUint32(&o.PCFR.Reg) & 0x7000000) >> 24
}

// AFIO.EXTICR: External interrupt configuration register (AFIO_EXTICR)
func (o *AFIO_Type) SetEXTICR_EXTI0(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0x3)|value)
}
func (o *AFIO_Type) GetEXTICR_EXTI0() uint32 {
	return volatile.LoadUint32(&o.EXTICR.Reg) & 0x3
}
func (o *AFIO_Type) SetEXTICR_EXTI1(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0xc)|value<<2)
}
func (o *AFIO_Type) GetEXTICR_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0xc) >> 2
}
func (o *AFIO_Type) SetEXTICR_EXTI2(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0x30)|value<<4)
}
func (o *AFIO_Type) GetEXTICR_EXTI2() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0x30) >> 4
}
func (o *AFIO_Type) SetEXTICR_EXTI3(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0xc0)|value<<6)
}
func (o *AFIO_Type) GetEXTICR_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0xc0) >> 6
}
func (o *AFIO_Type) SetEXTICR_EXTI4(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0x300)|value<<8)
}
func (o *AFIO_Type) GetEXTICR_EXTI4() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0x300) >> 8
}
func (o *AFIO_Type) SetEXTICR_EXTI5(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0xc00)|value<<10)
}
func (o *AFIO_Type) GetEXTICR_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0xc00) >> 10
}
func (o *AFIO_Type) SetEXTICR_EXTI6(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0x3000)|value<<12)
}
func (o *AFIO_Type) GetEXTICR_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0x3000) >> 12
}
func (o *AFIO_Type) SetEXTICR_EXTI7(value uint32) {
	volatile.StoreUint32(&o.EXTICR.Reg, volatile.LoadUint32(&o.EXTICR.Reg)&^(0xc000)|value<<14)
}
func (o *AFIO_Type) GetEXTICR_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.EXTICR.Reg) & 0xc000) >> 14
}

// EXTI
type EXTI_Type struct {
	INTENR volatile.Register32 // 0x0
	EVENR  volatile.Register32 // 0x4
	RTENR  volatile.Register32 // 0x8
	FTENR  volatile.Register32 // 0xC
	SWIEVR volatile.Register32 // 0x10
	INTFR  volatile.Register32 // 0x14
}

// EXTI.INTENR: Interrupt mask register (EXTI_INTENR)
func (o *EXTI_Type) SetINTENR_MR0(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetINTENR_MR0() uint32 {
	return volatile.LoadUint32(&o.INTENR.Reg) & 0x1
}
func (o *EXTI_Type) SetINTENR_MR1(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetINTENR_MR1() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetINTENR_MR2(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetINTENR_MR2() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetINTENR_MR3(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetINTENR_MR3() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetINTENR_MR4(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetINTENR_MR4() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetINTENR_MR5(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetINTENR_MR5() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetINTENR_MR6(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetINTENR_MR6() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetINTENR_MR7(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetINTENR_MR7() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetINTENR_MR8(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetINTENR_MR8() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetINTENR_MR9(value uint32) {
	volatile.StoreUint32(&o.INTENR.Reg, volatile.LoadUint32(&o.INTENR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetINTENR_MR9() uint32 {
	return (volatile.LoadUint32(&o.INTENR.Reg) & 0x200) >> 9
}

// EXTI.EVENR: Event mask register (EXTI_EVENR)
func (o *EXTI_Type) SetEVENR_MR0(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEVENR_MR0() uint32 {
	return volatile.LoadUint32(&o.EVENR.Reg) & 0x1
}
func (o *EXTI_Type) SetEVENR_MR1(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEVENR_MR1() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEVENR_MR2(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEVENR_MR2() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEVENR_MR3(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEVENR_MR3() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEVENR_MR4(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEVENR_MR4() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEVENR_MR5(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEVENR_MR5() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEVENR_MR6(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEVENR_MR6() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEVENR_MR7(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEVENR_MR7() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetEVENR_MR8(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetEVENR_MR8() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetEVENR_MR9(value uint32) {
	volatile.StoreUint32(&o.EVENR.Reg, volatile.LoadUint32(&o.EVENR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetEVENR_MR9() uint32 {
	return (volatile.LoadUint32(&o.EVENR.Reg) & 0x200) >> 9
}

// EXTI.RTENR: Rising Trigger selection register (EXTI_RTENR)
func (o *EXTI_Type) SetRTENR_TR0(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTENR_TR0() uint32 {
	return volatile.LoadUint32(&o.RTENR.Reg) & 0x1
}
func (o *EXTI_Type) SetRTENR_TR1(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTENR_TR1() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTENR_TR2(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTENR_TR2() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTENR_TR3(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTENR_TR3() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTENR_TR4(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTENR_TR4() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTENR_TR5(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTENR_TR5() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTENR_TR6(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTENR_TR6() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTENR_TR7(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTENR_TR7() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTENR_TR8(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTENR_TR8() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTENR_TR9(value uint32) {
	volatile.StoreUint32(&o.RTENR.Reg, volatile.LoadUint32(&o.RTENR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTENR_TR9() uint32 {
	return (volatile.LoadUint32(&o.RTENR.Reg) & 0x200) >> 9
}

// EXTI.FTENR: Falling Trigger selection register (EXTI_FTENR)
func (o *EXTI_Type) SetFTENR_TR0(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTENR_TR0() uint32 {
	return volatile.LoadUint32(&o.FTENR.Reg) & 0x1
}
func (o *EXTI_Type) SetFTENR_TR1(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTENR_TR1() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTENR_TR2(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTENR_TR2() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTENR_TR3(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTENR_TR3() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTENR_TR4(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTENR_TR4() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTENR_TR5(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTENR_TR5() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTENR_TR6(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTENR_TR6() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTENR_TR7(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTENR_TR7() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTENR_TR8(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTENR_TR8() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTENR_TR9(value uint32) {
	volatile.StoreUint32(&o.FTENR.Reg, volatile.LoadUint32(&o.FTENR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTENR_TR9() uint32 {
	return (volatile.LoadUint32(&o.FTENR.Reg) & 0x200) >> 9
}

// EXTI.SWIEVR: Software interrupt event register (EXTI_SWIEVR)
func (o *EXTI_Type) SetSWIEVR_SWIER0(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIEVR_SWIER0() uint32 {
	return volatile.LoadUint32(&o.SWIEVR.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIEVR_SWIER1(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIEVR_SWIER1() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIEVR_SWIER2(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIEVR_SWIER2() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIEVR_SWIER3(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIEVR_SWIER3() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIEVR_SWIER4(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIEVR_SWIER4() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIEVR_SWIER5(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIEVR_SWIER5() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIEVR_SWIER6(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIEVR_SWIER6() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIEVR_SWIER7(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIEVR_SWIER7() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIEVR_SWIER8(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIEVR_SWIER8() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIEVR_SWIER9(value uint32) {
	volatile.StoreUint32(&o.SWIEVR.Reg, volatile.LoadUint32(&o.SWIEVR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIEVR_SWIER9() uint32 {
	return (volatile.LoadUint32(&o.SWIEVR.Reg) & 0x200) >> 9
}

// EXTI.INTFR: Pending register (EXTI_INTFR)
func (o *EXTI_Type) SetINTFR_PR0(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetINTFR_PR0() uint32 {
	return volatile.LoadUint32(&o.INTFR.Reg) & 0x1
}
func (o *EXTI_Type) SetINTFR_PR1(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetINTFR_PR1() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetINTFR_PR2(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetINTFR_PR2() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetINTFR_PR3(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetINTFR_PR3() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetINTFR_PR4(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetINTFR_PR4() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetINTFR_PR5(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetINTFR_PR5() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetINTFR_PR6(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetINTFR_PR6() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetINTFR_PR7(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetINTFR_PR7() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetINTFR_PR8(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetINTFR_PR8() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetINTFR_PR9(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetINTFR_PR9() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x200) >> 9
}

// DMA1 controller
type DMA1_Type struct {
	INTFR  volatile.Register32 // 0x0
	INTFCR volatile.Register32 // 0x4
	CFGR1  volatile.Register32 // 0x8
	CNTR1  volatile.Register32 // 0xC
	PADDR1 volatile.Register32 // 0x10
	MADDR1 volatile.Register32 // 0x14
	_      [4]byte
	CFGR2  volatile.Register32 // 0x1C
	CNTR2  volatile.Register32 // 0x20
	PADDR2 volatile.Register32 // 0x24
	MADDR2 volatile.Register32 // 0x28
	_      [4]byte
	CFGR3  volatile.Register32 // 0x30
	CNTR3  volatile.Register32 // 0x34
	PADDR3 volatile.Register32 // 0x38
	MADDR3 volatile.Register32 // 0x3C
	_      [4]byte
	CFGR4  volatile.Register32 // 0x44
	CNTR4  volatile.Register32 // 0x48
	PADDR4 volatile.Register32 // 0x4C
	MADDR4 volatile.Register32 // 0x50
	_      [4]byte
	CFGR5  volatile.Register32 // 0x58
	CNTR5  volatile.Register32 // 0x5C
	PADDR5 volatile.Register32 // 0x60
	MADDR5 volatile.Register32 // 0x64
	_      [4]byte
	CFGR6  volatile.Register32 // 0x6C
	CNTR6  volatile.Register32 // 0x70
	PADDR6 volatile.Register32 // 0x74
	MADDR6 volatile.Register32 // 0x78
	_      [4]byte
	CFGR7  volatile.Register32 // 0x80
	CNTR7  volatile.Register32 // 0x84
	PADDR7 volatile.Register32 // 0x88
	MADDR7 volatile.Register32 // 0x8C
}

// DMA1.INTFR: DMA interrupt status register (DMA_INTFR)
func (o *DMA1_Type) SetINTFR_GIF1(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetINTFR_GIF1() uint32 {
	return volatile.LoadUint32(&o.INTFR.Reg) & 0x1
}
func (o *DMA1_Type) SetINTFR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetINTFR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetINTFR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetINTFR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetINTFR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetINTFR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetINTFR_GIF2(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetINTFR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetINTFR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetINTFR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetINTFR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetINTFR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetINTFR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetINTFR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetINTFR_GIF3(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x100)|value<<8)
}
func (o *DMA1_Type) GetINTFR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x100) >> 8
}
func (o *DMA1_Type) SetINTFR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x200)|value<<9)
}
func (o *DMA1_Type) GetINTFR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x200) >> 9
}
func (o *DMA1_Type) SetINTFR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x400)|value<<10)
}
func (o *DMA1_Type) GetINTFR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x400) >> 10
}
func (o *DMA1_Type) SetINTFR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x800)|value<<11)
}
func (o *DMA1_Type) GetINTFR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x800) >> 11
}
func (o *DMA1_Type) SetINTFR_GIF4(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA1_Type) GetINTFR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x1000) >> 12
}
func (o *DMA1_Type) SetINTFR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA1_Type) GetINTFR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x2000) >> 13
}
func (o *DMA1_Type) SetINTFR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetINTFR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x4000) >> 14
}
func (o *DMA1_Type) SetINTFR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA1_Type) GetINTFR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x8000) >> 15
}
func (o *DMA1_Type) SetINTFR_GIF5(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA1_Type) GetINTFR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x10000) >> 16
}
func (o *DMA1_Type) SetINTFR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA1_Type) GetINTFR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x20000) >> 17
}
func (o *DMA1_Type) SetINTFR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA1_Type) GetINTFR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x40000) >> 18
}
func (o *DMA1_Type) SetINTFR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA1_Type) GetINTFR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x80000) >> 19
}
func (o *DMA1_Type) SetINTFR_GIF6(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA1_Type) GetINTFR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x100000) >> 20
}
func (o *DMA1_Type) SetINTFR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA1_Type) GetINTFR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x200000) >> 21
}
func (o *DMA1_Type) SetINTFR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA1_Type) GetINTFR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x400000) >> 22
}
func (o *DMA1_Type) SetINTFR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA1_Type) GetINTFR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x800000) >> 23
}
func (o *DMA1_Type) SetINTFR_GIF7(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA1_Type) GetINTFR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x1000000) >> 24
}
func (o *DMA1_Type) SetINTFR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA1_Type) GetINTFR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x2000000) >> 25
}
func (o *DMA1_Type) SetINTFR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA1_Type) GetINTFR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x4000000) >> 26
}
func (o *DMA1_Type) SetINTFR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA1_Type) GetINTFR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x8000000) >> 27
}

// DMA1.INTFCR: DMA interrupt flag clear register (DMA_INTFCR)
func (o *DMA1_Type) SetINTFCR_CGIF1(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetINTFCR_CGIF1() uint32 {
	return volatile.LoadUint32(&o.INTFCR.Reg) & 0x1
}
func (o *DMA1_Type) SetINTFCR_CGIF2(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetINTFCR_CGIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetINTFCR_CGIF3(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA1_Type) GetINTFCR_CGIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x100) >> 8
}
func (o *DMA1_Type) SetINTFCR_CGIF4(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA1_Type) GetINTFCR_CGIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x1000) >> 12
}
func (o *DMA1_Type) SetINTFCR_CGIF5(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA1_Type) GetINTFCR_CGIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x10000) >> 16
}
func (o *DMA1_Type) SetINTFCR_CGIF6(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA1_Type) GetINTFCR_CGIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x100000) >> 20
}
func (o *DMA1_Type) SetINTFCR_CGIF7(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA1_Type) GetINTFCR_CGIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA1_Type) SetINTFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetINTFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetINTFCR_CTCIF2(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetINTFCR_CTCIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetINTFCR_CTCIF3(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA1_Type) GetINTFCR_CTCIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x200) >> 9
}
func (o *DMA1_Type) SetINTFCR_CTCIF4(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA1_Type) GetINTFCR_CTCIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x2000) >> 13
}
func (o *DMA1_Type) SetINTFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA1_Type) GetINTFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x20000) >> 17
}
func (o *DMA1_Type) SetINTFCR_CTCIF6(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA1_Type) GetINTFCR_CTCIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x200000) >> 21
}
func (o *DMA1_Type) SetINTFCR_CTCIF7(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA1_Type) GetINTFCR_CTCIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA1_Type) SetINTFCR_CHTIF1(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetINTFCR_CHTIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetINTFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetINTFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetINTFCR_CHTIF3(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA1_Type) GetINTFCR_CHTIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x400) >> 10
}
func (o *DMA1_Type) SetINTFCR_CHTIF4(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetINTFCR_CHTIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x4000) >> 14
}
func (o *DMA1_Type) SetINTFCR_CHTIF5(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA1_Type) GetINTFCR_CHTIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x40000) >> 18
}
func (o *DMA1_Type) SetINTFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA1_Type) GetINTFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x400000) >> 22
}
func (o *DMA1_Type) SetINTFCR_CHTIF7(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA1_Type) GetINTFCR_CHTIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA1_Type) SetINTFCR_CTEIF1(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetINTFCR_CTEIF1() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetINTFCR_CTEIF2(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetINTFCR_CTEIF2() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetINTFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA1_Type) GetINTFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x800) >> 11
}
func (o *DMA1_Type) SetINTFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA1_Type) GetINTFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x8000) >> 15
}
func (o *DMA1_Type) SetINTFCR_CTEIF5(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA1_Type) GetINTFCR_CTEIF5() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x80000) >> 19
}
func (o *DMA1_Type) SetINTFCR_CTEIF6(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA1_Type) GetINTFCR_CTEIF6() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x800000) >> 23
}
func (o *DMA1_Type) SetINTFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.INTFCR.Reg, volatile.LoadUint32(&o.INTFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA1_Type) GetINTFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.INTFCR.Reg) & 0x8000000) >> 27
}

// DMA1.CFGR1: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR1_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR1_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR1_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR1_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR1_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR1_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR1_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR1_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR1_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR1_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR1_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR1_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR1_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR1_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR1_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR1_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR1_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR1_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR1_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR1_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4000) >> 14
}

// DMA1.CNTR1: DMA channel 1 number of data register
func (o *DMA1_Type) SetCNTR1_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR1.Reg, volatile.LoadUint32(&o.CNTR1.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR1_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR1.Reg) & 0xffff
}

// DMA1.PADDR1: DMA channel 1 peripheral address register
func (o *DMA1_Type) SetPADDR1(value uint32) {
	volatile.StoreUint32(&o.PADDR1.Reg, value)
}
func (o *DMA1_Type) GetPADDR1() uint32 {
	return volatile.LoadUint32(&o.PADDR1.Reg)
}

// DMA1.MADDR1: DMA channel 1 memory address register
func (o *DMA1_Type) SetMADDR1(value uint32) {
	volatile.StoreUint32(&o.MADDR1.Reg, value)
}
func (o *DMA1_Type) GetMADDR1() uint32 {
	return volatile.LoadUint32(&o.MADDR1.Reg)
}

// DMA1.CFGR2: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR2_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR2_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR2_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR2_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR2_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR2_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR2_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR2_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR2_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR2_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR2_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR2_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR2_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR2_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR2_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR2_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR2_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR2_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR2_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR2_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR2_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR2_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR2_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR2_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4000) >> 14
}

// DMA1.CNTR2: DMA channel 2 number of data register
func (o *DMA1_Type) SetCNTR2_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR2.Reg, volatile.LoadUint32(&o.CNTR2.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR2_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR2.Reg) & 0xffff
}

// DMA1.PADDR2: DMA channel 2 peripheral address register
func (o *DMA1_Type) SetPADDR2(value uint32) {
	volatile.StoreUint32(&o.PADDR2.Reg, value)
}
func (o *DMA1_Type) GetPADDR2() uint32 {
	return volatile.LoadUint32(&o.PADDR2.Reg)
}

// DMA1.MADDR2: DMA channel 2 memory address register
func (o *DMA1_Type) SetMADDR2(value uint32) {
	volatile.StoreUint32(&o.MADDR2.Reg, value)
}
func (o *DMA1_Type) GetMADDR2() uint32 {
	return volatile.LoadUint32(&o.MADDR2.Reg)
}

// DMA1.CFGR3: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR3_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR3_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR3.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR3_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR3_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR3_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR3_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR3_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR3_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR3_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR3_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR3_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR3_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR3_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR3_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR3_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR3_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR3_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR3_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR3_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR3_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR3_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR3_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR3_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR3.Reg, volatile.LoadUint32(&o.CFGR3.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR3_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR3.Reg) & 0x4000) >> 14
}

// DMA1.CNTR3: DMA channel 3 number of data register
func (o *DMA1_Type) SetCNTR3_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR3.Reg, volatile.LoadUint32(&o.CNTR3.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR3_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR3.Reg) & 0xffff
}

// DMA1.PADDR3: DMA channel 3 peripheral address register
func (o *DMA1_Type) SetPADDR3(value uint32) {
	volatile.StoreUint32(&o.PADDR3.Reg, value)
}
func (o *DMA1_Type) GetPADDR3() uint32 {
	return volatile.LoadUint32(&o.PADDR3.Reg)
}

// DMA1.MADDR3: DMA channel 3 memory address register
func (o *DMA1_Type) SetMADDR3(value uint32) {
	volatile.StoreUint32(&o.MADDR3.Reg, value)
}
func (o *DMA1_Type) GetMADDR3() uint32 {
	return volatile.LoadUint32(&o.MADDR3.Reg)
}

// DMA1.CFGR4: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR4_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR4_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR4.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR4_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR4_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR4_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR4_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR4_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR4_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR4_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR4_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR4_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR4_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR4_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR4_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR4_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR4_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR4_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR4_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR4_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR4_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR4_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR4_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR4_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR4.Reg, volatile.LoadUint32(&o.CFGR4.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR4_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR4.Reg) & 0x4000) >> 14
}

// DMA1.CNTR4: DMA channel 4 number of data register
func (o *DMA1_Type) SetCNTR4_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR4.Reg, volatile.LoadUint32(&o.CNTR4.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR4_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR4.Reg) & 0xffff
}

// DMA1.PADDR4: DMA channel 4 peripheral address register
func (o *DMA1_Type) SetPADDR4(value uint32) {
	volatile.StoreUint32(&o.PADDR4.Reg, value)
}
func (o *DMA1_Type) GetPADDR4() uint32 {
	return volatile.LoadUint32(&o.PADDR4.Reg)
}

// DMA1.MADDR4: DMA channel 4 memory address register
func (o *DMA1_Type) SetMADDR4(value uint32) {
	volatile.StoreUint32(&o.MADDR4.Reg, value)
}
func (o *DMA1_Type) GetMADDR4() uint32 {
	return volatile.LoadUint32(&o.MADDR4.Reg)
}

// DMA1.CFGR5: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR5_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR5_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR5.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR5_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR5_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR5_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR5_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR5_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR5_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR5_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR5_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR5_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR5_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR5_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR5_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR5_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR5_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR5_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR5_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR5_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR5_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR5_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR5_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR5_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR5.Reg, volatile.LoadUint32(&o.CFGR5.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR5_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR5.Reg) & 0x4000) >> 14
}

// DMA1.CNTR5: DMA channel 5 number of data register
func (o *DMA1_Type) SetCNTR5_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR5.Reg, volatile.LoadUint32(&o.CNTR5.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR5_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR5.Reg) & 0xffff
}

// DMA1.PADDR5: DMA channel 5 peripheral address register
func (o *DMA1_Type) SetPADDR5(value uint32) {
	volatile.StoreUint32(&o.PADDR5.Reg, value)
}
func (o *DMA1_Type) GetPADDR5() uint32 {
	return volatile.LoadUint32(&o.PADDR5.Reg)
}

// DMA1.MADDR5: DMA channel 5 memory address register
func (o *DMA1_Type) SetMADDR5(value uint32) {
	volatile.StoreUint32(&o.MADDR5.Reg, value)
}
func (o *DMA1_Type) GetMADDR5() uint32 {
	return volatile.LoadUint32(&o.MADDR5.Reg)
}

// DMA1.CFGR6: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR6_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR6_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR6.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR6_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR6_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR6_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR6_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR6_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR6_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR6_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR6_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR6_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR6_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR6_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR6_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR6_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR6_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR6_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR6_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR6_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR6_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR6_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR6_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR6_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR6.Reg, volatile.LoadUint32(&o.CFGR6.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR6_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR6.Reg) & 0x4000) >> 14
}

// DMA1.CNTR6: DMA channel 6 number of data register
func (o *DMA1_Type) SetCNTR6_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR6.Reg, volatile.LoadUint32(&o.CNTR6.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR6_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR6.Reg) & 0xffff
}

// DMA1.PADDR6: DMA channel 6 peripheral address register
func (o *DMA1_Type) SetPADDR6(value uint32) {
	volatile.StoreUint32(&o.PADDR6.Reg, value)
}
func (o *DMA1_Type) GetPADDR6() uint32 {
	return volatile.LoadUint32(&o.PADDR6.Reg)
}

// DMA1.MADDR6: DMA channel 6 memory address register
func (o *DMA1_Type) SetMADDR6(value uint32) {
	volatile.StoreUint32(&o.MADDR6.Reg, value)
}
func (o *DMA1_Type) GetMADDR6() uint32 {
	return volatile.LoadUint32(&o.MADDR6.Reg)
}

// DMA1.CFGR7: DMA channel configuration register (DMA_CFGR)
func (o *DMA1_Type) SetCFGR7_EN(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x1)|value)
}
func (o *DMA1_Type) GetCFGR7_EN() uint32 {
	return volatile.LoadUint32(&o.CFGR7.Reg) & 0x1
}
func (o *DMA1_Type) SetCFGR7_TCIE(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x2)|value<<1)
}
func (o *DMA1_Type) GetCFGR7_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x2) >> 1
}
func (o *DMA1_Type) SetCFGR7_HTIE(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x4)|value<<2)
}
func (o *DMA1_Type) GetCFGR7_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x4) >> 2
}
func (o *DMA1_Type) SetCFGR7_TEIE(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x8)|value<<3)
}
func (o *DMA1_Type) GetCFGR7_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x8) >> 3
}
func (o *DMA1_Type) SetCFGR7_DIR(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x10)|value<<4)
}
func (o *DMA1_Type) GetCFGR7_DIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x10) >> 4
}
func (o *DMA1_Type) SetCFGR7_CIRC(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x20)|value<<5)
}
func (o *DMA1_Type) GetCFGR7_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x20) >> 5
}
func (o *DMA1_Type) SetCFGR7_PINC(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x40)|value<<6)
}
func (o *DMA1_Type) GetCFGR7_PINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x40) >> 6
}
func (o *DMA1_Type) SetCFGR7_MINC(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x80)|value<<7)
}
func (o *DMA1_Type) GetCFGR7_MINC() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x80) >> 7
}
func (o *DMA1_Type) SetCFGR7_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x300)|value<<8)
}
func (o *DMA1_Type) GetCFGR7_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x300) >> 8
}
func (o *DMA1_Type) SetCFGR7_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0xc00)|value<<10)
}
func (o *DMA1_Type) GetCFGR7_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0xc00) >> 10
}
func (o *DMA1_Type) SetCFGR7_PL(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x3000)|value<<12)
}
func (o *DMA1_Type) GetCFGR7_PL() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x3000) >> 12
}
func (o *DMA1_Type) SetCFGR7_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CFGR7.Reg, volatile.LoadUint32(&o.CFGR7.Reg)&^(0x4000)|value<<14)
}
func (o *DMA1_Type) GetCFGR7_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CFGR7.Reg) & 0x4000) >> 14
}

// DMA1.CNTR7: DMA channel 7 number of data register
func (o *DMA1_Type) SetCNTR7_NDT(value uint32) {
	volatile.StoreUint32(&o.CNTR7.Reg, volatile.LoadUint32(&o.CNTR7.Reg)&^(0xffff)|value)
}
func (o *DMA1_Type) GetCNTR7_NDT() uint32 {
	return volatile.LoadUint32(&o.CNTR7.Reg) & 0xffff
}

// DMA1.PADDR7: DMA channel 7 peripheral address register
func (o *DMA1_Type) SetPADDR7(value uint32) {
	volatile.StoreUint32(&o.PADDR7.Reg, value)
}
func (o *DMA1_Type) GetPADDR7() uint32 {
	return volatile.LoadUint32(&o.PADDR7.Reg)
}

// DMA1.MADDR7: DMA channel 7 memory address register
func (o *DMA1_Type) SetMADDR7(value uint32) {
	volatile.StoreUint32(&o.MADDR7.Reg, value)
}
func (o *DMA1_Type) GetMADDR7() uint32 {
	return volatile.LoadUint32(&o.MADDR7.Reg)
}

// Independent watchdog
type IWDG_Type struct {
	CTLR  volatile.Register32 // 0x0
	PSCR  volatile.Register32 // 0x4
	RLDR  volatile.Register32 // 0x8
	STATR volatile.Register32 // 0xC
}

// IWDG.CTLR: Key register (IWDG_CTLR)
func (o *IWDG_Type) SetCTLR_KEY(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetCTLR_KEY() uint32 {
	return volatile.LoadUint32(&o.CTLR.Reg) & 0xffff
}

// IWDG.PSCR: Prescaler register (IWDG_PSCR)
func (o *IWDG_Type) SetPSCR_PR(value uint32) {
	volatile.StoreUint32(&o.PSCR.Reg, volatile.LoadUint32(&o.PSCR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPSCR_PR() uint32 {
	return volatile.LoadUint32(&o.PSCR.Reg) & 0x7
}

// IWDG.RLDR: Reload register (IWDG_RLDR)
func (o *IWDG_Type) SetRLDR_RL(value uint32) {
	volatile.StoreUint32(&o.RLDR.Reg, volatile.LoadUint32(&o.RLDR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLDR_RL() uint32 {
	return volatile.LoadUint32(&o.RLDR.Reg) & 0xfff
}

// IWDG.STATR: Status register (IWDG_SR)
func (o *IWDG_Type) SetSTATR_PVU(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSTATR_PVU() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}
func (o *IWDG_Type) SetSTATR_RVU(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSTATR_RVU() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x2) >> 1
}

// Window watchdog
type WWDG_Type struct {
	CTLR  volatile.Register32 // 0x0
	CFGR  volatile.Register32 // 0x4
	STATR volatile.Register32 // 0x8
}

// WWDG.CTLR: Control register (WWDG_CR)
func (o *WWDG_Type) SetCTLR_T(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCTLR_T() uint32 {
	return volatile.LoadUint32(&o.CTLR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCTLR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCTLR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x80) >> 7
}

// WWDG.CFGR: Configuration register (WWDG_CFR)
func (o *WWDG_Type) SetCFGR_W(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFGR_W() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCFGR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x180)|value<<7)
}
func (o *WWDG_Type) GetCFGR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x180) >> 7
}
func (o *WWDG_Type) SetCFGR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFGR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200) >> 9
}

// WWDG.STATR: Status register (WWDG_SR)
func (o *WWDG_Type) SetSTATR_WEIF(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSTATR_WEIF() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}

// Advanced timer
type TIM_Type struct {
	CTLR1          volatile.Register32 // 0x0
	CTLR2          volatile.Register32 // 0x4
	SMCFGR         volatile.Register32 // 0x8
	DMAINTENR      volatile.Register32 // 0xC
	INTFR          volatile.Register32 // 0x10
	SWEVGR         volatile.Register32 // 0x14
	CHCTLR1_Output volatile.Register32 // 0x18
	CHCTLR2_Output volatile.Register32 // 0x1C
	CCER           volatile.Register32 // 0x20
	CNT            volatile.Register32 // 0x24
	PSC            volatile.Register32 // 0x28
	ATRLR          volatile.Register32 // 0x2C
	RPTCR          volatile.Register32 // 0x30
	CH1CVR         volatile.Register32 // 0x34
	CH2CVR         volatile.Register32 // 0x38
	CH3CVR         volatile.Register32 // 0x3C
	CH4CVR         volatile.Register32 // 0x40
	BDTR           volatile.Register32 // 0x44
	DMACFGR        volatile.Register32 // 0x48
	DMAADR         volatile.Register32 // 0x4C
}

// TIM.CTLR1: control register 1
func (o *TIM_Type) SetCTLR1_TMR_CAP_LVL_EN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCTLR1_TMR_CAP_LVL_EN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCTLR1_TMR_CAP_OV_EN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetCTLR1_TMR_CAP_OV_EN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetCTLR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCTLR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCTLR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCTLR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCTLR1_CMS(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x60)|value<<5)
}
func (o *TIM_Type) GetCTLR1_CMS() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x60) >> 5
}
func (o *TIM_Type) SetCTLR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCTLR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCTLR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCTLR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCTLR1_URS(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCTLR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCTLR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCTLR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCTLR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCTLR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1
}

// TIM.CTLR2: control register 2
func (o *TIM_Type) SetCTLR2_OIS4(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetCTLR2_OIS4() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetCTLR2_OIS3N(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCTLR2_OIS3N() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCTLR2_OIS3(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCTLR2_OIS3() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCTLR2_OIS2N(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCTLR2_OIS2N() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCTLR2_OIS2(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCTLR2_OIS2() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCTLR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCTLR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCTLR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCTLR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCTLR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCTLR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCTLR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCTLR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCTLR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCTLR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCTLR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCTLR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCTLR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCTLR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0x1
}

// TIM.SMCFGR: slave mode control register
func (o *TIM_Type) SetSMCFGR_ETP(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetSMCFGR_ETP() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetSMCFGR_ECE(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetSMCFGR_ECE() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetSMCFGR_ETPS(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x3000)|value<<12)
}
func (o *TIM_Type) GetSMCFGR_ETPS() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0x3000) >> 12
}
func (o *TIM_Type) SetSMCFGR_ETF(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetSMCFGR_ETF() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetSMCFGR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSMCFGR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSMCFGR_TS(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetSMCFGR_TS() uint32 {
	return (volatile.LoadUint32(&o.SMCFGR.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetSMCFGR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCFGR.Reg, volatile.LoadUint32(&o.SMCFGR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetSMCFGR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCFGR.Reg) & 0x7
}

// TIM.DMAINTENR: DMA/Interrupt enable register
func (o *TIM_Type) SetDMAINTENR_TDE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetDMAINTENR_TDE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetDMAINTENR_COMDE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDMAINTENR_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDMAINTENR_CC4DE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetDMAINTENR_CC4DE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetDMAINTENR_CC3DE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetDMAINTENR_CC3DE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetDMAINTENR_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetDMAINTENR_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetDMAINTENR_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDMAINTENR_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDMAINTENR_UDE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDMAINTENR_UDE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDMAINTENR_BIE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetDMAINTENR_BIE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetDMAINTENR_TIE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetDMAINTENR_TIE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetDMAINTENR_COMIE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetDMAINTENR_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetDMAINTENR_CC4IE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetDMAINTENR_CC4IE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetDMAINTENR_CC3IE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetDMAINTENR_CC3IE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetDMAINTENR_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetDMAINTENR_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetDMAINTENR_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDMAINTENR_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDMAINTENR_UIE(value uint32) {
	volatile.StoreUint32(&o.DMAINTENR.Reg, volatile.LoadUint32(&o.DMAINTENR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDMAINTENR_UIE() uint32 {
	return volatile.LoadUint32(&o.DMAINTENR.Reg) & 0x1
}

// TIM.INTFR: status register
func (o *TIM_Type) SetINTFR_CC4OF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetINTFR_CC4OF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetINTFR_CC3OF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetINTFR_CC3OF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetINTFR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetINTFR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetINTFR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetINTFR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetINTFR_BIF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetINTFR_BIF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetINTFR_TIF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetINTFR_TIF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetINTFR_COMIF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetINTFR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetINTFR_CC4IF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetINTFR_CC4IF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetINTFR_CC3IF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetINTFR_CC3IF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetINTFR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetINTFR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetINTFR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetINTFR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.INTFR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetINTFR_UIF(value uint32) {
	volatile.StoreUint32(&o.INTFR.Reg, volatile.LoadUint32(&o.INTFR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetINTFR_UIF() uint32 {
	return volatile.LoadUint32(&o.INTFR.Reg) & 0x1
}

// TIM.SWEVGR: event generation register
func (o *TIM_Type) SetSWEVGR_BG(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSWEVGR_BG() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSWEVGR_TG(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetSWEVGR_TG() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetSWEVGR_COMG(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetSWEVGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetSWEVGR_CC4G(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetSWEVGR_CC4G() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetSWEVGR_CC3G(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSWEVGR_CC3G() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSWEVGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetSWEVGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetSWEVGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSWEVGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.SWEVGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSWEVGR_UG(value uint32) {
	volatile.StoreUint32(&o.SWEVGR.Reg, volatile.LoadUint32(&o.SWEVGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSWEVGR_UG() uint32 {
	return volatile.LoadUint32(&o.SWEVGR.Reg) & 0x1
}

// TIM.CHCTLR1_Output: capture/compare mode register (output mode)
func (o *TIM_Type) SetCHCTLR1_Output_OC2CE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC2CE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCHCTLR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCHCTLR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCHCTLR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCHCTLR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCHCTLR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCHCTLR1_Output_OC1CE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC1CE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCHCTLR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCHCTLR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCHCTLR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCHCTLR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCHCTLR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CHCTLR1_Output.Reg, volatile.LoadUint32(&o.CHCTLR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCHCTLR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CHCTLR1_Output.Reg) & 0x3
}

// TIM.CHCTLR2_Output: capture/compare mode register (output mode)
func (o *TIM_Type) SetCHCTLR2_Output_OC4CE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC4CE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCHCTLR2_Output_OC4M(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC4M() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCHCTLR2_Output_OC4PE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC4PE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCHCTLR2_Output_OC4FE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC4FE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCHCTLR2_Output_CC4S(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCHCTLR2_Output_CC4S() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCHCTLR2_Output_OC3CE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC3CE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCHCTLR2_Output_OC3M(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC3M() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCHCTLR2_Output_OC3PE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC3PE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCHCTLR2_Output_OC3FE(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCHCTLR2_Output_OC3FE() uint32 {
	return (volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCHCTLR2_Output_CC3S(value uint32) {
	volatile.StoreUint32(&o.CHCTLR2_Output.Reg, volatile.LoadUint32(&o.CHCTLR2_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCHCTLR2_Output_CC3S() uint32 {
	return volatile.LoadUint32(&o.CHCTLR2_Output.Reg) & 0x3
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC4P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCCER_CC4P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCCER_CC4E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCCER_CC4E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCCER_CC3NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCER_CC3NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCER_CC3NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCER_CC3NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCER_CC3P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCCER_CC3P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCCER_CC3E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCCER_CC3E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCER_CC2NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetCCER_CC2NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ATRLR: auto-reload register
func (o *TIM_Type) SetATRLR(value uint32) {
	volatile.StoreUint32(&o.ATRLR.Reg, volatile.LoadUint32(&o.ATRLR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetATRLR() uint32 {
	return volatile.LoadUint32(&o.ATRLR.Reg) & 0xffff
}

// TIM.RPTCR: repetition counter register
func (o *TIM_Type) SetRPTCR(value uint32) {
	volatile.StoreUint32(&o.RPTCR.Reg, volatile.LoadUint32(&o.RPTCR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetRPTCR() uint32 {
	return volatile.LoadUint32(&o.RPTCR.Reg) & 0xff
}

// TIM.CH1CVR: capture/compare register 1
func (o *TIM_Type) SetCH1CVR(value uint32) {
	volatile.StoreUint32(&o.CH1CVR.Reg, volatile.LoadUint32(&o.CH1CVR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCH1CVR() uint32 {
	return volatile.LoadUint32(&o.CH1CVR.Reg) & 0xffff
}

// TIM.CH2CVR: capture/compare register 2
func (o *TIM_Type) SetCH2CVR(value uint32) {
	volatile.StoreUint32(&o.CH2CVR.Reg, volatile.LoadUint32(&o.CH2CVR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCH2CVR() uint32 {
	return volatile.LoadUint32(&o.CH2CVR.Reg) & 0xffff
}

// TIM.CH3CVR: capture/compare register 3
func (o *TIM_Type) SetCH3CVR(value uint32) {
	volatile.StoreUint32(&o.CH3CVR.Reg, volatile.LoadUint32(&o.CH3CVR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCH3CVR() uint32 {
	return volatile.LoadUint32(&o.CH3CVR.Reg) & 0xffff
}

// TIM.CH4CVR: capture/compare register 4
func (o *TIM_Type) SetCH4CVR(value uint32) {
	volatile.StoreUint32(&o.CH4CVR.Reg, volatile.LoadUint32(&o.CH4CVR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCH4CVR() uint32 {
	return volatile.LoadUint32(&o.CH4CVR.Reg) & 0xffff
}

// TIM.BDTR: break and dead-time register
func (o *TIM_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}

// TIM.DMACFGR: DMA control register
func (o *TIM_Type) SetDMACFGR_DBL(value uint32) {
	volatile.StoreUint32(&o.DMACFGR.Reg, volatile.LoadUint32(&o.DMACFGR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDMACFGR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DMACFGR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDMACFGR_DBA(value uint32) {
	volatile.StoreUint32(&o.DMACFGR.Reg, volatile.LoadUint32(&o.DMACFGR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDMACFGR_DBA() uint32 {
	return volatile.LoadUint32(&o.DMACFGR.Reg) & 0x1f
}

// TIM.DMAADR: DMA address for full transfer
func (o *TIM_Type) SetDMAADR(value uint32) {
	volatile.StoreUint32(&o.DMAADR.Reg, volatile.LoadUint32(&o.DMAADR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetDMAADR() uint32 {
	return volatile.LoadUint32(&o.DMAADR.Reg) & 0xffff
}

// Inter integrated circuit
type I2C_Type struct {
	CTLR1  volatile.Register32 // 0x0
	CTLR2  volatile.Register32 // 0x4
	OADDR1 volatile.Register32 // 0x8
	OADDR2 volatile.Register32 // 0xC
	DATAR  volatile.Register32 // 0x10
	STAR1  volatile.Register32 // 0x14
	STAR2  volatile.Register32 // 0x18
	CKCFGR volatile.Register32 // 0x1C
}

// I2C.CTLR1: Control register 1
func (o *I2C_Type) SetCTLR1_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCTLR1_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCTLR1_PEC(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCTLR1_PEC() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCTLR1_POS(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCTLR1_POS() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCTLR1_ACK(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCTLR1_ACK() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCTLR1_STOP(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetCTLR1_STOP() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetCTLR1_START(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetCTLR1_START() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetCTLR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCTLR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCTLR1_ENGC(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCTLR1_ENGC() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCTLR1_ENPEC(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCTLR1_ENPEC() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCTLR1_ENARP(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCTLR1_ENARP() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCTLR1_PE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCTLR1_PE() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1
}

// I2C.CTLR2: Control register 2
func (o *I2C_Type) SetCTLR2_LAST(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCTLR2_LAST() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCTLR2_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCTLR2_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCTLR2_ITBUFEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCTLR2_ITBUFEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCTLR2_ITEVTEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetCTLR2_ITEVTEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetCTLR2_ITERREN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetCTLR2_ITERREN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetCTLR2_FREQ(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x3f)|value)
}
func (o *I2C_Type) GetCTLR2_FREQ() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0x3f
}

// I2C.OADDR1: Own address register 1
func (o *I2C_Type) SetOADDR1_ADDMODE(value uint32) {
	volatile.StoreUint32(&o.OADDR1.Reg, volatile.LoadUint32(&o.OADDR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOADDR1_ADDMODE() uint32 {
	return (volatile.LoadUint32(&o.OADDR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetOADDR1_ADD9_8(value uint32) {
	volatile.StoreUint32(&o.OADDR1.Reg, volatile.LoadUint32(&o.OADDR1.Reg)&^(0x300)|value<<8)
}
func (o *I2C_Type) GetOADDR1_ADD9_8() uint32 {
	return (volatile.LoadUint32(&o.OADDR1.Reg) & 0x300) >> 8
}
func (o *I2C_Type) SetOADDR1_ADD7_1(value uint32) {
	volatile.StoreUint32(&o.OADDR1.Reg, volatile.LoadUint32(&o.OADDR1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOADDR1_ADD7_1() uint32 {
	return (volatile.LoadUint32(&o.OADDR1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOADDR1_ADD0(value uint32) {
	volatile.StoreUint32(&o.OADDR1.Reg, volatile.LoadUint32(&o.OADDR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetOADDR1_ADD0() uint32 {
	return volatile.LoadUint32(&o.OADDR1.Reg) & 0x1
}

// I2C.OADDR2: Own address register 2
func (o *I2C_Type) SetOADDR2_ADD2(value uint32) {
	volatile.StoreUint32(&o.OADDR2.Reg, volatile.LoadUint32(&o.OADDR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOADDR2_ADD2() uint32 {
	return (volatile.LoadUint32(&o.OADDR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOADDR2_ENDUAL(value uint32) {
	volatile.StoreUint32(&o.OADDR2.Reg, volatile.LoadUint32(&o.OADDR2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetOADDR2_ENDUAL() uint32 {
	return volatile.LoadUint32(&o.OADDR2.Reg) & 0x1
}

// I2C.DATAR: Data register
func (o *I2C_Type) SetDATAR(value uint32) {
	volatile.StoreUint32(&o.DATAR.Reg, volatile.LoadUint32(&o.DATAR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATAR() uint32 {
	return volatile.LoadUint32(&o.DATAR.Reg) & 0xff
}

// I2C.STAR1: Status register 1
func (o *I2C_Type) SetSTAR1_PECERR(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetSTAR1_PECERR() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetSTAR1_OVR(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetSTAR1_OVR() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetSTAR1_AF(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetSTAR1_AF() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetSTAR1_ARLO(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetSTAR1_ARLO() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetSTAR1_BERR(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetSTAR1_BERR() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetSTAR1_TxE(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSTAR1_TxE() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetSTAR1_RxNE(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSTAR1_RxNE() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSTAR1_STOPF(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSTAR1_STOPF() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSTAR1_ADD10(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSTAR1_ADD10() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSTAR1_BTF(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetSTAR1_BTF() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetSTAR1_ADDR(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSTAR1_ADDR() uint32 {
	return (volatile.LoadUint32(&o.STAR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSTAR1_SB(value uint32) {
	volatile.StoreUint32(&o.STAR1.Reg, volatile.LoadUint32(&o.STAR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSTAR1_SB() uint32 {
	return volatile.LoadUint32(&o.STAR1.Reg) & 0x1
}

// I2C.STAR2: Status register 2
func (o *I2C_Type) SetSTAR2_PEC(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetSTAR2_PEC() uint32 {
	return (volatile.LoadUint32(&o.STAR2.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetSTAR2_DUALF(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSTAR2_DUALF() uint32 {
	return (volatile.LoadUint32(&o.STAR2.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetSTAR2_GENCALL(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSTAR2_GENCALL() uint32 {
	return (volatile.LoadUint32(&o.STAR2.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSTAR2_TRA(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetSTAR2_TRA() uint32 {
	return (volatile.LoadUint32(&o.STAR2.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetSTAR2_BUSY(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSTAR2_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STAR2.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSTAR2_MSL(value uint32) {
	volatile.StoreUint32(&o.STAR2.Reg, volatile.LoadUint32(&o.STAR2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSTAR2_MSL() uint32 {
	return volatile.LoadUint32(&o.STAR2.Reg) & 0x1
}

// I2C.CKCFGR: Clock control register
func (o *I2C_Type) SetCKCFGR_F_S(value uint32) {
	volatile.StoreUint32(&o.CKCFGR.Reg, volatile.LoadUint32(&o.CKCFGR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCKCFGR_F_S() uint32 {
	return (volatile.LoadUint32(&o.CKCFGR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCKCFGR_DUTY(value uint32) {
	volatile.StoreUint32(&o.CKCFGR.Reg, volatile.LoadUint32(&o.CKCFGR.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCKCFGR_DUTY() uint32 {
	return (volatile.LoadUint32(&o.CKCFGR.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCKCFGR_CCR(value uint32) {
	volatile.StoreUint32(&o.CKCFGR.Reg, volatile.LoadUint32(&o.CKCFGR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetCKCFGR_CCR() uint32 {
	return volatile.LoadUint32(&o.CKCFGR.Reg) & 0xfff
}

// Serial peripheral interface
type SPI_Type struct {
	CTLR1 volatile.Register32 // 0x0
	CTLR2 volatile.Register32 // 0x4
	STATR volatile.Register32 // 0x8
	DATAR volatile.Register32 // 0xC
	CRCR  volatile.Register32 // 0x10
	RCRCR volatile.Register32 // 0x14
	TCRCR volatile.Register32 // 0x18
	_     [8]byte
	HSCR  volatile.Register32 // 0x24
}

// SPI.CTLR1: control register 1
func (o *SPI_Type) SetCTLR1_BIDIMODE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCTLR1_BIDIMODE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCTLR1_BIDIOE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCTLR1_BIDIOE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCTLR1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCTLR1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCTLR1_CRCNEXT(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCTLR1_CRCNEXT() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCTLR1_DFF(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCTLR1_DFF() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCTLR1_RXONLY(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCTLR1_RXONLY() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCTLR1_SSM(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCTLR1_SSM() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCTLR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCTLR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCTLR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCTLR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCTLR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCTLR1_SPE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCTLR1_BR(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetCTLR1_BR() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetCTLR1_MSTR(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCTLR1_MSTR() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCTLR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCTLR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCTLR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCTLR1_CPHA() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1
}

// SPI.CTLR2: control register 2
func (o *SPI_Type) SetCTLR2_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCTLR2_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCTLR2_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCTLR2_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCTLR2_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCTLR2_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCTLR2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCTLR2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCTLR2_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCTLR2_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCTLR2_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCTLR2_RXDMAEN() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0x1
}

// SPI.STATR: status register
func (o *SPI_Type) SetSTATR_BSY(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSTATR_BSY() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSTATR_OVR(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSTATR_OVR() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSTATR_MODF(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSTATR_MODF() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSTATR_CRCERR(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSTATR_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSTATR_CHSID(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSTATR_CHSID() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSTATR_UDR(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSTATR_UDR() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSTATR_TXE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSTATR_TXE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSTATR_RXNE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSTATR_RXNE() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}

// SPI.DATAR: data register
func (o *SPI_Type) SetDATAR(value uint32) {
	volatile.StoreUint32(&o.DATAR.Reg, volatile.LoadUint32(&o.DATAR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDATAR() uint32 {
	return volatile.LoadUint32(&o.DATAR.Reg) & 0xffff
}

// SPI.CRCR: CRCR polynomial register
func (o *SPI_Type) SetCRCR_CRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCR.Reg, volatile.LoadUint32(&o.CRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCRCR_CRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCR.Reg) & 0xffff
}

// SPI.RCRCR: RX CRC register
func (o *SPI_Type) SetRCRCR_RXCRC(value uint32) {
	volatile.StoreUint32(&o.RCRCR.Reg, volatile.LoadUint32(&o.RCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRCRCR_RXCRC() uint32 {
	return volatile.LoadUint32(&o.RCRCR.Reg) & 0xffff
}

// SPI.TCRCR: send CRC register
func (o *SPI_Type) SetTCRCR_TXCRC(value uint32) {
	volatile.StoreUint32(&o.TCRCR.Reg, volatile.LoadUint32(&o.TCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTCRCR_TXCRC() uint32 {
	return volatile.LoadUint32(&o.TCRCR.Reg) & 0xffff
}

// SPI.HSCR: high speed control register
func (o *SPI_Type) SetHSCR_HSRXEN(value uint32) {
	volatile.StoreUint32(&o.HSCR.Reg, volatile.LoadUint32(&o.HSCR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetHSCR_HSRXEN() uint32 {
	return volatile.LoadUint32(&o.HSCR.Reg) & 0x1
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	STATR volatile.Register32 // 0x0
	DATAR volatile.Register32 // 0x4
	BRR   volatile.Register32 // 0x8
	CTLR1 volatile.Register32 // 0xC
	CTLR2 volatile.Register32 // 0x10
	CTLR3 volatile.Register32 // 0x14
	GPR   volatile.Register32 // 0x18
}

// USART.STATR: Status register
func (o *USART_Type) SetSTATR_CTS(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetSTATR_CTS() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetSTATR_LBD(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetSTATR_LBD() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetSTATR_TXE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetSTATR_TXE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetSTATR_TC(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetSTATR_TC() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetSTATR_RXNE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetSTATR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetSTATR_IDLE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetSTATR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetSTATR_ORE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetSTATR_ORE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetSTATR_NE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetSTATR_NE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetSTATR_FE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetSTATR_FE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetSTATR_PE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetSTATR_PE() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}

// USART.DATAR: Data register
func (o *USART_Type) SetDATAR_DR(value uint32) {
	volatile.StoreUint32(&o.DATAR.Reg, volatile.LoadUint32(&o.DATAR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetDATAR_DR() uint32 {
	return volatile.LoadUint32(&o.DATAR.Reg) & 0x1ff
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR_DIV_Mantissa(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xfff0)|value<<4)
}
func (o *USART_Type) GetBRR_DIV_Mantissa() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0xfff0) >> 4
}
func (o *USART_Type) SetBRR_DIV_Fraction(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetBRR_DIV_Fraction() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xf
}

// USART.CTLR1: Control register 1
func (o *USART_Type) SetCTLR1_UE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCTLR1_UE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCTLR1_M(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCTLR1_M() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCTLR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCTLR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCTLR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCTLR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCTLR1_PS(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCTLR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCTLR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCTLR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCTLR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCTLR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCTLR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCTLR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCTLR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCTLR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCTLR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCTLR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCTLR1_TE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCTLR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCTLR1_RE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCTLR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCTLR1_RWU(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCTLR1_RWU() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCTLR1_SBK(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCTLR1_SBK() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1
}

// USART.CTLR2: Control register 2
func (o *USART_Type) SetCTLR2_LINEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCTLR2_LINEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCTLR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCTLR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCTLR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCTLR2_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCTLR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCTLR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCTLR2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCTLR2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCTLR2_LBCL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCTLR2_LBCL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCTLR2_LBDIE(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCTLR2_LBDIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCTLR2_LBDL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCTLR2_LBDL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCTLR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetCTLR2_ADD() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0xf
}

// USART.CTLR3: Control register 3
func (o *USART_Type) SetCTLR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCTLR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCTLR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCTLR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCTLR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCTLR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCTLR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCTLR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCTLR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCTLR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCTLR3_SCEN(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCTLR3_SCEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCTLR3_NACK(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCTLR3_NACK() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCTLR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCTLR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCTLR3_IRLP(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCTLR3_IRLP() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCTLR3_IREN(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCTLR3_IREN() uint32 {
	return (volatile.LoadUint32(&o.CTLR3.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCTLR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CTLR3.Reg, volatile.LoadUint32(&o.CTLR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCTLR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CTLR3.Reg) & 0x1
}

// USART.GPR: Guard time and prescaler register
func (o *USART_Type) SetGPR_GT(value uint32) {
	volatile.StoreUint32(&o.GPR.Reg, volatile.LoadUint32(&o.GPR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetGPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GPR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetGPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GPR.Reg, volatile.LoadUint32(&o.GPR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetGPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GPR.Reg) & 0xff
}

// Analog to digital converter
type ADC1_Type struct {
	STATR           volatile.Register32 // 0x0
	CTLR1           volatile.Register32 // 0x4
	CTLR2           volatile.Register32 // 0x8
	SAMPTR1_CHARGE1 volatile.Register32 // 0xC
	SAMPTR2_CHARGE2 volatile.Register32 // 0x10
	IOFR1           volatile.Register32 // 0x14
	IOFR2           volatile.Register32 // 0x18
	IOFR3           volatile.Register32 // 0x1C
	IOFR4           volatile.Register32 // 0x20
	WDHTR           volatile.Register32 // 0x24
	WDLTR           volatile.Register32 // 0x28
	RSQR1           volatile.Register32 // 0x2C
	RSQR2           volatile.Register32 // 0x30
	RSQR3           volatile.Register32 // 0x34
	ISQR            volatile.Register32 // 0x38
	IDATAR1         volatile.Register32 // 0x3C
	IDATAR2         volatile.Register32 // 0x40
	IDATAR3         volatile.Register32 // 0x44
	IDATAR4         volatile.Register32 // 0x48
	RDATAR          volatile.Register32 // 0x4C
	DLYR            volatile.Register32 // 0x50
}

// ADC1.STATR: status register
func (o *ADC1_Type) SetSTATR_STRT(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x10)|value<<4)
}
func (o *ADC1_Type) GetSTATR_STRT() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x10) >> 4
}
func (o *ADC1_Type) SetSTATR_JSTRT(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x8)|value<<3)
}
func (o *ADC1_Type) GetSTATR_JSTRT() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x8) >> 3
}
func (o *ADC1_Type) SetSTATR_JEOC(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x4)|value<<2)
}
func (o *ADC1_Type) GetSTATR_JEOC() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x4) >> 2
}
func (o *ADC1_Type) SetSTATR_EOC(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x2)|value<<1)
}
func (o *ADC1_Type) GetSTATR_EOC() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x2) >> 1
}
func (o *ADC1_Type) SetSTATR_AWD(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *ADC1_Type) GetSTATR_AWD() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}

// ADC1.CTLR1: control register 1/TKEY_V_CTLR
func (o *ADC1_Type) SetCTLR1_ADC_CAL_VOL(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x6000000)|value<<25)
}
func (o *ADC1_Type) GetCTLR1_ADC_CAL_VOL() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x6000000) >> 25
}
func (o *ADC1_Type) SetCTLR1_AWDEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x800000)|value<<23)
}
func (o *ADC1_Type) GetCTLR1_AWDEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x800000) >> 23
}
func (o *ADC1_Type) SetCTLR1_JAWDEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x400000)|value<<22)
}
func (o *ADC1_Type) GetCTLR1_JAWDEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x400000) >> 22
}
func (o *ADC1_Type) SetCTLR1_DISCNUM(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0xe000)|value<<13)
}
func (o *ADC1_Type) GetCTLR1_DISCNUM() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0xe000) >> 13
}
func (o *ADC1_Type) SetCTLR1_JDISCEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC1_Type) GetCTLR1_JDISCEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x1000) >> 12
}
func (o *ADC1_Type) SetCTLR1_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC1_Type) GetCTLR1_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x800) >> 11
}
func (o *ADC1_Type) SetCTLR1_JAUTO(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC1_Type) GetCTLR1_JAUTO() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x400) >> 10
}
func (o *ADC1_Type) SetCTLR1_AWDSGL(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC1_Type) GetCTLR1_AWDSGL() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x200) >> 9
}
func (o *ADC1_Type) SetCTLR1_SCAN(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC1_Type) GetCTLR1_SCAN() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x100) >> 8
}
func (o *ADC1_Type) SetCTLR1_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC1_Type) GetCTLR1_JEOCIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x80) >> 7
}
func (o *ADC1_Type) SetCTLR1_AWDIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC1_Type) GetCTLR1_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x40) >> 6
}
func (o *ADC1_Type) SetCTLR1_EOCIE(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC1_Type) GetCTLR1_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR1.Reg) & 0x20) >> 5
}
func (o *ADC1_Type) SetCTLR1_AWDCH(value uint32) {
	volatile.StoreUint32(&o.CTLR1.Reg, volatile.LoadUint32(&o.CTLR1.Reg)&^(0x1f)|value)
}
func (o *ADC1_Type) GetCTLR1_AWDCH() uint32 {
	return volatile.LoadUint32(&o.CTLR1.Reg) & 0x1f
}

// ADC1.CTLR2: control register 2
func (o *ADC1_Type) SetCTLR2_SWSTART(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x400000)|value<<22)
}
func (o *ADC1_Type) GetCTLR2_SWSTART() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x400000) >> 22
}
func (o *ADC1_Type) SetCTLR2_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x200000)|value<<21)
}
func (o *ADC1_Type) GetCTLR2_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x200000) >> 21
}
func (o *ADC1_Type) SetCTLR2_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x100000)|value<<20)
}
func (o *ADC1_Type) GetCTLR2_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x100000) >> 20
}
func (o *ADC1_Type) SetCTLR2_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0xe0000)|value<<17)
}
func (o *ADC1_Type) GetCTLR2_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0xe0000) >> 17
}
func (o *ADC1_Type) SetCTLR2_JEXTTRIG(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x8000)|value<<15)
}
func (o *ADC1_Type) GetCTLR2_JEXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x8000) >> 15
}
func (o *ADC1_Type) SetCTLR2_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x7000)|value<<12)
}
func (o *ADC1_Type) GetCTLR2_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x7000) >> 12
}
func (o *ADC1_Type) SetCTLR2_ALIGN(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x800)|value<<11)
}
func (o *ADC1_Type) GetCTLR2_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x800) >> 11
}
func (o *ADC1_Type) SetCTLR2_DMA(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x100)|value<<8)
}
func (o *ADC1_Type) GetCTLR2_DMA() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x100) >> 8
}
func (o *ADC1_Type) SetCTLR2_RSTCAL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x8)|value<<3)
}
func (o *ADC1_Type) GetCTLR2_RSTCAL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x8) >> 3
}
func (o *ADC1_Type) SetCTLR2_CAL(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x4)|value<<2)
}
func (o *ADC1_Type) GetCTLR2_CAL() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x4) >> 2
}
func (o *ADC1_Type) SetCTLR2_CONT(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x2)|value<<1)
}
func (o *ADC1_Type) GetCTLR2_CONT() uint32 {
	return (volatile.LoadUint32(&o.CTLR2.Reg) & 0x2) >> 1
}
func (o *ADC1_Type) SetCTLR2_ADON(value uint32) {
	volatile.StoreUint32(&o.CTLR2.Reg, volatile.LoadUint32(&o.CTLR2.Reg)&^(0x1)|value)
}
func (o *ADC1_Type) GetCTLR2_ADON() uint32 {
	return volatile.LoadUint32(&o.CTLR2.Reg) & 0x1
}

// ADC1.SAMPTR1_CHARGE1: sample time register 1
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP10_TKCG10(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0x7)|value)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP10_TKCG10() uint32 {
	return volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0x7
}
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP11_TKCG11(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0x38)|value<<3)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP11_TKCG11() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0x38) >> 3
}
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP12_TKCG12(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP12_TKCG12() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0x1c0) >> 6
}
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP13_TKCG13(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0xe00)|value<<9)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP13_TKCG13() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0xe00) >> 9
}
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP14_TKCG14(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0x7000)|value<<12)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP14_TKCG14() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0x7000) >> 12
}
func (o *ADC1_Type) SetSAMPTR1_CHARGE1_SMP15_TKCG15(value uint32) {
	volatile.StoreUint32(&o.SAMPTR1_CHARGE1.Reg, volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg)&^(0x38000)|value<<15)
}
func (o *ADC1_Type) GetSAMPTR1_CHARGE1_SMP15_TKCG15() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR1_CHARGE1.Reg) & 0x38000) >> 15
}

// ADC1.SAMPTR2_CHARGE2: sample time register 2
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP0_TKCG0(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x7)|value)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP0_TKCG0() uint32 {
	return volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x7
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP1_TKCG1(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x38)|value<<3)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP1_TKCG1() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x38) >> 3
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP2_TKCG2(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP2_TKCG2() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x1c0) >> 6
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP3_TKCG3(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0xe00)|value<<9)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP3_TKCG3() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0xe00) >> 9
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP4_TKCG4(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x7000)|value<<12)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP4_TKCG4() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x7000) >> 12
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP5_TKCG5(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x38000)|value<<15)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP5_TKCG5() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x38000) >> 15
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP6_TKCG6(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x1c0000)|value<<18)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP6_TKCG6() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x1c0000) >> 18
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP7_TKCG7(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0xe00000)|value<<21)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP7_TKCG7() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0xe00000) >> 21
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP8_TKCG8(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP8_TKCG8() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x7000000) >> 24
}
func (o *ADC1_Type) SetSAMPTR2_CHARGE2_SMP9_TKCG9(value uint32) {
	volatile.StoreUint32(&o.SAMPTR2_CHARGE2.Reg, volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC1_Type) GetSAMPTR2_CHARGE2_SMP9_TKCG9() uint32 {
	return (volatile.LoadUint32(&o.SAMPTR2_CHARGE2.Reg) & 0x38000000) >> 27
}

// ADC1.IOFR1: injected channel data offset register x
func (o *ADC1_Type) SetIOFR1_JOFFSET1(value uint32) {
	volatile.StoreUint32(&o.IOFR1.Reg, volatile.LoadUint32(&o.IOFR1.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetIOFR1_JOFFSET1() uint32 {
	return volatile.LoadUint32(&o.IOFR1.Reg) & 0x3ff
}

// ADC1.IOFR2: injected channel data offset register x
func (o *ADC1_Type) SetIOFR2_JOFFSET2(value uint32) {
	volatile.StoreUint32(&o.IOFR2.Reg, volatile.LoadUint32(&o.IOFR2.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetIOFR2_JOFFSET2() uint32 {
	return volatile.LoadUint32(&o.IOFR2.Reg) & 0x3ff
}

// ADC1.IOFR3: injected channel data offset register x
func (o *ADC1_Type) SetIOFR3_JOFFSET3(value uint32) {
	volatile.StoreUint32(&o.IOFR3.Reg, volatile.LoadUint32(&o.IOFR3.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetIOFR3_JOFFSET3() uint32 {
	return volatile.LoadUint32(&o.IOFR3.Reg) & 0x3ff
}

// ADC1.IOFR4: injected channel data offset register x
func (o *ADC1_Type) SetIOFR4_JOFFSET4(value uint32) {
	volatile.StoreUint32(&o.IOFR4.Reg, volatile.LoadUint32(&o.IOFR4.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetIOFR4_JOFFSET4() uint32 {
	return volatile.LoadUint32(&o.IOFR4.Reg) & 0x3ff
}

// ADC1.WDHTR: watchdog higher threshold register
func (o *ADC1_Type) SetWDHTR_HT(value uint32) {
	volatile.StoreUint32(&o.WDHTR.Reg, volatile.LoadUint32(&o.WDHTR.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetWDHTR_HT() uint32 {
	return volatile.LoadUint32(&o.WDHTR.Reg) & 0x3ff
}

// ADC1.WDLTR: watchdog lower threshold register
func (o *ADC1_Type) SetWDLTR_LT(value uint32) {
	volatile.StoreUint32(&o.WDLTR.Reg, volatile.LoadUint32(&o.WDLTR.Reg)&^(0x3ff)|value)
}
func (o *ADC1_Type) GetWDLTR_LT() uint32 {
	return volatile.LoadUint32(&o.WDLTR.Reg) & 0x3ff
}

// ADC1.RSQR1: regular sequence register 1
func (o *ADC1_Type) SetRSQR1_L(value uint32) {
	volatile.StoreUint32(&o.RSQR1.Reg, volatile.LoadUint32(&o.RSQR1.Reg)&^(0xf00000)|value<<20)
}
func (o *ADC1_Type) GetRSQR1_L() uint32 {
	return (volatile.LoadUint32(&o.RSQR1.Reg) & 0xf00000) >> 20
}
func (o *ADC1_Type) SetRSQR1_SQ16(value uint32) {
	volatile.StoreUint32(&o.RSQR1.Reg, volatile.LoadUint32(&o.RSQR1.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC1_Type) GetRSQR1_SQ16() uint32 {
	return (volatile.LoadUint32(&o.RSQR1.Reg) & 0xf8000) >> 15
}
func (o *ADC1_Type) SetRSQR1_SQ15(value uint32) {
	volatile.StoreUint32(&o.RSQR1.Reg, volatile.LoadUint32(&o.RSQR1.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC1_Type) GetRSQR1_SQ15() uint32 {
	return (volatile.LoadUint32(&o.RSQR1.Reg) & 0x7c00) >> 10
}
func (o *ADC1_Type) SetRSQR1_SQ14(value uint32) {
	volatile.StoreUint32(&o.RSQR1.Reg, volatile.LoadUint32(&o.RSQR1.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC1_Type) GetRSQR1_SQ14() uint32 {
	return (volatile.LoadUint32(&o.RSQR1.Reg) & 0x3e0) >> 5
}
func (o *ADC1_Type) SetRSQR1_SQ13(value uint32) {
	volatile.StoreUint32(&o.RSQR1.Reg, volatile.LoadUint32(&o.RSQR1.Reg)&^(0x1f)|value)
}
func (o *ADC1_Type) GetRSQR1_SQ13() uint32 {
	return volatile.LoadUint32(&o.RSQR1.Reg) & 0x1f
}

// ADC1.RSQR2: regular sequence register 2
func (o *ADC1_Type) SetRSQR2_SQ12(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0x3e000000)|value<<25)
}
func (o *ADC1_Type) GetRSQR2_SQ12() uint32 {
	return (volatile.LoadUint32(&o.RSQR2.Reg) & 0x3e000000) >> 25
}
func (o *ADC1_Type) SetRSQR2_SQ11(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0x1f00000)|value<<20)
}
func (o *ADC1_Type) GetRSQR2_SQ11() uint32 {
	return (volatile.LoadUint32(&o.RSQR2.Reg) & 0x1f00000) >> 20
}
func (o *ADC1_Type) SetRSQR2_SQ10(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC1_Type) GetRSQR2_SQ10() uint32 {
	return (volatile.LoadUint32(&o.RSQR2.Reg) & 0xf8000) >> 15
}
func (o *ADC1_Type) SetRSQR2_SQ9(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC1_Type) GetRSQR2_SQ9() uint32 {
	return (volatile.LoadUint32(&o.RSQR2.Reg) & 0x7c00) >> 10
}
func (o *ADC1_Type) SetRSQR2_SQ8(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC1_Type) GetRSQR2_SQ8() uint32 {
	return (volatile.LoadUint32(&o.RSQR2.Reg) & 0x3e0) >> 5
}
func (o *ADC1_Type) SetRSQR2_SQ7(value uint32) {
	volatile.StoreUint32(&o.RSQR2.Reg, volatile.LoadUint32(&o.RSQR2.Reg)&^(0x1f)|value)
}
func (o *ADC1_Type) GetRSQR2_SQ7() uint32 {
	return volatile.LoadUint32(&o.RSQR2.Reg) & 0x1f
}

// ADC1.RSQR3: regular sequence register 3
func (o *ADC1_Type) SetRSQR3_SQ6(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0x3e000000)|value<<25)
}
func (o *ADC1_Type) GetRSQR3_SQ6() uint32 {
	return (volatile.LoadUint32(&o.RSQR3.Reg) & 0x3e000000) >> 25
}
func (o *ADC1_Type) SetRSQR3_SQ5(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0x1f00000)|value<<20)
}
func (o *ADC1_Type) GetRSQR3_SQ5() uint32 {
	return (volatile.LoadUint32(&o.RSQR3.Reg) & 0x1f00000) >> 20
}
func (o *ADC1_Type) SetRSQR3_SQ4(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC1_Type) GetRSQR3_SQ4() uint32 {
	return (volatile.LoadUint32(&o.RSQR3.Reg) & 0xf8000) >> 15
}
func (o *ADC1_Type) SetRSQR3_SQ3(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC1_Type) GetRSQR3_SQ3() uint32 {
	return (volatile.LoadUint32(&o.RSQR3.Reg) & 0x7c00) >> 10
}
func (o *ADC1_Type) SetRSQR3_SQ2(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC1_Type) GetRSQR3_SQ2() uint32 {
	return (volatile.LoadUint32(&o.RSQR3.Reg) & 0x3e0) >> 5
}
func (o *ADC1_Type) SetRSQR3_SQ1(value uint32) {
	volatile.StoreUint32(&o.RSQR3.Reg, volatile.LoadUint32(&o.RSQR3.Reg)&^(0x1f)|value)
}
func (o *ADC1_Type) GetRSQR3_SQ1() uint32 {
	return volatile.LoadUint32(&o.RSQR3.Reg) & 0x1f
}

// ADC1.ISQR: injected sequence register
func (o *ADC1_Type) SetISQR_JL(value uint32) {
	volatile.StoreUint32(&o.ISQR.Reg, volatile.LoadUint32(&o.ISQR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC1_Type) GetISQR_JL() uint32 {
	return (volatile.LoadUint32(&o.ISQR.Reg) & 0x300000) >> 20
}
func (o *ADC1_Type) SetISQR_JSQ4(value uint32) {
	volatile.StoreUint32(&o.ISQR.Reg, volatile.LoadUint32(&o.ISQR.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC1_Type) GetISQR_JSQ4() uint32 {
	return (volatile.LoadUint32(&o.ISQR.Reg) & 0xf8000) >> 15
}
func (o *ADC1_Type) SetISQR_JSQ3(value uint32) {
	volatile.StoreUint32(&o.ISQR.Reg, volatile.LoadUint32(&o.ISQR.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC1_Type) GetISQR_JSQ3() uint32 {
	return (volatile.LoadUint32(&o.ISQR.Reg) & 0x7c00) >> 10
}
func (o *ADC1_Type) SetISQR_JSQ2(value uint32) {
	volatile.StoreUint32(&o.ISQR.Reg, volatile.LoadUint32(&o.ISQR.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC1_Type) GetISQR_JSQ2() uint32 {
	return (volatile.LoadUint32(&o.ISQR.Reg) & 0x3e0) >> 5
}
func (o *ADC1_Type) SetISQR_JSQ1(value uint32) {
	volatile.StoreUint32(&o.ISQR.Reg, volatile.LoadUint32(&o.ISQR.Reg)&^(0x1f)|value)
}
func (o *ADC1_Type) GetISQR_JSQ1() uint32 {
	return volatile.LoadUint32(&o.ISQR.Reg) & 0x1f
}

// ADC1.IDATAR1: injected data register 1
func (o *ADC1_Type) SetIDATAR1_IDATA(value uint32) {
	volatile.StoreUint32(&o.IDATAR1.Reg, volatile.LoadUint32(&o.IDATAR1.Reg)&^(0xffff)|value)
}
func (o *ADC1_Type) GetIDATAR1_IDATA() uint32 {
	return volatile.LoadUint32(&o.IDATAR1.Reg) & 0xffff
}

// ADC1.IDATAR2: injected data register 2
func (o *ADC1_Type) SetIDATAR2_IDATA(value uint32) {
	volatile.StoreUint32(&o.IDATAR2.Reg, volatile.LoadUint32(&o.IDATAR2.Reg)&^(0xffff)|value)
}
func (o *ADC1_Type) GetIDATAR2_IDATA() uint32 {
	return volatile.LoadUint32(&o.IDATAR2.Reg) & 0xffff
}

// ADC1.IDATAR3: injected data register 3
func (o *ADC1_Type) SetIDATAR3_IDATA(value uint32) {
	volatile.StoreUint32(&o.IDATAR3.Reg, volatile.LoadUint32(&o.IDATAR3.Reg)&^(0xffff)|value)
}
func (o *ADC1_Type) GetIDATAR3_IDATA() uint32 {
	return volatile.LoadUint32(&o.IDATAR3.Reg) & 0xffff
}

// ADC1.IDATAR4: injected data register 4
func (o *ADC1_Type) SetIDATAR4_IDATA(value uint32) {
	volatile.StoreUint32(&o.IDATAR4.Reg, volatile.LoadUint32(&o.IDATAR4.Reg)&^(0xffff)|value)
}
func (o *ADC1_Type) GetIDATAR4_IDATA() uint32 {
	return volatile.LoadUint32(&o.IDATAR4.Reg) & 0xffff
}

// ADC1.RDATAR: regular data register
func (o *ADC1_Type) SetRDATAR(value uint32) {
	volatile.StoreUint32(&o.RDATAR.Reg, value)
}
func (o *ADC1_Type) GetRDATAR() uint32 {
	return volatile.LoadUint32(&o.RDATAR.Reg)
}

// ADC1.DLYR: delay data register
func (o *ADC1_Type) SetDLYR_DLYVLU(value uint32) {
	volatile.StoreUint32(&o.DLYR.Reg, volatile.LoadUint32(&o.DLYR.Reg)&^(0x1ff)|value)
}
func (o *ADC1_Type) GetDLYR_DLYVLU() uint32 {
	return volatile.LoadUint32(&o.DLYR.Reg) & 0x1ff
}
func (o *ADC1_Type) SetDLYR_DLYSRC(value uint32) {
	volatile.StoreUint32(&o.DLYR.Reg, volatile.LoadUint32(&o.DLYR.Reg)&^(0x200)|value<<9)
}
func (o *ADC1_Type) GetDLYR_DLYSRC() uint32 {
	return (volatile.LoadUint32(&o.DLYR.Reg) & 0x200) >> 9
}

// Debug support
type DBG_Type struct {
	CFGR1 volatile.Register32 // 0x0
	CFGR2 volatile.Register32 // 0x4
}

// DBG.CFGR1: DBGMCU_CFGR1
func (o *DBG_Type) SetCFGR1_DEG_IWDG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetCFGR1_DEG_IWDG() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}
func (o *DBG_Type) SetCFGR1_DEG_WWDG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetCFGR1_DEG_WWDG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetCFGR1_DEG_I2C1(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *DBG_Type) GetCFGR1_DEG_I2C1() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *DBG_Type) SetCFGR1_DEG_TIM1(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10)|value<<4)
}
func (o *DBG_Type) GetCFGR1_DEG_TIM1() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10) >> 4
}
func (o *DBG_Type) SetCFGR1_DEG_TIM2(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DBG_Type) GetCFGR1_DEG_TIM2() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}

// DBG.CFGR2: DBGMCU_CFGR2
func (o *DBG_Type) SetCFGR2_DBG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetCFGR2_DBG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *DBG_Type) SetCFGR2_DBG_STOP(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetCFGR2_DBG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetCFGR2_DBG_STANDBY(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *DBG_Type) GetCFGR2_DBG_STANDBY() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}

// Device electronic signature
type ESIG_Type struct {
	FLACAP volatile.Register16 // 0x0
	_      [6]byte
	UNIID1 volatile.Register32 // 0x8
	UNIID2 volatile.Register32 // 0xC
	UNIID3 volatile.Register32 // 0x10
}

// ESIG.FLACAP: Flash capacity register
func (o *ESIG_Type) SetFLACAP(value uint16) {
	volatile.StoreUint16(&o.FLACAP.Reg, value)
}
func (o *ESIG_Type) GetFLACAP() uint16 {
	return volatile.LoadUint16(&o.FLACAP.Reg)
}

// ESIG.UNIID1: Unique identity 1
func (o *ESIG_Type) SetUNIID1(value uint32) {
	volatile.StoreUint32(&o.UNIID1.Reg, value)
}
func (o *ESIG_Type) GetUNIID1() uint32 {
	return volatile.LoadUint32(&o.UNIID1.Reg)
}

// ESIG.UNIID2: Unique identity 2
func (o *ESIG_Type) SetUNIID2(value uint32) {
	volatile.StoreUint32(&o.UNIID2.Reg, value)
}
func (o *ESIG_Type) GetUNIID2() uint32 {
	return volatile.LoadUint32(&o.UNIID2.Reg)
}

// ESIG.UNIID3: Unique identity 3
func (o *ESIG_Type) SetUNIID3(value uint32) {
	volatile.StoreUint32(&o.UNIID3.Reg, value)
}
func (o *ESIG_Type) GetUNIID3() uint32 {
	return volatile.LoadUint32(&o.UNIID3.Reg)
}

// FLASH
type FLASH_Type struct {
	ACTLR         volatile.Register32 // 0x0
	KEYR          volatile.Register32 // 0x4
	OBKEYR        volatile.Register32 // 0x8
	STATR         volatile.Register32 // 0xC
	CTLR          volatile.Register32 // 0x10
	ADDR          volatile.Register32 // 0x14
	_             [4]byte
	OBR           volatile.Register32 // 0x1C
	WPR           volatile.Register32 // 0x20
	MODEKEYR      volatile.Register32 // 0x24
	BOOT_MODEKEYP volatile.Register32 // 0x28
}

// FLASH.ACTLR: Flash key register
func (o *FLASH_Type) SetACTLR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetACTLR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACTLR.Reg) & 0x1
}

// FLASH.KEYR: Flash key register
func (o *FLASH_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *FLASH_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// FLASH.OBKEYR: Flash option key register
func (o *FLASH_Type) SetOBKEYR(value uint32) {
	volatile.StoreUint32(&o.OBKEYR.Reg, value)
}
func (o *FLASH_Type) GetOBKEYR() uint32 {
	return volatile.LoadUint32(&o.OBKEYR.Reg)
}

// FLASH.STATR: Status register
func (o *FLASH_Type) SetSTATR_BOOT_LOCK(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x8000)|value<<15)
}
func (o *FLASH_Type) GetSTATR_BOOT_LOCK() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x8000) >> 15
}
func (o *FLASH_Type) SetSTATR_BOOT_MODE(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x4000)|value<<14)
}
func (o *FLASH_Type) GetSTATR_BOOT_MODE() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x4000) >> 14
}
func (o *FLASH_Type) SetSTATR_EOP(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetSTATR_EOP() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetSTATR_WRPRTERR(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetSTATR_WRPRTERR() uint32 {
	return (volatile.LoadUint32(&o.STATR.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetSTATR_BSY(value uint32) {
	volatile.StoreUint32(&o.STATR.Reg, volatile.LoadUint32(&o.STATR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetSTATR_BSY() uint32 {
	return volatile.LoadUint32(&o.STATR.Reg) & 0x1
}

// FLASH.CTLR: Control register
func (o *FLASH_Type) SetCTLR_PG(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetCTLR_PG() uint32 {
	return volatile.LoadUint32(&o.CTLR.Reg) & 0x1
}
func (o *FLASH_Type) SetCTLR_PER(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetCTLR_PER() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetCTLR_MER(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetCTLR_MER() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetCTLR_OBPG(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetCTLR_OBPG() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetCTLR_OBER(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetCTLR_OBER() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetCTLR_STRT(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x40)|value<<6)
}
func (o *FLASH_Type) GetCTLR_STRT() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x40) >> 6
}
func (o *FLASH_Type) SetCTLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x80)|value<<7)
}
func (o *FLASH_Type) GetCTLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x80) >> 7
}
func (o *FLASH_Type) SetCTLR_OBWRE(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetCTLR_OBWRE() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetCTLR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *FLASH_Type) GetCTLR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *FLASH_Type) SetCTLR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x1000)|value<<12)
}
func (o *FLASH_Type) GetCTLR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x1000) >> 12
}
func (o *FLASH_Type) SetCTLR_FLOCK(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x8000)|value<<15)
}
func (o *FLASH_Type) GetCTLR_FLOCK() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x8000) >> 15
}
func (o *FLASH_Type) SetCTLR_PAGE_PG(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_Type) GetCTLR_PAGE_PG() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x10000) >> 16
}
func (o *FLASH_Type) SetCTLR_PAGE_ER(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x20000)|value<<17)
}
func (o *FLASH_Type) GetCTLR_PAGE_ER() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x20000) >> 17
}
func (o *FLASH_Type) SetCTLR_BUFLOAD(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x40000)|value<<18)
}
func (o *FLASH_Type) GetCTLR_BUFLOAD() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x40000) >> 18
}
func (o *FLASH_Type) SetCTLR_BUFRST(value uint32) {
	volatile.StoreUint32(&o.CTLR.Reg, volatile.LoadUint32(&o.CTLR.Reg)&^(0x80000)|value<<19)
}
func (o *FLASH_Type) GetCTLR_BUFRST() uint32 {
	return (volatile.LoadUint32(&o.CTLR.Reg) & 0x80000) >> 19
}

// FLASH.ADDR: Flash address register
func (o *FLASH_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *FLASH_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// FLASH.OBR: Option byte register
func (o *FLASH_Type) SetOBR_OBERR(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetOBR_OBERR() uint32 {
	return volatile.LoadUint32(&o.OBR.Reg) & 0x1
}
func (o *FLASH_Type) SetOBR_RDPRT(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetOBR_RDPRT() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetOBR_IWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetOBR_IWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetOBR_STOP_RST(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x8)|value<<3)
}
func (o *FLASH_Type) GetOBR_STOP_RST() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x8) >> 3
}
func (o *FLASH_Type) SetOBR_STANDY_RST(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetOBR_STANDY_RST() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetOBR_CFG_RST_MODE(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x60)|value<<5)
}
func (o *FLASH_Type) GetOBR_CFG_RST_MODE() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x60) >> 5
}
func (o *FLASH_Type) SetOBR_DATA0(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x3fc00)|value<<10)
}
func (o *FLASH_Type) GetOBR_DATA0() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x3fc00) >> 10
}
func (o *FLASH_Type) SetOBR_DATA1(value uint32) {
	volatile.StoreUint32(&o.OBR.Reg, volatile.LoadUint32(&o.OBR.Reg)&^(0x3fc0000)|value<<18)
}
func (o *FLASH_Type) GetOBR_DATA1() uint32 {
	return (volatile.LoadUint32(&o.OBR.Reg) & 0x3fc0000) >> 18
}

// FLASH.WPR: Write protection register
func (o *FLASH_Type) SetWPR(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, value)
}
func (o *FLASH_Type) GetWPR() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg)
}

// FLASH.MODEKEYR: Mode select register
func (o *FLASH_Type) SetMODEKEYR(value uint32) {
	volatile.StoreUint32(&o.MODEKEYR.Reg, value)
}
func (o *FLASH_Type) GetMODEKEYR() uint32 {
	return volatile.LoadUint32(&o.MODEKEYR.Reg)
}

// FLASH.BOOT_MODEKEYP: Boot mode key register
func (o *FLASH_Type) SetBOOT_MODEKEYP(value uint32) {
	volatile.StoreUint32(&o.BOOT_MODEKEYP.Reg, value)
}
func (o *FLASH_Type) GetBOOT_MODEKEYP() uint32 {
	return volatile.LoadUint32(&o.BOOT_MODEKEYP.Reg)
}

// Programmable Fast Interrupt Controller
type PFIC_Type struct {
	ISR1      volatile.Register32 // 0x0
	ISR2      volatile.Register32 // 0x4
	ISR3      volatile.Register32 // 0x8
	ISR4      volatile.Register32 // 0xC
	_         [16]byte
	IPR1      volatile.Register32 // 0x20
	IPR2      volatile.Register32 // 0x24
	IPR3      volatile.Register32 // 0x28
	IPR4      volatile.Register32 // 0x2C
	_         [16]byte
	ITHRESDR  volatile.Register32 // 0x40
	_         [4]byte
	CFGR      volatile.Register32 // 0x48
	GISR      volatile.Register32 // 0x4C
	VTFIDR    volatile.Register32 // 0x50
	_         [12]byte
	VTFADDRR0 volatile.Register32 // 0x60
	VTFADDRR1 volatile.Register32 // 0x64
	VTFADDRR2 volatile.Register32 // 0x68
	VTFADDRR3 volatile.Register32 // 0x6C
	_         [144]byte
	IENR1     volatile.Register32 // 0x100
	IENR2     volatile.Register32 // 0x104
	IENR3     volatile.Register32 // 0x108
	IENR4     volatile.Register32 // 0x10C
	_         [112]byte
	IRER1     volatile.Register32 // 0x180
	IRER2     volatile.Register32 // 0x184
	IRER3     volatile.Register32 // 0x188
	IRER4     volatile.Register32 // 0x18C
	_         [112]byte
	IPSR1     volatile.Register32 // 0x200
	IPSR2     volatile.Register32 // 0x204
	IPSR3     volatile.Register32 // 0x208
	IPSR4     volatile.Register32 // 0x20C
	_         [112]byte
	IPRR1     volatile.Register32 // 0x280
	IPRR2     volatile.Register32 // 0x284
	IPRR3     volatile.Register32 // 0x288
	IPRR4     volatile.Register32 // 0x28C
	_         [112]byte
	IACTR1    volatile.Register32 // 0x300
	IACTR2    volatile.Register32 // 0x304
	IACTR3    volatile.Register32 // 0x308
	IACTR4    volatile.Register32 // 0x30C
	_         [240]byte
	IPRIOR0   volatile.Register8 // 0x400
	IPRIOR1   volatile.Register8 // 0x401
	IPRIOR2   volatile.Register8 // 0x402
	IPRIOR3   volatile.Register8 // 0x403
	IPRIOR4   volatile.Register8 // 0x404
	IPRIOR5   volatile.Register8 // 0x405
	IPRIOR6   volatile.Register8 // 0x406
	IPRIOR7   volatile.Register8 // 0x407
	IPRIOR8   volatile.Register8 // 0x408
	IPRIOR9   volatile.Register8 // 0x409
	IPRIOR10  volatile.Register8 // 0x40A
	IPRIOR11  volatile.Register8 // 0x40B
	IPRIOR12  volatile.Register8 // 0x40C
	IPRIOR13  volatile.Register8 // 0x40D
	IPRIOR14  volatile.Register8 // 0x40E
	IPRIOR15  volatile.Register8 // 0x40F
	IPRIOR16  volatile.Register8 // 0x410
	IPRIOR17  volatile.Register8 // 0x411
	IPRIOR18  volatile.Register8 // 0x412
	IPRIOR19  volatile.Register8 // 0x413
	IPRIOR20  volatile.Register8 // 0x414
	IPRIOR21  volatile.Register8 // 0x415
	IPRIOR22  volatile.Register8 // 0x416
	IPRIOR23  volatile.Register8 // 0x417
	IPRIOR24  volatile.Register8 // 0x418
	IPRIOR25  volatile.Register8 // 0x419
	IPRIOR26  volatile.Register8 // 0x41A
	IPRIOR27  volatile.Register8 // 0x41B
	IPRIOR28  volatile.Register8 // 0x41C
	IPRIOR29  volatile.Register8 // 0x41D
	IPRIOR30  volatile.Register8 // 0x41E
	IPRIOR31  volatile.Register8 // 0x41F
	IPRIOR32  volatile.Register8 // 0x420
	IPRIOR33  volatile.Register8 // 0x421
	IPRIOR34  volatile.Register8 // 0x422
	IPRIOR35  volatile.Register8 // 0x423
	IPRIOR36  volatile.Register8 // 0x424
	IPRIOR37  volatile.Register8 // 0x425
	IPRIOR38  volatile.Register8 // 0x426
	IPRIOR39  volatile.Register8 // 0x427
	IPRIOR40  volatile.Register8 // 0x428
	IPRIOR41  volatile.Register8 // 0x429
	IPRIOR42  volatile.Register8 // 0x42A
	IPRIOR43  volatile.Register8 // 0x42B
	IPRIOR44  volatile.Register8 // 0x42C
	IPRIOR45  volatile.Register8 // 0x42D
	IPRIOR46  volatile.Register8 // 0x42E
	IPRIOR47  volatile.Register8 // 0x42F
	IPRIOR48  volatile.Register8 // 0x430
	IPRIOR49  volatile.Register8 // 0x431
	IPRIOR50  volatile.Register8 // 0x432
	IPRIOR51  volatile.Register8 // 0x433
	IPRIOR52  volatile.Register8 // 0x434
	IPRIOR53  volatile.Register8 // 0x435
	IPRIOR54  volatile.Register8 // 0x436
	IPRIOR55  volatile.Register8 // 0x437
	IPRIOR56  volatile.Register8 // 0x438
	IPRIOR57  volatile.Register8 // 0x439
	IPRIOR58  volatile.Register8 // 0x43A
	IPRIOR59  volatile.Register8 // 0x43B
	IPRIOR60  volatile.Register8 // 0x43C
	IPRIOR61  volatile.Register8 // 0x43D
	IPRIOR62  volatile.Register8 // 0x43E
	IPRIOR63  volatile.Register8 // 0x43F
	_         [2256]byte
	SCTLR     volatile.Register32 // 0xD10
	_         [748]byte
	STK_CTLR  volatile.Register32 // 0x1000
	STK_SR    volatile.Register32 // 0x1004
	STK_CNTL  volatile.Register32 // 0x1008
	_         [4]byte
	STK_CMPLR volatile.Register32 // 0x1010
}

// PFIC.ISR1: Interrupt Status Register
func (o *PFIC_Type) SetISR1_INTENSTA2_3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0xc)|value<<2)
}
func (o *PFIC_Type) GetISR1_INTENSTA2_3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0xc) >> 2
}
func (o *PFIC_Type) SetISR1_INTENSTA12_31(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetISR1_INTENSTA12_31() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0xfffff000) >> 12
}

// PFIC.ISR2: Interrupt Status Register
func (o *PFIC_Type) SetISR2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, value)
}
func (o *PFIC_Type) GetISR2() uint32 {
	return volatile.LoadUint32(&o.ISR2.Reg)
}

// PFIC.ISR3: Interrupt Status Register
func (o *PFIC_Type) SetISR3(value uint32) {
	volatile.StoreUint32(&o.ISR3.Reg, value)
}
func (o *PFIC_Type) GetISR3() uint32 {
	return volatile.LoadUint32(&o.ISR3.Reg)
}

// PFIC.ISR4: Interrupt Status Register
func (o *PFIC_Type) SetISR4_INTENSTA(value uint32) {
	volatile.StoreUint32(&o.ISR4.Reg, volatile.LoadUint32(&o.ISR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetISR4_INTENSTA() uint32 {
	return volatile.LoadUint32(&o.ISR4.Reg) & 0xff
}

// PFIC.IPR1: Interrupt Pending Register
func (o *PFIC_Type) SetIPR1_PENDSTA2_3(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xc)|value<<2)
}
func (o *PFIC_Type) GetIPR1_PENDSTA2_3() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xc) >> 2
}
func (o *PFIC_Type) SetIPR1_PENDSTA12_31(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIPR1_PENDSTA12_31() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xfffff000) >> 12
}

// PFIC.IPR2: Interrupt Pending Register
func (o *PFIC_Type) SetIPR2(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, value)
}
func (o *PFIC_Type) GetIPR2() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg)
}

// PFIC.IPR3: Interrupt Pending Register
func (o *PFIC_Type) SetIPR3(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, value)
}
func (o *PFIC_Type) GetIPR3() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg)
}

// PFIC.IPR4: Interrupt Pending Register
func (o *PFIC_Type) SetIPR4_PENDSTA(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIPR4_PENDSTA() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}

// PFIC.ITHRESDR: Interrupt Priority Register
func (o *PFIC_Type) SetITHRESDR_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.ITHRESDR.Reg, volatile.LoadUint32(&o.ITHRESDR.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetITHRESDR_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.ITHRESDR.Reg) & 0xff
}

// PFIC.CFGR: Interrupt Config Register
func (o *PFIC_Type) SetCFGR_RESETSYS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80)|value<<7)
}
func (o *PFIC_Type) GetCFGR_RESETSYS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80) >> 7
}
func (o *PFIC_Type) SetCFGR_KEYCODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PFIC_Type) GetCFGR_KEYCODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xffff0000) >> 16
}

// PFIC.GISR: Interrupt Global Register
func (o *PFIC_Type) SetGISR_NESTSTA(value uint32) {
	volatile.StoreUint32(&o.GISR.Reg, volatile.LoadUint32(&o.GISR.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetGISR_NESTSTA() uint32 {
	return volatile.LoadUint32(&o.GISR.Reg) & 0xff
}
func (o *PFIC_Type) SetGISR_GACTSTA(value uint32) {
	volatile.StoreUint32(&o.GISR.Reg, volatile.LoadUint32(&o.GISR.Reg)&^(0x100)|value<<8)
}
func (o *PFIC_Type) GetGISR_GACTSTA() uint32 {
	return (volatile.LoadUint32(&o.GISR.Reg) & 0x100) >> 8
}
func (o *PFIC_Type) SetGISR_GPENDSTA(value uint32) {
	volatile.StoreUint32(&o.GISR.Reg, volatile.LoadUint32(&o.GISR.Reg)&^(0x200)|value<<9)
}
func (o *PFIC_Type) GetGISR_GPENDSTA() uint32 {
	return (volatile.LoadUint32(&o.GISR.Reg) & 0x200) >> 9
}

// PFIC.VTFIDR: ID Config Register
func (o *PFIC_Type) SetVTFIDR_VTFID0(value uint32) {
	volatile.StoreUint32(&o.VTFIDR.Reg, volatile.LoadUint32(&o.VTFIDR.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetVTFIDR_VTFID0() uint32 {
	return volatile.LoadUint32(&o.VTFIDR.Reg) & 0xff
}
func (o *PFIC_Type) SetVTFIDR_VTFID1(value uint32) {
	volatile.StoreUint32(&o.VTFIDR.Reg, volatile.LoadUint32(&o.VTFIDR.Reg)&^(0xff00)|value<<8)
}
func (o *PFIC_Type) GetVTFIDR_VTFID1() uint32 {
	return (volatile.LoadUint32(&o.VTFIDR.Reg) & 0xff00) >> 8
}
func (o *PFIC_Type) SetVTFIDR_VTFID2(value uint32) {
	volatile.StoreUint32(&o.VTFIDR.Reg, volatile.LoadUint32(&o.VTFIDR.Reg)&^(0xff0000)|value<<16)
}
func (o *PFIC_Type) GetVTFIDR_VTFID2() uint32 {
	return (volatile.LoadUint32(&o.VTFIDR.Reg) & 0xff0000) >> 16
}
func (o *PFIC_Type) SetVTFIDR_VTFID3(value uint32) {
	volatile.StoreUint32(&o.VTFIDR.Reg, volatile.LoadUint32(&o.VTFIDR.Reg)&^(0xff000000)|value<<24)
}
func (o *PFIC_Type) GetVTFIDR_VTFID3() uint32 {
	return (volatile.LoadUint32(&o.VTFIDR.Reg) & 0xff000000) >> 24
}

// PFIC.VTFADDRR0: Interrupt 0 address Register
func (o *PFIC_Type) SetVTFADDRR0_VTF0EN(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR0.Reg, volatile.LoadUint32(&o.VTFADDRR0.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetVTFADDRR0_VTF0EN() uint32 {
	return volatile.LoadUint32(&o.VTFADDRR0.Reg) & 0x1
}
func (o *PFIC_Type) SetVTFADDRR0__ADDR0(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR0.Reg, volatile.LoadUint32(&o.VTFADDRR0.Reg)&^(0xfffffffe)|value<<1)
}
func (o *PFIC_Type) GetVTFADDRR0__ADDR0() uint32 {
	return (volatile.LoadUint32(&o.VTFADDRR0.Reg) & 0xfffffffe) >> 1
}

// PFIC.VTFADDRR1: Interrupt 1 address Register
func (o *PFIC_Type) SetVTFADDRR1_VTF1EN(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR1.Reg, volatile.LoadUint32(&o.VTFADDRR1.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetVTFADDRR1_VTF1EN() uint32 {
	return volatile.LoadUint32(&o.VTFADDRR1.Reg) & 0x1
}
func (o *PFIC_Type) SetVTFADDRR1__ADDR1(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR1.Reg, volatile.LoadUint32(&o.VTFADDRR1.Reg)&^(0xfffffffe)|value<<1)
}
func (o *PFIC_Type) GetVTFADDRR1__ADDR1() uint32 {
	return (volatile.LoadUint32(&o.VTFADDRR1.Reg) & 0xfffffffe) >> 1
}

// PFIC.VTFADDRR2: Interrupt 2 address Register
func (o *PFIC_Type) SetVTFADDRR2_VTF2EN(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR2.Reg, volatile.LoadUint32(&o.VTFADDRR2.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetVTFADDRR2_VTF2EN() uint32 {
	return volatile.LoadUint32(&o.VTFADDRR2.Reg) & 0x1
}
func (o *PFIC_Type) SetVTFADDRR2__ADDR2(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR2.Reg, volatile.LoadUint32(&o.VTFADDRR2.Reg)&^(0xfffffffe)|value<<1)
}
func (o *PFIC_Type) GetVTFADDRR2__ADDR2() uint32 {
	return (volatile.LoadUint32(&o.VTFADDRR2.Reg) & 0xfffffffe) >> 1
}

// PFIC.VTFADDRR3: Interrupt 3 address Register
func (o *PFIC_Type) SetVTFADDRR3_VTF3EN(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR3.Reg, volatile.LoadUint32(&o.VTFADDRR3.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetVTFADDRR3_VTF3EN() uint32 {
	return volatile.LoadUint32(&o.VTFADDRR3.Reg) & 0x1
}
func (o *PFIC_Type) SetVTFADDRR3__ADDR3(value uint32) {
	volatile.StoreUint32(&o.VTFADDRR3.Reg, volatile.LoadUint32(&o.VTFADDRR3.Reg)&^(0xfffffffe)|value<<1)
}
func (o *PFIC_Type) GetVTFADDRR3__ADDR3() uint32 {
	return (volatile.LoadUint32(&o.VTFADDRR3.Reg) & 0xfffffffe) >> 1
}

// PFIC.IENR1: Interrupt Setting Register
func (o *PFIC_Type) SetIENR1_INTEN(value uint32) {
	volatile.StoreUint32(&o.IENR1.Reg, volatile.LoadUint32(&o.IENR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIENR1_INTEN() uint32 {
	return (volatile.LoadUint32(&o.IENR1.Reg) & 0xfffff000) >> 12
}

// PFIC.IENR2: Interrupt Setting Register
func (o *PFIC_Type) SetIENR2(value uint32) {
	volatile.StoreUint32(&o.IENR2.Reg, value)
}
func (o *PFIC_Type) GetIENR2() uint32 {
	return volatile.LoadUint32(&o.IENR2.Reg)
}

// PFIC.IENR3: Interrupt Setting Register
func (o *PFIC_Type) SetIENR3(value uint32) {
	volatile.StoreUint32(&o.IENR3.Reg, value)
}
func (o *PFIC_Type) GetIENR3() uint32 {
	return volatile.LoadUint32(&o.IENR3.Reg)
}

// PFIC.IENR4: Interrupt Setting Register
func (o *PFIC_Type) SetIENR4_INTEN(value uint32) {
	volatile.StoreUint32(&o.IENR4.Reg, volatile.LoadUint32(&o.IENR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIENR4_INTEN() uint32 {
	return volatile.LoadUint32(&o.IENR4.Reg) & 0xff
}

// PFIC.IRER1: Interrupt Clear Register
func (o *PFIC_Type) SetIRER1_INTRSET(value uint32) {
	volatile.StoreUint32(&o.IRER1.Reg, volatile.LoadUint32(&o.IRER1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIRER1_INTRSET() uint32 {
	return (volatile.LoadUint32(&o.IRER1.Reg) & 0xfffff000) >> 12
}

// PFIC.IRER2: Interrupt Clear Register
func (o *PFIC_Type) SetIRER2(value uint32) {
	volatile.StoreUint32(&o.IRER2.Reg, value)
}
func (o *PFIC_Type) GetIRER2() uint32 {
	return volatile.LoadUint32(&o.IRER2.Reg)
}

// PFIC.IRER3: Interrupt Clear Register
func (o *PFIC_Type) SetIRER3(value uint32) {
	volatile.StoreUint32(&o.IRER3.Reg, value)
}
func (o *PFIC_Type) GetIRER3() uint32 {
	return volatile.LoadUint32(&o.IRER3.Reg)
}

// PFIC.IRER4: Interrupt Clear Register
func (o *PFIC_Type) SetIRER4_INTRSET(value uint32) {
	volatile.StoreUint32(&o.IRER4.Reg, volatile.LoadUint32(&o.IRER4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIRER4_INTRSET() uint32 {
	return volatile.LoadUint32(&o.IRER4.Reg) & 0xff
}

// PFIC.IPSR1: Interrupt Pending Register
func (o *PFIC_Type) SetIPSR1_PENDSET2_3(value uint32) {
	volatile.StoreUint32(&o.IPSR1.Reg, volatile.LoadUint32(&o.IPSR1.Reg)&^(0xc)|value<<2)
}
func (o *PFIC_Type) GetIPSR1_PENDSET2_3() uint32 {
	return (volatile.LoadUint32(&o.IPSR1.Reg) & 0xc) >> 2
}
func (o *PFIC_Type) SetIPSR1_PENDSET12_31(value uint32) {
	volatile.StoreUint32(&o.IPSR1.Reg, volatile.LoadUint32(&o.IPSR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIPSR1_PENDSET12_31() uint32 {
	return (volatile.LoadUint32(&o.IPSR1.Reg) & 0xfffff000) >> 12
}

// PFIC.IPSR2: Interrupt Pending Register
func (o *PFIC_Type) SetIPSR2(value uint32) {
	volatile.StoreUint32(&o.IPSR2.Reg, value)
}
func (o *PFIC_Type) GetIPSR2() uint32 {
	return volatile.LoadUint32(&o.IPSR2.Reg)
}

// PFIC.IPSR3: Interrupt Pending Register
func (o *PFIC_Type) SetIPSR3(value uint32) {
	volatile.StoreUint32(&o.IPSR3.Reg, value)
}
func (o *PFIC_Type) GetIPSR3() uint32 {
	return volatile.LoadUint32(&o.IPSR3.Reg)
}

// PFIC.IPSR4: Interrupt Pending Register
func (o *PFIC_Type) SetIPSR4_PENDSET(value uint32) {
	volatile.StoreUint32(&o.IPSR4.Reg, volatile.LoadUint32(&o.IPSR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIPSR4_PENDSET() uint32 {
	return volatile.LoadUint32(&o.IPSR4.Reg) & 0xff
}

// PFIC.IPRR1: Interrupt Pending Clear Register
func (o *PFIC_Type) SetIPRR1_PENDRESET2_3(value uint32) {
	volatile.StoreUint32(&o.IPRR1.Reg, volatile.LoadUint32(&o.IPRR1.Reg)&^(0xc)|value<<2)
}
func (o *PFIC_Type) GetIPRR1_PENDRESET2_3() uint32 {
	return (volatile.LoadUint32(&o.IPRR1.Reg) & 0xc) >> 2
}
func (o *PFIC_Type) SetIPRR1_PENDRESET12_31(value uint32) {
	volatile.StoreUint32(&o.IPRR1.Reg, volatile.LoadUint32(&o.IPRR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIPRR1_PENDRESET12_31() uint32 {
	return (volatile.LoadUint32(&o.IPRR1.Reg) & 0xfffff000) >> 12
}

// PFIC.IPRR2: Interrupt Pending Clear Register
func (o *PFIC_Type) SetIPRR2(value uint32) {
	volatile.StoreUint32(&o.IPRR2.Reg, value)
}
func (o *PFIC_Type) GetIPRR2() uint32 {
	return volatile.LoadUint32(&o.IPRR2.Reg)
}

// PFIC.IPRR3: Interrupt Pending Clear Register
func (o *PFIC_Type) SetIPRR3(value uint32) {
	volatile.StoreUint32(&o.IPRR3.Reg, value)
}
func (o *PFIC_Type) GetIPRR3() uint32 {
	return volatile.LoadUint32(&o.IPRR3.Reg)
}

// PFIC.IPRR4: Interrupt Pending Clear Register
func (o *PFIC_Type) SetIPRR4_PENDRESET(value uint32) {
	volatile.StoreUint32(&o.IPRR4.Reg, volatile.LoadUint32(&o.IPRR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIPRR4_PENDRESET() uint32 {
	return volatile.LoadUint32(&o.IPRR4.Reg) & 0xff
}

// PFIC.IACTR1: Interrupt ACTIVE Register
func (o *PFIC_Type) SetIACTR1_IACTS2_3(value uint32) {
	volatile.StoreUint32(&o.IACTR1.Reg, volatile.LoadUint32(&o.IACTR1.Reg)&^(0xc)|value<<2)
}
func (o *PFIC_Type) GetIACTR1_IACTS2_3() uint32 {
	return (volatile.LoadUint32(&o.IACTR1.Reg) & 0xc) >> 2
}
func (o *PFIC_Type) SetIACTR1_IACTS12_31(value uint32) {
	volatile.StoreUint32(&o.IACTR1.Reg, volatile.LoadUint32(&o.IACTR1.Reg)&^(0xfffff000)|value<<12)
}
func (o *PFIC_Type) GetIACTR1_IACTS12_31() uint32 {
	return (volatile.LoadUint32(&o.IACTR1.Reg) & 0xfffff000) >> 12
}

// PFIC.IACTR2: Interrupt ACTIVE Register
func (o *PFIC_Type) SetIACTR2(value uint32) {
	volatile.StoreUint32(&o.IACTR2.Reg, value)
}
func (o *PFIC_Type) GetIACTR2() uint32 {
	return volatile.LoadUint32(&o.IACTR2.Reg)
}

// PFIC.IACTR3: Interrupt ACTIVE Register
func (o *PFIC_Type) SetIACTR3(value uint32) {
	volatile.StoreUint32(&o.IACTR3.Reg, value)
}
func (o *PFIC_Type) GetIACTR3() uint32 {
	return volatile.LoadUint32(&o.IACTR3.Reg)
}

// PFIC.IACTR4: Interrupt ACTIVE Register
func (o *PFIC_Type) SetIACTR4_IACTS(value uint32) {
	volatile.StoreUint32(&o.IACTR4.Reg, volatile.LoadUint32(&o.IACTR4.Reg)&^(0xff)|value)
}
func (o *PFIC_Type) GetIACTR4_IACTS() uint32 {
	return volatile.LoadUint32(&o.IACTR4.Reg) & 0xff
}

// PFIC.SCTLR: System Control Register
func (o *PFIC_Type) SetSCTLR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x2)|value<<1)
}
func (o *PFIC_Type) GetSCTLR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x2) >> 1
}
func (o *PFIC_Type) SetSCTLR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x4)|value<<2)
}
func (o *PFIC_Type) GetSCTLR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x4) >> 2
}
func (o *PFIC_Type) SetSCTLR_WFITOWFE(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x8)|value<<3)
}
func (o *PFIC_Type) GetSCTLR_WFITOWFE() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x8) >> 3
}
func (o *PFIC_Type) SetSCTLR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x10)|value<<4)
}
func (o *PFIC_Type) GetSCTLR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x10) >> 4
}
func (o *PFIC_Type) SetSCTLR_SETEVENT(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x20)|value<<5)
}
func (o *PFIC_Type) GetSCTLR_SETEVENT() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x20) >> 5
}
func (o *PFIC_Type) SetSCTLR_SYSRESET(value uint32) {
	volatile.StoreUint32(&o.SCTLR.Reg, volatile.LoadUint32(&o.SCTLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PFIC_Type) GetSCTLR_SYSRESET() uint32 {
	return (volatile.LoadUint32(&o.SCTLR.Reg) & 0x80000000) >> 31
}

// PFIC.STK_CTLR: System counter control register
func (o *PFIC_Type) SetSTK_CTLR_STE(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetSTK_CTLR_STE() uint32 {
	return volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x1
}
func (o *PFIC_Type) SetSTK_CTLR_STIE(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x2)|value<<1)
}
func (o *PFIC_Type) GetSTK_CTLR_STIE() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x2) >> 1
}
func (o *PFIC_Type) SetSTK_CTLR_STCLK(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x4)|value<<2)
}
func (o *PFIC_Type) GetSTK_CTLR_STCLK() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x4) >> 2
}
func (o *PFIC_Type) SetSTK_CTLR_STRE(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x8)|value<<3)
}
func (o *PFIC_Type) GetSTK_CTLR_STRE() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x8) >> 3
}
func (o *PFIC_Type) SetSTK_CTLR_MODE(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x10)|value<<4)
}
func (o *PFIC_Type) GetSTK_CTLR_MODE() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x10) >> 4
}
func (o *PFIC_Type) SetSTK_CTLR_INIT(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x20)|value<<5)
}
func (o *PFIC_Type) GetSTK_CTLR_INIT() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x20) >> 5
}
func (o *PFIC_Type) SetSTK_CTLR_SWIE(value uint32) {
	volatile.StoreUint32(&o.STK_CTLR.Reg, volatile.LoadUint32(&o.STK_CTLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PFIC_Type) GetSTK_CTLR_SWIE() uint32 {
	return (volatile.LoadUint32(&o.STK_CTLR.Reg) & 0x80000000) >> 31
}

// PFIC.STK_SR: System START
func (o *PFIC_Type) SetSTK_SR_CNTIF(value uint32) {
	volatile.StoreUint32(&o.STK_SR.Reg, volatile.LoadUint32(&o.STK_SR.Reg)&^(0x1)|value)
}
func (o *PFIC_Type) GetSTK_SR_CNTIF() uint32 {
	return volatile.LoadUint32(&o.STK_SR.Reg) & 0x1
}

// PFIC.STK_CNTL: System counter low register
func (o *PFIC_Type) SetSTK_CNTL(value uint32) {
	volatile.StoreUint32(&o.STK_CNTL.Reg, value)
}
func (o *PFIC_Type) GetSTK_CNTL() uint32 {
	return volatile.LoadUint32(&o.STK_CNTL.Reg)
}

// PFIC.STK_CMPLR: System compare low register
func (o *PFIC_Type) SetSTK_CMPLR(value uint32) {
	volatile.StoreUint32(&o.STK_CMPLR.Reg, value)
}
func (o *PFIC_Type) GetSTK_CMPLR() uint32 {
	return volatile.LoadUint32(&o.STK_CMPLR.Reg)
}

// Constants for PWR: Power control
const (
	// CTLR: Power control register (PWR_CTRL)
	// Position of PDDS field.
	PWR_CTLR_PDDS_Pos = 0x1
	// Bit mask of PDDS field.
	PWR_CTLR_PDDS_Msk = 0x2
	// Bit PDDS.
	PWR_CTLR_PDDS = 0x2
	// Position of PVDE field.
	PWR_CTLR_PVDE_Pos = 0x4
	// Bit mask of PVDE field.
	PWR_CTLR_PVDE_Msk = 0x10
	// Bit PVDE.
	PWR_CTLR_PVDE = 0x10
	// Position of PLS field.
	PWR_CTLR_PLS_Pos = 0x5
	// Bit mask of PLS field.
	PWR_CTLR_PLS_Msk = 0xe0

	// CSR: Power control state register (PWR_CSR)
	// Position of PVDO field.
	PWR_CSR_PVDO_Pos = 0x2
	// Bit mask of PVDO field.
	PWR_CSR_PVDO_Msk = 0x4
	// Bit PVDO.
	PWR_CSR_PVDO = 0x4

	// AWUCSR: Automatic wake-up control state register (PWR_AWUCSR)
	// Position of AWUEN field.
	PWR_AWUCSR_AWUEN_Pos = 0x1
	// Bit mask of AWUEN field.
	PWR_AWUCSR_AWUEN_Msk = 0x2
	// Bit AWUEN.
	PWR_AWUCSR_AWUEN = 0x2

	// AWUAPR: Automatic wake window comparison value register (PWR_AWUAPR)
	// Position of AWUAPR field.
	PWR_AWUAPR_AWUAPR_Pos = 0x0
	// Bit mask of AWUAPR field.
	PWR_AWUAPR_AWUAPR_Msk = 0x3f

	// AWUPSC: Automatic wake-up prescaler register (PWR_AWUPSC)
	// Position of AWUPSC field.
	PWR_AWUPSC_AWUPSC_Pos = 0x0
	// Bit mask of AWUPSC field.
	PWR_AWUPSC_AWUPSC_Msk = 0xf
)

// Constants for RCC: Reset and clock control
const (
	// CTLR: Clock control register
	// Position of HSION field.
	RCC_CTLR_HSION_Pos = 0x0
	// Bit mask of HSION field.
	RCC_CTLR_HSION_Msk = 0x1
	// Bit HSION.
	RCC_CTLR_HSION = 0x1
	// Position of HSIRDY field.
	RCC_CTLR_HSIRDY_Pos = 0x1
	// Bit mask of HSIRDY field.
	RCC_CTLR_HSIRDY_Msk = 0x2
	// Bit HSIRDY.
	RCC_CTLR_HSIRDY = 0x2
	// Position of HSITRIM field.
	RCC_CTLR_HSITRIM_Pos = 0x3
	// Bit mask of HSITRIM field.
	RCC_CTLR_HSITRIM_Msk = 0xf8
	// Position of HSICAL field.
	RCC_CTLR_HSICAL_Pos = 0x8
	// Bit mask of HSICAL field.
	RCC_CTLR_HSICAL_Msk = 0xff00
	// Position of HSEON field.
	RCC_CTLR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CTLR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CTLR_HSEON = 0x10000
	// Position of HSERDY field.
	RCC_CTLR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CTLR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CTLR_HSERDY = 0x20000
	// Position of HSEBYP field.
	RCC_CTLR_HSEBYP_Pos = 0x12
	// Bit mask of HSEBYP field.
	RCC_CTLR_HSEBYP_Msk = 0x40000
	// Bit HSEBYP.
	RCC_CTLR_HSEBYP = 0x40000
	// Position of CSSON field.
	RCC_CTLR_CSSON_Pos = 0x13
	// Bit mask of CSSON field.
	RCC_CTLR_CSSON_Msk = 0x80000
	// Bit CSSON.
	RCC_CTLR_CSSON = 0x80000
	// Position of PLLON field.
	RCC_CTLR_PLLON_Pos = 0x18
	// Bit mask of PLLON field.
	RCC_CTLR_PLLON_Msk = 0x1000000
	// Bit PLLON.
	RCC_CTLR_PLLON = 0x1000000
	// Position of PLLRDY field.
	RCC_CTLR_PLLRDY_Pos = 0x19
	// Bit mask of PLLRDY field.
	RCC_CTLR_PLLRDY_Msk = 0x2000000
	// Bit PLLRDY.
	RCC_CTLR_PLLRDY = 0x2000000

	// CFGR0: Clock configuration register (RCC_CFGR0)
	// Position of SW field.
	RCC_CFGR0_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR0_SW_Msk = 0x3
	// Position of SWS field.
	RCC_CFGR0_SWS_Pos = 0x2
	// Bit mask of SWS field.
	RCC_CFGR0_SWS_Msk = 0xc
	// Position of HPRE field.
	RCC_CFGR0_HPRE_Pos = 0x4
	// Bit mask of HPRE field.
	RCC_CFGR0_HPRE_Msk = 0xf0
	// Position of PPRE1 field.
	RCC_CFGR0_PPRE1_Pos = 0x8
	// Bit mask of PPRE1 field.
	RCC_CFGR0_PPRE1_Msk = 0x700
	// Position of PPRE2 field.
	RCC_CFGR0_PPRE2_Pos = 0xb
	// Bit mask of PPRE2 field.
	RCC_CFGR0_PPRE2_Msk = 0x3800
	// Position of ADCPRE field.
	RCC_CFGR0_ADCPRE_Pos = 0xe
	// Bit mask of ADCPRE field.
	RCC_CFGR0_ADCPRE_Msk = 0xc000
	// Position of PLLSRC field.
	RCC_CFGR0_PLLSRC_Pos = 0x10
	// Bit mask of PLLSRC field.
	RCC_CFGR0_PLLSRC_Msk = 0x10000
	// Bit PLLSRC.
	RCC_CFGR0_PLLSRC = 0x10000
	// Position of MCO field.
	RCC_CFGR0_MCO_Pos = 0x18
	// Bit mask of MCO field.
	RCC_CFGR0_MCO_Msk = 0x7000000

	// INTR: Clock interrupt register (RCC_INTR)
	// Position of LSIRDYF field.
	RCC_INTR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_INTR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_INTR_LSIRDYF = 0x1
	// Position of HSIRDYF field.
	RCC_INTR_HSIRDYF_Pos = 0x2
	// Bit mask of HSIRDYF field.
	RCC_INTR_HSIRDYF_Msk = 0x4
	// Bit HSIRDYF.
	RCC_INTR_HSIRDYF = 0x4
	// Position of HSERDYF field.
	RCC_INTR_HSERDYF_Pos = 0x3
	// Bit mask of HSERDYF field.
	RCC_INTR_HSERDYF_Msk = 0x8
	// Bit HSERDYF.
	RCC_INTR_HSERDYF = 0x8
	// Position of PLLRDYF field.
	RCC_INTR_PLLRDYF_Pos = 0x4
	// Bit mask of PLLRDYF field.
	RCC_INTR_PLLRDYF_Msk = 0x10
	// Bit PLLRDYF.
	RCC_INTR_PLLRDYF = 0x10
	// Position of CSSF field.
	RCC_INTR_CSSF_Pos = 0x7
	// Bit mask of CSSF field.
	RCC_INTR_CSSF_Msk = 0x80
	// Bit CSSF.
	RCC_INTR_CSSF = 0x80
	// Position of LSIRDYIE field.
	RCC_INTR_LSIRDYIE_Pos = 0x8
	// Bit mask of LSIRDYIE field.
	RCC_INTR_LSIRDYIE_Msk = 0x100
	// Bit LSIRDYIE.
	RCC_INTR_LSIRDYIE = 0x100
	// Position of HSIRDYIE field.
	RCC_INTR_HSIRDYIE_Pos = 0xa
	// Bit mask of HSIRDYIE field.
	RCC_INTR_HSIRDYIE_Msk = 0x400
	// Bit HSIRDYIE.
	RCC_INTR_HSIRDYIE = 0x400
	// Position of HSERDYIE field.
	RCC_INTR_HSERDYIE_Pos = 0xb
	// Bit mask of HSERDYIE field.
	RCC_INTR_HSERDYIE_Msk = 0x800
	// Bit HSERDYIE.
	RCC_INTR_HSERDYIE = 0x800
	// Position of PLLRDYIE field.
	RCC_INTR_PLLRDYIE_Pos = 0xc
	// Bit mask of PLLRDYIE field.
	RCC_INTR_PLLRDYIE_Msk = 0x1000
	// Bit PLLRDYIE.
	RCC_INTR_PLLRDYIE = 0x1000
	// Position of LSIRDYC field.
	RCC_INTR_LSIRDYC_Pos = 0x10
	// Bit mask of LSIRDYC field.
	RCC_INTR_LSIRDYC_Msk = 0x10000
	// Bit LSIRDYC.
	RCC_INTR_LSIRDYC = 0x10000
	// Position of HSIRDYC field.
	RCC_INTR_HSIRDYC_Pos = 0x12
	// Bit mask of HSIRDYC field.
	RCC_INTR_HSIRDYC_Msk = 0x40000
	// Bit HSIRDYC.
	RCC_INTR_HSIRDYC = 0x40000
	// Position of HSERDYC field.
	RCC_INTR_HSERDYC_Pos = 0x13
	// Bit mask of HSERDYC field.
	RCC_INTR_HSERDYC_Msk = 0x80000
	// Bit HSERDYC.
	RCC_INTR_HSERDYC = 0x80000
	// Position of PLLRDYC field.
	RCC_INTR_PLLRDYC_Pos = 0x14
	// Bit mask of PLLRDYC field.
	RCC_INTR_PLLRDYC_Msk = 0x100000
	// Bit PLLRDYC.
	RCC_INTR_PLLRDYC = 0x100000
	// Position of CSSC field.
	RCC_INTR_CSSC_Pos = 0x17
	// Bit mask of CSSC field.
	RCC_INTR_CSSC_Msk = 0x800000
	// Bit CSSC.
	RCC_INTR_CSSC = 0x800000

	// APB2PRSTR: APB2 peripheral reset register (RCC_APB2PRSTR)
	// Position of AFIORST field.
	RCC_APB2PRSTR_AFIORST_Pos = 0x0
	// Bit mask of AFIORST field.
	RCC_APB2PRSTR_AFIORST_Msk = 0x1
	// Bit AFIORST.
	RCC_APB2PRSTR_AFIORST = 0x1
	// Position of IOPARST field.
	RCC_APB2PRSTR_IOPARST_Pos = 0x2
	// Bit mask of IOPARST field.
	RCC_APB2PRSTR_IOPARST_Msk = 0x4
	// Bit IOPARST.
	RCC_APB2PRSTR_IOPARST = 0x4
	// Position of IOPCRST field.
	RCC_APB2PRSTR_IOPCRST_Pos = 0x4
	// Bit mask of IOPCRST field.
	RCC_APB2PRSTR_IOPCRST_Msk = 0x10
	// Bit IOPCRST.
	RCC_APB2PRSTR_IOPCRST = 0x10
	// Position of IOPDRST field.
	RCC_APB2PRSTR_IOPDRST_Pos = 0x5
	// Bit mask of IOPDRST field.
	RCC_APB2PRSTR_IOPDRST_Msk = 0x20
	// Bit IOPDRST.
	RCC_APB2PRSTR_IOPDRST = 0x20
	// Position of ADC1RST field.
	RCC_APB2PRSTR_ADC1RST_Pos = 0x9
	// Bit mask of ADC1RST field.
	RCC_APB2PRSTR_ADC1RST_Msk = 0x200
	// Bit ADC1RST.
	RCC_APB2PRSTR_ADC1RST = 0x200
	// Position of TIM1RST field.
	RCC_APB2PRSTR_TIM1RST_Pos = 0xb
	// Bit mask of TIM1RST field.
	RCC_APB2PRSTR_TIM1RST_Msk = 0x800
	// Bit TIM1RST.
	RCC_APB2PRSTR_TIM1RST = 0x800
	// Position of SPI1RST field.
	RCC_APB2PRSTR_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APB2PRSTR_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APB2PRSTR_SPI1RST = 0x1000
	// Position of USART1RST field.
	RCC_APB2PRSTR_USART1RST_Pos = 0xe
	// Bit mask of USART1RST field.
	RCC_APB2PRSTR_USART1RST_Msk = 0x4000
	// Bit USART1RST.
	RCC_APB2PRSTR_USART1RST = 0x4000

	// APB1PRSTR: APB1 peripheral reset register (RCC_APB1PRSTR)
	// Position of WWDGRST field.
	RCC_APB1PRSTR_WWDGRST_Pos = 0xb
	// Bit mask of WWDGRST field.
	RCC_APB1PRSTR_WWDGRST_Msk = 0x800
	// Bit WWDGRST.
	RCC_APB1PRSTR_WWDGRST = 0x800
	// Position of I2C1RST field.
	RCC_APB1PRSTR_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APB1PRSTR_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APB1PRSTR_I2C1RST = 0x200000
	// Position of PWRRST field.
	RCC_APB1PRSTR_PWRRST_Pos = 0x1c
	// Bit mask of PWRRST field.
	RCC_APB1PRSTR_PWRRST_Msk = 0x10000000
	// Bit PWRRST.
	RCC_APB1PRSTR_PWRRST = 0x10000000

	// AHBPCENR: AHB Peripheral Clock enable register (RCC_AHBPCENR)
	// Position of DMA1EN field.
	RCC_AHBPCENR_DMA1EN_Pos = 0x0
	// Bit mask of DMA1EN field.
	RCC_AHBPCENR_DMA1EN_Msk = 0x1
	// Bit DMA1EN.
	RCC_AHBPCENR_DMA1EN = 0x1
	// Position of SRAMEN field.
	RCC_AHBPCENR_SRAMEN_Pos = 0x2
	// Bit mask of SRAMEN field.
	RCC_AHBPCENR_SRAMEN_Msk = 0x4
	// Bit SRAMEN.
	RCC_AHBPCENR_SRAMEN = 0x4

	// APB2PCENR: APB2 peripheral clock enable register (RCC_APB2PCENR)
	// Position of AFIOEN field.
	RCC_APB2PCENR_AFIOEN_Pos = 0x0
	// Bit mask of AFIOEN field.
	RCC_APB2PCENR_AFIOEN_Msk = 0x1
	// Bit AFIOEN.
	RCC_APB2PCENR_AFIOEN = 0x1
	// Position of IOPAEN field.
	RCC_APB2PCENR_IOPAEN_Pos = 0x2
	// Bit mask of IOPAEN field.
	RCC_APB2PCENR_IOPAEN_Msk = 0x4
	// Bit IOPAEN.
	RCC_APB2PCENR_IOPAEN = 0x4
	// Position of IOPCEN field.
	RCC_APB2PCENR_IOPCEN_Pos = 0x4
	// Bit mask of IOPCEN field.
	RCC_APB2PCENR_IOPCEN_Msk = 0x10
	// Bit IOPCEN.
	RCC_APB2PCENR_IOPCEN = 0x10
	// Position of IOPDEN field.
	RCC_APB2PCENR_IOPDEN_Pos = 0x5
	// Bit mask of IOPDEN field.
	RCC_APB2PCENR_IOPDEN_Msk = 0x20
	// Bit IOPDEN.
	RCC_APB2PCENR_IOPDEN = 0x20
	// Position of ADC1EN field.
	RCC_APB2PCENR_ADC1EN_Pos = 0x9
	// Bit mask of ADC1EN field.
	RCC_APB2PCENR_ADC1EN_Msk = 0x200
	// Bit ADC1EN.
	RCC_APB2PCENR_ADC1EN = 0x200
	// Position of TIM1EN field.
	RCC_APB2PCENR_TIM1EN_Pos = 0xb
	// Bit mask of TIM1EN field.
	RCC_APB2PCENR_TIM1EN_Msk = 0x800
	// Bit TIM1EN.
	RCC_APB2PCENR_TIM1EN = 0x800
	// Position of SPI1EN field.
	RCC_APB2PCENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APB2PCENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APB2PCENR_SPI1EN = 0x1000
	// Position of USART1EN field.
	RCC_APB2PCENR_USART1EN_Pos = 0xe
	// Bit mask of USART1EN field.
	RCC_APB2PCENR_USART1EN_Msk = 0x4000
	// Bit USART1EN.
	RCC_APB2PCENR_USART1EN = 0x4000

	// APB1PCENR: APB1 peripheral clock enable register (RCC_APB1PCENR)
	// Position of TIM2EN field.
	RCC_APB1PCENR_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APB1PCENR_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APB1PCENR_TIM2EN = 0x1
	// Position of WWDGEN field.
	RCC_APB1PCENR_WWDGEN_Pos = 0xb
	// Bit mask of WWDGEN field.
	RCC_APB1PCENR_WWDGEN_Msk = 0x800
	// Bit WWDGEN.
	RCC_APB1PCENR_WWDGEN = 0x800
	// Position of I2C1EN field.
	RCC_APB1PCENR_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APB1PCENR_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APB1PCENR_I2C1EN = 0x200000
	// Position of PWREN field.
	RCC_APB1PCENR_PWREN_Pos = 0x1c
	// Bit mask of PWREN field.
	RCC_APB1PCENR_PWREN_Msk = 0x10000000
	// Bit PWREN.
	RCC_APB1PCENR_PWREN = 0x10000000

	// RSTSCKR: Control/status register (RCC_RSTSCKR)
	// Position of LSION field.
	RCC_RSTSCKR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_RSTSCKR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_RSTSCKR_LSION = 0x1
	// Position of LSIRDY field.
	RCC_RSTSCKR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_RSTSCKR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_RSTSCKR_LSIRDY = 0x2
	// Position of RMVF field.
	RCC_RSTSCKR_RMVF_Pos = 0x18
	// Bit mask of RMVF field.
	RCC_RSTSCKR_RMVF_Msk = 0x1000000
	// Bit RMVF.
	RCC_RSTSCKR_RMVF = 0x1000000
	// Position of PINRSTF field.
	RCC_RSTSCKR_PINRSTF_Pos = 0x1a
	// Bit mask of PINRSTF field.
	RCC_RSTSCKR_PINRSTF_Msk = 0x4000000
	// Bit PINRSTF.
	RCC_RSTSCKR_PINRSTF = 0x4000000
	// Position of PORRSTF field.
	RCC_RSTSCKR_PORRSTF_Pos = 0x1b
	// Bit mask of PORRSTF field.
	RCC_RSTSCKR_PORRSTF_Msk = 0x8000000
	// Bit PORRSTF.
	RCC_RSTSCKR_PORRSTF = 0x8000000
	// Position of SFTRSTF field.
	RCC_RSTSCKR_SFTRSTF_Pos = 0x1c
	// Bit mask of SFTRSTF field.
	RCC_RSTSCKR_SFTRSTF_Msk = 0x10000000
	// Bit SFTRSTF.
	RCC_RSTSCKR_SFTRSTF = 0x10000000
	// Position of IWDGRSTF field.
	RCC_RSTSCKR_IWDGRSTF_Pos = 0x1d
	// Bit mask of IWDGRSTF field.
	RCC_RSTSCKR_IWDGRSTF_Msk = 0x20000000
	// Bit IWDGRSTF.
	RCC_RSTSCKR_IWDGRSTF = 0x20000000
	// Position of WWDGRSTF field.
	RCC_RSTSCKR_WWDGRSTF_Pos = 0x1e
	// Bit mask of WWDGRSTF field.
	RCC_RSTSCKR_WWDGRSTF_Msk = 0x40000000
	// Bit WWDGRSTF.
	RCC_RSTSCKR_WWDGRSTF = 0x40000000
	// Position of LPWRRSTF field.
	RCC_RSTSCKR_LPWRRSTF_Pos = 0x1f
	// Bit mask of LPWRRSTF field.
	RCC_RSTSCKR_LPWRRSTF_Msk = 0x80000000
	// Bit LPWRRSTF.
	RCC_RSTSCKR_LPWRRSTF = 0x80000000
)

// Constants for EXTEND: Extend configuration
const (
	// EXTEND_CTR: Configure the extended control register
	// Position of PLL_CFG field.
	EXTEND_EXTEND_CTR_PLL_CFG_Pos = 0x0
	// Bit mask of PLL_CFG field.
	EXTEND_EXTEND_CTR_PLL_CFG_Msk = 0xf
	// Position of LOCKUP_EN field.
	EXTEND_EXTEND_CTR_LOCKUP_EN_Pos = 0x6
	// Bit mask of LOCKUP_EN field.
	EXTEND_EXTEND_CTR_LOCKUP_EN_Msk = 0x40
	// Bit LOCKUP_EN.
	EXTEND_EXTEND_CTR_LOCKUP_EN = 0x40
	// Position of LOCKUP_RESET field.
	EXTEND_EXTEND_CTR_LOCKUP_RESET_Pos = 0x7
	// Bit mask of LOCKUP_RESET field.
	EXTEND_EXTEND_CTR_LOCKUP_RESET_Msk = 0x80
	// Bit LOCKUP_RESET.
	EXTEND_EXTEND_CTR_LOCKUP_RESET = 0x80
	// Position of LDO_TRIM field.
	EXTEND_EXTEND_CTR_LDO_TRIM_Pos = 0xa
	// Bit mask of LDO_TRIM field.
	EXTEND_EXTEND_CTR_LDO_TRIM_Msk = 0x400
	// Bit LDO_TRIM.
	EXTEND_EXTEND_CTR_LDO_TRIM = 0x400
	// Position of FLASH_CLK_TRIM field.
	EXTEND_EXTEND_CTR_FLASH_CLK_TRIM_Pos = 0xb
	// Bit mask of FLASH_CLK_TRIM field.
	EXTEND_EXTEND_CTR_FLASH_CLK_TRIM_Msk = 0x3800
	// Position of WR_EN field.
	EXTEND_EXTEND_CTR_WR_EN_Pos = 0xe
	// Bit mask of WR_EN field.
	EXTEND_EXTEND_CTR_WR_EN_Msk = 0x4000
	// Bit WR_EN.
	EXTEND_EXTEND_CTR_WR_EN = 0x4000
	// Position of WR_LOCK field.
	EXTEND_EXTEND_CTR_WR_LOCK_Pos = 0xf
	// Bit mask of WR_LOCK field.
	EXTEND_EXTEND_CTR_WR_LOCK_Msk = 0x8000
	// Bit WR_LOCK.
	EXTEND_EXTEND_CTR_WR_LOCK = 0x8000
	// Position of OPA_EN field.
	EXTEND_EXTEND_CTR_OPA_EN_Pos = 0x10
	// Bit mask of OPA_EN field.
	EXTEND_EXTEND_CTR_OPA_EN_Msk = 0x10000
	// Bit OPA_EN.
	EXTEND_EXTEND_CTR_OPA_EN = 0x10000
	// Position of OPA_NSEL field.
	EXTEND_EXTEND_CTR_OPA_NSEL_Pos = 0x11
	// Bit mask of OPA_NSEL field.
	EXTEND_EXTEND_CTR_OPA_NSEL_Msk = 0x20000
	// Bit OPA_NSEL.
	EXTEND_EXTEND_CTR_OPA_NSEL = 0x20000
	// Position of OPA_PSEL field.
	EXTEND_EXTEND_CTR_OPA_PSEL_Pos = 0x12
	// Bit mask of OPA_PSEL field.
	EXTEND_EXTEND_CTR_OPA_PSEL_Msk = 0x40000
	// Bit OPA_PSEL.
	EXTEND_EXTEND_CTR_OPA_PSEL = 0x40000

	// EXTEND_KR: Configure the extended key register
	// Position of KEY field.
	EXTEND_EXTEND_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	EXTEND_EXTEND_KR_KEY_Msk = 0xffffffff
)

// Constants for GPIOA: General purpose I/O
const (
	// CFGLR: Port configuration register low (GPIOn_CFGLR)
	// Position of MODE0 field.
	GPIO_CFGLR_MODE0_Pos = 0x0
	// Bit mask of MODE0 field.
	GPIO_CFGLR_MODE0_Msk = 0x3
	// Position of CNF0 field.
	GPIO_CFGLR_CNF0_Pos = 0x2
	// Bit mask of CNF0 field.
	GPIO_CFGLR_CNF0_Msk = 0xc
	// Position of MODE1 field.
	GPIO_CFGLR_MODE1_Pos = 0x4
	// Bit mask of MODE1 field.
	GPIO_CFGLR_MODE1_Msk = 0x30
	// Position of CNF1 field.
	GPIO_CFGLR_CNF1_Pos = 0x6
	// Bit mask of CNF1 field.
	GPIO_CFGLR_CNF1_Msk = 0xc0
	// Position of MODE2 field.
	GPIO_CFGLR_MODE2_Pos = 0x8
	// Bit mask of MODE2 field.
	GPIO_CFGLR_MODE2_Msk = 0x300
	// Position of CNF2 field.
	GPIO_CFGLR_CNF2_Pos = 0xa
	// Bit mask of CNF2 field.
	GPIO_CFGLR_CNF2_Msk = 0xc00
	// Position of MODE3 field.
	GPIO_CFGLR_MODE3_Pos = 0xc
	// Bit mask of MODE3 field.
	GPIO_CFGLR_MODE3_Msk = 0x3000
	// Position of CNF3 field.
	GPIO_CFGLR_CNF3_Pos = 0xe
	// Bit mask of CNF3 field.
	GPIO_CFGLR_CNF3_Msk = 0xc000
	// Position of MODE4 field.
	GPIO_CFGLR_MODE4_Pos = 0x10
	// Bit mask of MODE4 field.
	GPIO_CFGLR_MODE4_Msk = 0x30000
	// Position of CNF4 field.
	GPIO_CFGLR_CNF4_Pos = 0x12
	// Bit mask of CNF4 field.
	GPIO_CFGLR_CNF4_Msk = 0xc0000
	// Position of MODE5 field.
	GPIO_CFGLR_MODE5_Pos = 0x14
	// Bit mask of MODE5 field.
	GPIO_CFGLR_MODE5_Msk = 0x300000
	// Position of CNF5 field.
	GPIO_CFGLR_CNF5_Pos = 0x16
	// Bit mask of CNF5 field.
	GPIO_CFGLR_CNF5_Msk = 0xc00000
	// Position of MODE6 field.
	GPIO_CFGLR_MODE6_Pos = 0x18
	// Bit mask of MODE6 field.
	GPIO_CFGLR_MODE6_Msk = 0x3000000
	// Position of CNF6 field.
	GPIO_CFGLR_CNF6_Pos = 0x1a
	// Bit mask of CNF6 field.
	GPIO_CFGLR_CNF6_Msk = 0xc000000
	// Position of MODE7 field.
	GPIO_CFGLR_MODE7_Pos = 0x1c
	// Bit mask of MODE7 field.
	GPIO_CFGLR_MODE7_Msk = 0x30000000
	// Position of CNF7 field.
	GPIO_CFGLR_CNF7_Pos = 0x1e
	// Bit mask of CNF7 field.
	GPIO_CFGLR_CNF7_Msk = 0xc0000000

	// INDR: Port input data register (GPIOn_INDR)
	// Position of IDR0 field.
	GPIO_INDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_INDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_INDR_IDR0 = 0x1
	// Position of IDR1 field.
	GPIO_INDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_INDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_INDR_IDR1 = 0x2
	// Position of IDR2 field.
	GPIO_INDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_INDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_INDR_IDR2 = 0x4
	// Position of IDR3 field.
	GPIO_INDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_INDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_INDR_IDR3 = 0x8
	// Position of IDR4 field.
	GPIO_INDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_INDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_INDR_IDR4 = 0x10
	// Position of IDR5 field.
	GPIO_INDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_INDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_INDR_IDR5 = 0x20
	// Position of IDR6 field.
	GPIO_INDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_INDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_INDR_IDR6 = 0x40
	// Position of IDR7 field.
	GPIO_INDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_INDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_INDR_IDR7 = 0x80

	// OUTDR: Port output data register (GPIOn_OUTDR)
	// Position of ODR0 field.
	GPIO_OUTDR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_OUTDR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_OUTDR_ODR0 = 0x1
	// Position of ODR1 field.
	GPIO_OUTDR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_OUTDR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_OUTDR_ODR1 = 0x2
	// Position of ODR2 field.
	GPIO_OUTDR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_OUTDR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_OUTDR_ODR2 = 0x4
	// Position of ODR3 field.
	GPIO_OUTDR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_OUTDR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_OUTDR_ODR3 = 0x8
	// Position of ODR4 field.
	GPIO_OUTDR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_OUTDR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_OUTDR_ODR4 = 0x10
	// Position of ODR5 field.
	GPIO_OUTDR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_OUTDR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_OUTDR_ODR5 = 0x20
	// Position of ODR6 field.
	GPIO_OUTDR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_OUTDR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_OUTDR_ODR6 = 0x40
	// Position of ODR7 field.
	GPIO_OUTDR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_OUTDR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_OUTDR_ODR7 = 0x80

	// BSHR: Port bit set/reset register (GPIOn_BSHR)
	// Position of BS0 field.
	GPIO_BSHR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSHR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSHR_BS0 = 0x1
	// Position of BS1 field.
	GPIO_BSHR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSHR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSHR_BS1 = 0x2
	// Position of BS2 field.
	GPIO_BSHR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSHR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSHR_BS2 = 0x4
	// Position of BS3 field.
	GPIO_BSHR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSHR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSHR_BS3 = 0x8
	// Position of BS4 field.
	GPIO_BSHR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSHR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSHR_BS4 = 0x10
	// Position of BS5 field.
	GPIO_BSHR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSHR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSHR_BS5 = 0x20
	// Position of BS6 field.
	GPIO_BSHR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSHR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSHR_BS6 = 0x40
	// Position of BS7 field.
	GPIO_BSHR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSHR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSHR_BS7 = 0x80
	// Position of BR0 field.
	GPIO_BSHR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSHR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSHR_BR0 = 0x10000
	// Position of BR1 field.
	GPIO_BSHR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSHR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSHR_BR1 = 0x20000
	// Position of BR2 field.
	GPIO_BSHR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSHR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSHR_BR2 = 0x40000
	// Position of BR3 field.
	GPIO_BSHR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSHR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSHR_BR3 = 0x80000
	// Position of BR4 field.
	GPIO_BSHR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSHR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSHR_BR4 = 0x100000
	// Position of BR5 field.
	GPIO_BSHR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSHR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSHR_BR5 = 0x200000
	// Position of BR6 field.
	GPIO_BSHR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSHR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSHR_BR6 = 0x400000
	// Position of BR7 field.
	GPIO_BSHR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSHR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSHR_BR7 = 0x800000

	// BCR: Port bit reset register (GPIOn_BCR)
	// Position of BR0 field.
	GPIO_BCR_BR0_Pos = 0x0
	// Bit mask of BR0 field.
	GPIO_BCR_BR0_Msk = 0x1
	// Bit BR0.
	GPIO_BCR_BR0 = 0x1
	// Position of BR1 field.
	GPIO_BCR_BR1_Pos = 0x1
	// Bit mask of BR1 field.
	GPIO_BCR_BR1_Msk = 0x2
	// Bit BR1.
	GPIO_BCR_BR1 = 0x2
	// Position of BR2 field.
	GPIO_BCR_BR2_Pos = 0x2
	// Bit mask of BR2 field.
	GPIO_BCR_BR2_Msk = 0x4
	// Bit BR2.
	GPIO_BCR_BR2 = 0x4
	// Position of BR3 field.
	GPIO_BCR_BR3_Pos = 0x3
	// Bit mask of BR3 field.
	GPIO_BCR_BR3_Msk = 0x8
	// Bit BR3.
	GPIO_BCR_BR3 = 0x8
	// Position of BR4 field.
	GPIO_BCR_BR4_Pos = 0x4
	// Bit mask of BR4 field.
	GPIO_BCR_BR4_Msk = 0x10
	// Bit BR4.
	GPIO_BCR_BR4 = 0x10
	// Position of BR5 field.
	GPIO_BCR_BR5_Pos = 0x5
	// Bit mask of BR5 field.
	GPIO_BCR_BR5_Msk = 0x20
	// Bit BR5.
	GPIO_BCR_BR5 = 0x20
	// Position of BR6 field.
	GPIO_BCR_BR6_Pos = 0x6
	// Bit mask of BR6 field.
	GPIO_BCR_BR6_Msk = 0x40
	// Bit BR6.
	GPIO_BCR_BR6 = 0x40
	// Position of BR7 field.
	GPIO_BCR_BR7_Pos = 0x7
	// Bit mask of BR7 field.
	GPIO_BCR_BR7_Msk = 0x80
	// Bit BR7.
	GPIO_BCR_BR7 = 0x80

	// LCKR: Port configuration lock register
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x8
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x100
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x100
)

// Constants for AFIO: Alternate function I/O
const (
	// PCFR: AF remap and debug I/O configuration register (AFIO_PCFR)
	// Position of SPI1RM field.
	AFIO_PCFR_SPI1RM_Pos = 0x0
	// Bit mask of SPI1RM field.
	AFIO_PCFR_SPI1RM_Msk = 0x1
	// Bit SPI1RM.
	AFIO_PCFR_SPI1RM = 0x1
	// Position of I2C1RM field.
	AFIO_PCFR_I2C1RM_Pos = 0x1
	// Bit mask of I2C1RM field.
	AFIO_PCFR_I2C1RM_Msk = 0x2
	// Bit I2C1RM.
	AFIO_PCFR_I2C1RM = 0x2
	// Position of USART1RM field.
	AFIO_PCFR_USART1RM_Pos = 0x2
	// Bit mask of USART1RM field.
	AFIO_PCFR_USART1RM_Msk = 0x4
	// Bit USART1RM.
	AFIO_PCFR_USART1RM = 0x4
	// Position of TIM1RM field.
	AFIO_PCFR_TIM1RM_Pos = 0x6
	// Bit mask of TIM1RM field.
	AFIO_PCFR_TIM1RM_Msk = 0xc0
	// Position of TIM2RM field.
	AFIO_PCFR_TIM2RM_Pos = 0x8
	// Bit mask of TIM2RM field.
	AFIO_PCFR_TIM2RM_Msk = 0x300
	// Position of PA12RM field.
	AFIO_PCFR_PA12RM_Pos = 0xf
	// Bit mask of PA12RM field.
	AFIO_PCFR_PA12RM_Msk = 0x8000
	// Bit PA12RM.
	AFIO_PCFR_PA12RM = 0x8000
	// Position of ADC1_ETRGINJ_RM field.
	AFIO_PCFR_ADC1_ETRGINJ_RM_Pos = 0x11
	// Bit mask of ADC1_ETRGINJ_RM field.
	AFIO_PCFR_ADC1_ETRGINJ_RM_Msk = 0x20000
	// Bit ADC1_ETRGINJ_RM.
	AFIO_PCFR_ADC1_ETRGINJ_RM = 0x20000
	// Position of ADC1_ETRGREG_RM field.
	AFIO_PCFR_ADC1_ETRGREG_RM_Pos = 0x12
	// Bit mask of ADC1_ETRGREG_RM field.
	AFIO_PCFR_ADC1_ETRGREG_RM_Msk = 0x40000
	// Bit ADC1_ETRGREG_RM.
	AFIO_PCFR_ADC1_ETRGREG_RM = 0x40000
	// Position of USART1REMAP1 field.
	AFIO_PCFR_USART1REMAP1_Pos = 0x15
	// Bit mask of USART1REMAP1 field.
	AFIO_PCFR_USART1REMAP1_Msk = 0x200000
	// Bit USART1REMAP1.
	AFIO_PCFR_USART1REMAP1 = 0x200000
	// Position of I2C1REMAP1 field.
	AFIO_PCFR_I2C1REMAP1_Pos = 0x16
	// Bit mask of I2C1REMAP1 field.
	AFIO_PCFR_I2C1REMAP1_Msk = 0x400000
	// Bit I2C1REMAP1.
	AFIO_PCFR_I2C1REMAP1 = 0x400000
	// Position of TIM1_IREMAP field.
	AFIO_PCFR_TIM1_IREMAP_Pos = 0x17
	// Bit mask of TIM1_IREMAP field.
	AFIO_PCFR_TIM1_IREMAP_Msk = 0x800000
	// Bit TIM1_IREMAP.
	AFIO_PCFR_TIM1_IREMAP = 0x800000
	// Position of SWCFG field.
	AFIO_PCFR_SWCFG_Pos = 0x18
	// Bit mask of SWCFG field.
	AFIO_PCFR_SWCFG_Msk = 0x7000000

	// EXTICR: External interrupt configuration register (AFIO_EXTICR)
	// Position of EXTI0 field.
	AFIO_EXTICR_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	AFIO_EXTICR_EXTI0_Msk = 0x3
	// Position of EXTI1 field.
	AFIO_EXTICR_EXTI1_Pos = 0x2
	// Bit mask of EXTI1 field.
	AFIO_EXTICR_EXTI1_Msk = 0xc
	// Position of EXTI2 field.
	AFIO_EXTICR_EXTI2_Pos = 0x4
	// Bit mask of EXTI2 field.
	AFIO_EXTICR_EXTI2_Msk = 0x30
	// Position of EXTI3 field.
	AFIO_EXTICR_EXTI3_Pos = 0x6
	// Bit mask of EXTI3 field.
	AFIO_EXTICR_EXTI3_Msk = 0xc0
	// Position of EXTI4 field.
	AFIO_EXTICR_EXTI4_Pos = 0x8
	// Bit mask of EXTI4 field.
	AFIO_EXTICR_EXTI4_Msk = 0x300
	// Position of EXTI5 field.
	AFIO_EXTICR_EXTI5_Pos = 0xa
	// Bit mask of EXTI5 field.
	AFIO_EXTICR_EXTI5_Msk = 0xc00
	// Position of EXTI6 field.
	AFIO_EXTICR_EXTI6_Pos = 0xc
	// Bit mask of EXTI6 field.
	AFIO_EXTICR_EXTI6_Msk = 0x3000
	// Position of EXTI7 field.
	AFIO_EXTICR_EXTI7_Pos = 0xe
	// Bit mask of EXTI7 field.
	AFIO_EXTICR_EXTI7_Msk = 0xc000
)

// Constants for EXTI: EXTI
const (
	// INTENR: Interrupt mask register (EXTI_INTENR)
	// Position of MR0 field.
	EXTI_INTENR_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_INTENR_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_INTENR_MR0 = 0x1
	// Position of MR1 field.
	EXTI_INTENR_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_INTENR_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_INTENR_MR1 = 0x2
	// Position of MR2 field.
	EXTI_INTENR_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_INTENR_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_INTENR_MR2 = 0x4
	// Position of MR3 field.
	EXTI_INTENR_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_INTENR_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_INTENR_MR3 = 0x8
	// Position of MR4 field.
	EXTI_INTENR_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_INTENR_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_INTENR_MR4 = 0x10
	// Position of MR5 field.
	EXTI_INTENR_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_INTENR_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_INTENR_MR5 = 0x20
	// Position of MR6 field.
	EXTI_INTENR_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_INTENR_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_INTENR_MR6 = 0x40
	// Position of MR7 field.
	EXTI_INTENR_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_INTENR_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_INTENR_MR7 = 0x80
	// Position of MR8 field.
	EXTI_INTENR_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_INTENR_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_INTENR_MR8 = 0x100
	// Position of MR9 field.
	EXTI_INTENR_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_INTENR_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_INTENR_MR9 = 0x200

	// EVENR: Event mask register (EXTI_EVENR)
	// Position of MR0 field.
	EXTI_EVENR_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_EVENR_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_EVENR_MR0 = 0x1
	// Position of MR1 field.
	EXTI_EVENR_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_EVENR_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_EVENR_MR1 = 0x2
	// Position of MR2 field.
	EXTI_EVENR_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_EVENR_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_EVENR_MR2 = 0x4
	// Position of MR3 field.
	EXTI_EVENR_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_EVENR_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_EVENR_MR3 = 0x8
	// Position of MR4 field.
	EXTI_EVENR_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_EVENR_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_EVENR_MR4 = 0x10
	// Position of MR5 field.
	EXTI_EVENR_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_EVENR_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_EVENR_MR5 = 0x20
	// Position of MR6 field.
	EXTI_EVENR_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_EVENR_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_EVENR_MR6 = 0x40
	// Position of MR7 field.
	EXTI_EVENR_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_EVENR_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_EVENR_MR7 = 0x80
	// Position of MR8 field.
	EXTI_EVENR_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_EVENR_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_EVENR_MR8 = 0x100
	// Position of MR9 field.
	EXTI_EVENR_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_EVENR_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_EVENR_MR9 = 0x200

	// RTENR: Rising Trigger selection register (EXTI_RTENR)
	// Position of TR0 field.
	EXTI_RTENR_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_RTENR_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_RTENR_TR0 = 0x1
	// Position of TR1 field.
	EXTI_RTENR_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_RTENR_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_RTENR_TR1 = 0x2
	// Position of TR2 field.
	EXTI_RTENR_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_RTENR_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_RTENR_TR2 = 0x4
	// Position of TR3 field.
	EXTI_RTENR_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_RTENR_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_RTENR_TR3 = 0x8
	// Position of TR4 field.
	EXTI_RTENR_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_RTENR_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_RTENR_TR4 = 0x10
	// Position of TR5 field.
	EXTI_RTENR_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_RTENR_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_RTENR_TR5 = 0x20
	// Position of TR6 field.
	EXTI_RTENR_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_RTENR_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_RTENR_TR6 = 0x40
	// Position of TR7 field.
	EXTI_RTENR_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_RTENR_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_RTENR_TR7 = 0x80
	// Position of TR8 field.
	EXTI_RTENR_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_RTENR_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_RTENR_TR8 = 0x100
	// Position of TR9 field.
	EXTI_RTENR_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_RTENR_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_RTENR_TR9 = 0x200

	// FTENR: Falling Trigger selection register (EXTI_FTENR)
	// Position of TR0 field.
	EXTI_FTENR_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_FTENR_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_FTENR_TR0 = 0x1
	// Position of TR1 field.
	EXTI_FTENR_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_FTENR_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_FTENR_TR1 = 0x2
	// Position of TR2 field.
	EXTI_FTENR_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_FTENR_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_FTENR_TR2 = 0x4
	// Position of TR3 field.
	EXTI_FTENR_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_FTENR_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_FTENR_TR3 = 0x8
	// Position of TR4 field.
	EXTI_FTENR_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_FTENR_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_FTENR_TR4 = 0x10
	// Position of TR5 field.
	EXTI_FTENR_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_FTENR_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_FTENR_TR5 = 0x20
	// Position of TR6 field.
	EXTI_FTENR_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_FTENR_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_FTENR_TR6 = 0x40
	// Position of TR7 field.
	EXTI_FTENR_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_FTENR_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_FTENR_TR7 = 0x80
	// Position of TR8 field.
	EXTI_FTENR_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_FTENR_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_FTENR_TR8 = 0x100
	// Position of TR9 field.
	EXTI_FTENR_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_FTENR_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_FTENR_TR9 = 0x200

	// SWIEVR: Software interrupt event register (EXTI_SWIEVR)
	// Position of SWIER0 field.
	EXTI_SWIEVR_SWIER0_Pos = 0x0
	// Bit mask of SWIER0 field.
	EXTI_SWIEVR_SWIER0_Msk = 0x1
	// Bit SWIER0.
	EXTI_SWIEVR_SWIER0 = 0x1
	// Position of SWIER1 field.
	EXTI_SWIEVR_SWIER1_Pos = 0x1
	// Bit mask of SWIER1 field.
	EXTI_SWIEVR_SWIER1_Msk = 0x2
	// Bit SWIER1.
	EXTI_SWIEVR_SWIER1 = 0x2
	// Position of SWIER2 field.
	EXTI_SWIEVR_SWIER2_Pos = 0x2
	// Bit mask of SWIER2 field.
	EXTI_SWIEVR_SWIER2_Msk = 0x4
	// Bit SWIER2.
	EXTI_SWIEVR_SWIER2 = 0x4
	// Position of SWIER3 field.
	EXTI_SWIEVR_SWIER3_Pos = 0x3
	// Bit mask of SWIER3 field.
	EXTI_SWIEVR_SWIER3_Msk = 0x8
	// Bit SWIER3.
	EXTI_SWIEVR_SWIER3 = 0x8
	// Position of SWIER4 field.
	EXTI_SWIEVR_SWIER4_Pos = 0x4
	// Bit mask of SWIER4 field.
	EXTI_SWIEVR_SWIER4_Msk = 0x10
	// Bit SWIER4.
	EXTI_SWIEVR_SWIER4 = 0x10
	// Position of SWIER5 field.
	EXTI_SWIEVR_SWIER5_Pos = 0x5
	// Bit mask of SWIER5 field.
	EXTI_SWIEVR_SWIER5_Msk = 0x20
	// Bit SWIER5.
	EXTI_SWIEVR_SWIER5 = 0x20
	// Position of SWIER6 field.
	EXTI_SWIEVR_SWIER6_Pos = 0x6
	// Bit mask of SWIER6 field.
	EXTI_SWIEVR_SWIER6_Msk = 0x40
	// Bit SWIER6.
	EXTI_SWIEVR_SWIER6 = 0x40
	// Position of SWIER7 field.
	EXTI_SWIEVR_SWIER7_Pos = 0x7
	// Bit mask of SWIER7 field.
	EXTI_SWIEVR_SWIER7_Msk = 0x80
	// Bit SWIER7.
	EXTI_SWIEVR_SWIER7 = 0x80
	// Position of SWIER8 field.
	EXTI_SWIEVR_SWIER8_Pos = 0x8
	// Bit mask of SWIER8 field.
	EXTI_SWIEVR_SWIER8_Msk = 0x100
	// Bit SWIER8.
	EXTI_SWIEVR_SWIER8 = 0x100
	// Position of SWIER9 field.
	EXTI_SWIEVR_SWIER9_Pos = 0x9
	// Bit mask of SWIER9 field.
	EXTI_SWIEVR_SWIER9_Msk = 0x200
	// Bit SWIER9.
	EXTI_SWIEVR_SWIER9 = 0x200

	// INTFR: Pending register (EXTI_INTFR)
	// Position of PR0 field.
	EXTI_INTFR_PR0_Pos = 0x0
	// Bit mask of PR0 field.
	EXTI_INTFR_PR0_Msk = 0x1
	// Bit PR0.
	EXTI_INTFR_PR0 = 0x1
	// Position of PR1 field.
	EXTI_INTFR_PR1_Pos = 0x1
	// Bit mask of PR1 field.
	EXTI_INTFR_PR1_Msk = 0x2
	// Bit PR1.
	EXTI_INTFR_PR1 = 0x2
	// Position of PR2 field.
	EXTI_INTFR_PR2_Pos = 0x2
	// Bit mask of PR2 field.
	EXTI_INTFR_PR2_Msk = 0x4
	// Bit PR2.
	EXTI_INTFR_PR2 = 0x4
	// Position of PR3 field.
	EXTI_INTFR_PR3_Pos = 0x3
	// Bit mask of PR3 field.
	EXTI_INTFR_PR3_Msk = 0x8
	// Bit PR3.
	EXTI_INTFR_PR3 = 0x8
	// Position of PR4 field.
	EXTI_INTFR_PR4_Pos = 0x4
	// Bit mask of PR4 field.
	EXTI_INTFR_PR4_Msk = 0x10
	// Bit PR4.
	EXTI_INTFR_PR4 = 0x10
	// Position of PR5 field.
	EXTI_INTFR_PR5_Pos = 0x5
	// Bit mask of PR5 field.
	EXTI_INTFR_PR5_Msk = 0x20
	// Bit PR5.
	EXTI_INTFR_PR5 = 0x20
	// Position of PR6 field.
	EXTI_INTFR_PR6_Pos = 0x6
	// Bit mask of PR6 field.
	EXTI_INTFR_PR6_Msk = 0x40
	// Bit PR6.
	EXTI_INTFR_PR6 = 0x40
	// Position of PR7 field.
	EXTI_INTFR_PR7_Pos = 0x7
	// Bit mask of PR7 field.
	EXTI_INTFR_PR7_Msk = 0x80
	// Bit PR7.
	EXTI_INTFR_PR7 = 0x80
	// Position of PR8 field.
	EXTI_INTFR_PR8_Pos = 0x8
	// Bit mask of PR8 field.
	EXTI_INTFR_PR8_Msk = 0x100
	// Bit PR8.
	EXTI_INTFR_PR8 = 0x100
	// Position of PR9 field.
	EXTI_INTFR_PR9_Pos = 0x9
	// Bit mask of PR9 field.
	EXTI_INTFR_PR9_Msk = 0x200
	// Bit PR9.
	EXTI_INTFR_PR9 = 0x200
)

// Constants for DMA1: DMA1 controller
const (
	// INTFR: DMA interrupt status register (DMA_INTFR)
	// Position of GIF1 field.
	DMA1_INTFR_GIF1_Pos = 0x0
	// Bit mask of GIF1 field.
	DMA1_INTFR_GIF1_Msk = 0x1
	// Bit GIF1.
	DMA1_INTFR_GIF1 = 0x1
	// Position of TCIF1 field.
	DMA1_INTFR_TCIF1_Pos = 0x1
	// Bit mask of TCIF1 field.
	DMA1_INTFR_TCIF1_Msk = 0x2
	// Bit TCIF1.
	DMA1_INTFR_TCIF1 = 0x2
	// Position of HTIF1 field.
	DMA1_INTFR_HTIF1_Pos = 0x2
	// Bit mask of HTIF1 field.
	DMA1_INTFR_HTIF1_Msk = 0x4
	// Bit HTIF1.
	DMA1_INTFR_HTIF1 = 0x4
	// Position of TEIF1 field.
	DMA1_INTFR_TEIF1_Pos = 0x3
	// Bit mask of TEIF1 field.
	DMA1_INTFR_TEIF1_Msk = 0x8
	// Bit TEIF1.
	DMA1_INTFR_TEIF1 = 0x8
	// Position of GIF2 field.
	DMA1_INTFR_GIF2_Pos = 0x4
	// Bit mask of GIF2 field.
	DMA1_INTFR_GIF2_Msk = 0x10
	// Bit GIF2.
	DMA1_INTFR_GIF2 = 0x10
	// Position of TCIF2 field.
	DMA1_INTFR_TCIF2_Pos = 0x5
	// Bit mask of TCIF2 field.
	DMA1_INTFR_TCIF2_Msk = 0x20
	// Bit TCIF2.
	DMA1_INTFR_TCIF2 = 0x20
	// Position of HTIF2 field.
	DMA1_INTFR_HTIF2_Pos = 0x6
	// Bit mask of HTIF2 field.
	DMA1_INTFR_HTIF2_Msk = 0x40
	// Bit HTIF2.
	DMA1_INTFR_HTIF2 = 0x40
	// Position of TEIF2 field.
	DMA1_INTFR_TEIF2_Pos = 0x7
	// Bit mask of TEIF2 field.
	DMA1_INTFR_TEIF2_Msk = 0x80
	// Bit TEIF2.
	DMA1_INTFR_TEIF2 = 0x80
	// Position of GIF3 field.
	DMA1_INTFR_GIF3_Pos = 0x8
	// Bit mask of GIF3 field.
	DMA1_INTFR_GIF3_Msk = 0x100
	// Bit GIF3.
	DMA1_INTFR_GIF3 = 0x100
	// Position of TCIF3 field.
	DMA1_INTFR_TCIF3_Pos = 0x9
	// Bit mask of TCIF3 field.
	DMA1_INTFR_TCIF3_Msk = 0x200
	// Bit TCIF3.
	DMA1_INTFR_TCIF3 = 0x200
	// Position of HTIF3 field.
	DMA1_INTFR_HTIF3_Pos = 0xa
	// Bit mask of HTIF3 field.
	DMA1_INTFR_HTIF3_Msk = 0x400
	// Bit HTIF3.
	DMA1_INTFR_HTIF3 = 0x400
	// Position of TEIF3 field.
	DMA1_INTFR_TEIF3_Pos = 0xb
	// Bit mask of TEIF3 field.
	DMA1_INTFR_TEIF3_Msk = 0x800
	// Bit TEIF3.
	DMA1_INTFR_TEIF3 = 0x800
	// Position of GIF4 field.
	DMA1_INTFR_GIF4_Pos = 0xc
	// Bit mask of GIF4 field.
	DMA1_INTFR_GIF4_Msk = 0x1000
	// Bit GIF4.
	DMA1_INTFR_GIF4 = 0x1000
	// Position of TCIF4 field.
	DMA1_INTFR_TCIF4_Pos = 0xd
	// Bit mask of TCIF4 field.
	DMA1_INTFR_TCIF4_Msk = 0x2000
	// Bit TCIF4.
	DMA1_INTFR_TCIF4 = 0x2000
	// Position of HTIF4 field.
	DMA1_INTFR_HTIF4_Pos = 0xe
	// Bit mask of HTIF4 field.
	DMA1_INTFR_HTIF4_Msk = 0x4000
	// Bit HTIF4.
	DMA1_INTFR_HTIF4 = 0x4000
	// Position of TEIF4 field.
	DMA1_INTFR_TEIF4_Pos = 0xf
	// Bit mask of TEIF4 field.
	DMA1_INTFR_TEIF4_Msk = 0x8000
	// Bit TEIF4.
	DMA1_INTFR_TEIF4 = 0x8000
	// Position of GIF5 field.
	DMA1_INTFR_GIF5_Pos = 0x10
	// Bit mask of GIF5 field.
	DMA1_INTFR_GIF5_Msk = 0x10000
	// Bit GIF5.
	DMA1_INTFR_GIF5 = 0x10000
	// Position of TCIF5 field.
	DMA1_INTFR_TCIF5_Pos = 0x11
	// Bit mask of TCIF5 field.
	DMA1_INTFR_TCIF5_Msk = 0x20000
	// Bit TCIF5.
	DMA1_INTFR_TCIF5 = 0x20000
	// Position of HTIF5 field.
	DMA1_INTFR_HTIF5_Pos = 0x12
	// Bit mask of HTIF5 field.
	DMA1_INTFR_HTIF5_Msk = 0x40000
	// Bit HTIF5.
	DMA1_INTFR_HTIF5 = 0x40000
	// Position of TEIF5 field.
	DMA1_INTFR_TEIF5_Pos = 0x13
	// Bit mask of TEIF5 field.
	DMA1_INTFR_TEIF5_Msk = 0x80000
	// Bit TEIF5.
	DMA1_INTFR_TEIF5 = 0x80000
	// Position of GIF6 field.
	DMA1_INTFR_GIF6_Pos = 0x14
	// Bit mask of GIF6 field.
	DMA1_INTFR_GIF6_Msk = 0x100000
	// Bit GIF6.
	DMA1_INTFR_GIF6 = 0x100000
	// Position of TCIF6 field.
	DMA1_INTFR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA1_INTFR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA1_INTFR_TCIF6 = 0x200000
	// Position of HTIF6 field.
	DMA1_INTFR_HTIF6_Pos = 0x16
	// Bit mask of HTIF6 field.
	DMA1_INTFR_HTIF6_Msk = 0x400000
	// Bit HTIF6.
	DMA1_INTFR_HTIF6 = 0x400000
	// Position of TEIF6 field.
	DMA1_INTFR_TEIF6_Pos = 0x17
	// Bit mask of TEIF6 field.
	DMA1_INTFR_TEIF6_Msk = 0x800000
	// Bit TEIF6.
	DMA1_INTFR_TEIF6 = 0x800000
	// Position of GIF7 field.
	DMA1_INTFR_GIF7_Pos = 0x18
	// Bit mask of GIF7 field.
	DMA1_INTFR_GIF7_Msk = 0x1000000
	// Bit GIF7.
	DMA1_INTFR_GIF7 = 0x1000000
	// Position of TCIF7 field.
	DMA1_INTFR_TCIF7_Pos = 0x19
	// Bit mask of TCIF7 field.
	DMA1_INTFR_TCIF7_Msk = 0x2000000
	// Bit TCIF7.
	DMA1_INTFR_TCIF7 = 0x2000000
	// Position of HTIF7 field.
	DMA1_INTFR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA1_INTFR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA1_INTFR_HTIF7 = 0x4000000
	// Position of TEIF7 field.
	DMA1_INTFR_TEIF7_Pos = 0x1b
	// Bit mask of TEIF7 field.
	DMA1_INTFR_TEIF7_Msk = 0x8000000
	// Bit TEIF7.
	DMA1_INTFR_TEIF7 = 0x8000000

	// INTFCR: DMA interrupt flag clear register (DMA_INTFCR)
	// Position of CGIF1 field.
	DMA1_INTFCR_CGIF1_Pos = 0x0
	// Bit mask of CGIF1 field.
	DMA1_INTFCR_CGIF1_Msk = 0x1
	// Bit CGIF1.
	DMA1_INTFCR_CGIF1 = 0x1
	// Position of CGIF2 field.
	DMA1_INTFCR_CGIF2_Pos = 0x4
	// Bit mask of CGIF2 field.
	DMA1_INTFCR_CGIF2_Msk = 0x10
	// Bit CGIF2.
	DMA1_INTFCR_CGIF2 = 0x10
	// Position of CGIF3 field.
	DMA1_INTFCR_CGIF3_Pos = 0x8
	// Bit mask of CGIF3 field.
	DMA1_INTFCR_CGIF3_Msk = 0x100
	// Bit CGIF3.
	DMA1_INTFCR_CGIF3 = 0x100
	// Position of CGIF4 field.
	DMA1_INTFCR_CGIF4_Pos = 0xc
	// Bit mask of CGIF4 field.
	DMA1_INTFCR_CGIF4_Msk = 0x1000
	// Bit CGIF4.
	DMA1_INTFCR_CGIF4 = 0x1000
	// Position of CGIF5 field.
	DMA1_INTFCR_CGIF5_Pos = 0x10
	// Bit mask of CGIF5 field.
	DMA1_INTFCR_CGIF5_Msk = 0x10000
	// Bit CGIF5.
	DMA1_INTFCR_CGIF5 = 0x10000
	// Position of CGIF6 field.
	DMA1_INTFCR_CGIF6_Pos = 0x14
	// Bit mask of CGIF6 field.
	DMA1_INTFCR_CGIF6_Msk = 0x100000
	// Bit CGIF6.
	DMA1_INTFCR_CGIF6 = 0x100000
	// Position of CGIF7 field.
	DMA1_INTFCR_CGIF7_Pos = 0x18
	// Bit mask of CGIF7 field.
	DMA1_INTFCR_CGIF7_Msk = 0x1000000
	// Bit CGIF7.
	DMA1_INTFCR_CGIF7 = 0x1000000
	// Position of CTCIF1 field.
	DMA1_INTFCR_CTCIF1_Pos = 0x1
	// Bit mask of CTCIF1 field.
	DMA1_INTFCR_CTCIF1_Msk = 0x2
	// Bit CTCIF1.
	DMA1_INTFCR_CTCIF1 = 0x2
	// Position of CTCIF2 field.
	DMA1_INTFCR_CTCIF2_Pos = 0x5
	// Bit mask of CTCIF2 field.
	DMA1_INTFCR_CTCIF2_Msk = 0x20
	// Bit CTCIF2.
	DMA1_INTFCR_CTCIF2 = 0x20
	// Position of CTCIF3 field.
	DMA1_INTFCR_CTCIF3_Pos = 0x9
	// Bit mask of CTCIF3 field.
	DMA1_INTFCR_CTCIF3_Msk = 0x200
	// Bit CTCIF3.
	DMA1_INTFCR_CTCIF3 = 0x200
	// Position of CTCIF4 field.
	DMA1_INTFCR_CTCIF4_Pos = 0xd
	// Bit mask of CTCIF4 field.
	DMA1_INTFCR_CTCIF4_Msk = 0x2000
	// Bit CTCIF4.
	DMA1_INTFCR_CTCIF4 = 0x2000
	// Position of CTCIF5 field.
	DMA1_INTFCR_CTCIF5_Pos = 0x11
	// Bit mask of CTCIF5 field.
	DMA1_INTFCR_CTCIF5_Msk = 0x20000
	// Bit CTCIF5.
	DMA1_INTFCR_CTCIF5 = 0x20000
	// Position of CTCIF6 field.
	DMA1_INTFCR_CTCIF6_Pos = 0x15
	// Bit mask of CTCIF6 field.
	DMA1_INTFCR_CTCIF6_Msk = 0x200000
	// Bit CTCIF6.
	DMA1_INTFCR_CTCIF6 = 0x200000
	// Position of CTCIF7 field.
	DMA1_INTFCR_CTCIF7_Pos = 0x19
	// Bit mask of CTCIF7 field.
	DMA1_INTFCR_CTCIF7_Msk = 0x2000000
	// Bit CTCIF7.
	DMA1_INTFCR_CTCIF7 = 0x2000000
	// Position of CHTIF1 field.
	DMA1_INTFCR_CHTIF1_Pos = 0x2
	// Bit mask of CHTIF1 field.
	DMA1_INTFCR_CHTIF1_Msk = 0x4
	// Bit CHTIF1.
	DMA1_INTFCR_CHTIF1 = 0x4
	// Position of CHTIF2 field.
	DMA1_INTFCR_CHTIF2_Pos = 0x6
	// Bit mask of CHTIF2 field.
	DMA1_INTFCR_CHTIF2_Msk = 0x40
	// Bit CHTIF2.
	DMA1_INTFCR_CHTIF2 = 0x40
	// Position of CHTIF3 field.
	DMA1_INTFCR_CHTIF3_Pos = 0xa
	// Bit mask of CHTIF3 field.
	DMA1_INTFCR_CHTIF3_Msk = 0x400
	// Bit CHTIF3.
	DMA1_INTFCR_CHTIF3 = 0x400
	// Position of CHTIF4 field.
	DMA1_INTFCR_CHTIF4_Pos = 0xe
	// Bit mask of CHTIF4 field.
	DMA1_INTFCR_CHTIF4_Msk = 0x4000
	// Bit CHTIF4.
	DMA1_INTFCR_CHTIF4 = 0x4000
	// Position of CHTIF5 field.
	DMA1_INTFCR_CHTIF5_Pos = 0x12
	// Bit mask of CHTIF5 field.
	DMA1_INTFCR_CHTIF5_Msk = 0x40000
	// Bit CHTIF5.
	DMA1_INTFCR_CHTIF5 = 0x40000
	// Position of CHTIF6 field.
	DMA1_INTFCR_CHTIF6_Pos = 0x16
	// Bit mask of CHTIF6 field.
	DMA1_INTFCR_CHTIF6_Msk = 0x400000
	// Bit CHTIF6.
	DMA1_INTFCR_CHTIF6 = 0x400000
	// Position of CHTIF7 field.
	DMA1_INTFCR_CHTIF7_Pos = 0x1a
	// Bit mask of CHTIF7 field.
	DMA1_INTFCR_CHTIF7_Msk = 0x4000000
	// Bit CHTIF7.
	DMA1_INTFCR_CHTIF7 = 0x4000000
	// Position of CTEIF1 field.
	DMA1_INTFCR_CTEIF1_Pos = 0x3
	// Bit mask of CTEIF1 field.
	DMA1_INTFCR_CTEIF1_Msk = 0x8
	// Bit CTEIF1.
	DMA1_INTFCR_CTEIF1 = 0x8
	// Position of CTEIF2 field.
	DMA1_INTFCR_CTEIF2_Pos = 0x7
	// Bit mask of CTEIF2 field.
	DMA1_INTFCR_CTEIF2_Msk = 0x80
	// Bit CTEIF2.
	DMA1_INTFCR_CTEIF2 = 0x80
	// Position of CTEIF3 field.
	DMA1_INTFCR_CTEIF3_Pos = 0xb
	// Bit mask of CTEIF3 field.
	DMA1_INTFCR_CTEIF3_Msk = 0x800
	// Bit CTEIF3.
	DMA1_INTFCR_CTEIF3 = 0x800
	// Position of CTEIF4 field.
	DMA1_INTFCR_CTEIF4_Pos = 0xf
	// Bit mask of CTEIF4 field.
	DMA1_INTFCR_CTEIF4_Msk = 0x8000
	// Bit CTEIF4.
	DMA1_INTFCR_CTEIF4 = 0x8000
	// Position of CTEIF5 field.
	DMA1_INTFCR_CTEIF5_Pos = 0x13
	// Bit mask of CTEIF5 field.
	DMA1_INTFCR_CTEIF5_Msk = 0x80000
	// Bit CTEIF5.
	DMA1_INTFCR_CTEIF5 = 0x80000
	// Position of CTEIF6 field.
	DMA1_INTFCR_CTEIF6_Pos = 0x17
	// Bit mask of CTEIF6 field.
	DMA1_INTFCR_CTEIF6_Msk = 0x800000
	// Bit CTEIF6.
	DMA1_INTFCR_CTEIF6 = 0x800000
	// Position of CTEIF7 field.
	DMA1_INTFCR_CTEIF7_Pos = 0x1b
	// Bit mask of CTEIF7 field.
	DMA1_INTFCR_CTEIF7_Msk = 0x8000000
	// Bit CTEIF7.
	DMA1_INTFCR_CTEIF7 = 0x8000000

	// CFGR1: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR1_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR1_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR1_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR1_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR1_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR1_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR1_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR1_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR1_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR1_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR1_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR1_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR1_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR1_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR1_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR1_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR1_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR1_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR1_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR1_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR1_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR1_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR1_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR1_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR1_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR1_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR1_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR1_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR1_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR1_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR1_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR1_MEM2MEM = 0x4000

	// CNTR1: DMA channel 1 number of data register
	// Position of NDT field.
	DMA1_CNTR1_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR1_NDT_Msk = 0xffff

	// PADDR1: DMA channel 1 peripheral address register
	// Position of PA field.
	DMA1_PADDR1_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR1_PA_Msk = 0xffffffff

	// MADDR1: DMA channel 1 memory address register
	// Position of MA field.
	DMA1_MADDR1_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR1_MA_Msk = 0xffffffff

	// CFGR2: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR2_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR2_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR2_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR2_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR2_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR2_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR2_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR2_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR2_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR2_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR2_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR2_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR2_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR2_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR2_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR2_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR2_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR2_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR2_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR2_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR2_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR2_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR2_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR2_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR2_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR2_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR2_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR2_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR2_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR2_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR2_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR2_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR2_MEM2MEM = 0x4000

	// CNTR2: DMA channel 2 number of data register
	// Position of NDT field.
	DMA1_CNTR2_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR2_NDT_Msk = 0xffff

	// PADDR2: DMA channel 2 peripheral address register
	// Position of PA field.
	DMA1_PADDR2_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR2_PA_Msk = 0xffffffff

	// MADDR2: DMA channel 2 memory address register
	// Position of MA field.
	DMA1_MADDR2_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR2_MA_Msk = 0xffffffff

	// CFGR3: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR3_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR3_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR3_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR3_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR3_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR3_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR3_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR3_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR3_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR3_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR3_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR3_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR3_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR3_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR3_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR3_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR3_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR3_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR3_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR3_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR3_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR3_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR3_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR3_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR3_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR3_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR3_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR3_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR3_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR3_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR3_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR3_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR3_MEM2MEM = 0x4000

	// CNTR3: DMA channel 3 number of data register
	// Position of NDT field.
	DMA1_CNTR3_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR3_NDT_Msk = 0xffff

	// PADDR3: DMA channel 3 peripheral address register
	// Position of PA field.
	DMA1_PADDR3_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR3_PA_Msk = 0xffffffff

	// MADDR3: DMA channel 3 memory address register
	// Position of MA field.
	DMA1_MADDR3_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR3_MA_Msk = 0xffffffff

	// CFGR4: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR4_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR4_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR4_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR4_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR4_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR4_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR4_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR4_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR4_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR4_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR4_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR4_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR4_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR4_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR4_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR4_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR4_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR4_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR4_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR4_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR4_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR4_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR4_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR4_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR4_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR4_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR4_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR4_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR4_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR4_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR4_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR4_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR4_MEM2MEM = 0x4000

	// CNTR4: DMA channel 4 number of data register
	// Position of NDT field.
	DMA1_CNTR4_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR4_NDT_Msk = 0xffff

	// PADDR4: DMA channel 4 peripheral address register
	// Position of PA field.
	DMA1_PADDR4_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR4_PA_Msk = 0xffffffff

	// MADDR4: DMA channel 4 memory address register
	// Position of MA field.
	DMA1_MADDR4_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR4_MA_Msk = 0xffffffff

	// CFGR5: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR5_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR5_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR5_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR5_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR5_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR5_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR5_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR5_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR5_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR5_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR5_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR5_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR5_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR5_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR5_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR5_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR5_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR5_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR5_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR5_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR5_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR5_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR5_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR5_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR5_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR5_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR5_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR5_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR5_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR5_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR5_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR5_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR5_MEM2MEM = 0x4000

	// CNTR5: DMA channel 5 number of data register
	// Position of NDT field.
	DMA1_CNTR5_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR5_NDT_Msk = 0xffff

	// PADDR5: DMA channel 5 peripheral address register
	// Position of PA field.
	DMA1_PADDR5_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR5_PA_Msk = 0xffffffff

	// MADDR5: DMA channel 5 memory address register
	// Position of MA field.
	DMA1_MADDR5_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR5_MA_Msk = 0xffffffff

	// CFGR6: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR6_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR6_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR6_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR6_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR6_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR6_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR6_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR6_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR6_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR6_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR6_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR6_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR6_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR6_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR6_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR6_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR6_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR6_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR6_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR6_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR6_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR6_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR6_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR6_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR6_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR6_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR6_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR6_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR6_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR6_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR6_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR6_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR6_MEM2MEM = 0x4000

	// CNTR6: DMA channel 6 number of data register
	// Position of NDT field.
	DMA1_CNTR6_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR6_NDT_Msk = 0xffff

	// PADDR6: DMA channel 6 peripheral address register
	// Position of PA field.
	DMA1_PADDR6_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR6_PA_Msk = 0xffffffff

	// MADDR6: DMA channel 6 memory address register
	// Position of MA field.
	DMA1_MADDR6_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR6_MA_Msk = 0xffffffff

	// CFGR7: DMA channel configuration register (DMA_CFGR)
	// Position of EN field.
	DMA1_CFGR7_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA1_CFGR7_EN_Msk = 0x1
	// Bit EN.
	DMA1_CFGR7_EN = 0x1
	// Position of TCIE field.
	DMA1_CFGR7_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA1_CFGR7_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA1_CFGR7_TCIE = 0x2
	// Position of HTIE field.
	DMA1_CFGR7_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA1_CFGR7_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA1_CFGR7_HTIE = 0x4
	// Position of TEIE field.
	DMA1_CFGR7_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA1_CFGR7_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA1_CFGR7_TEIE = 0x8
	// Position of DIR field.
	DMA1_CFGR7_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA1_CFGR7_DIR_Msk = 0x10
	// Bit DIR.
	DMA1_CFGR7_DIR = 0x10
	// Position of CIRC field.
	DMA1_CFGR7_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA1_CFGR7_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA1_CFGR7_CIRC = 0x20
	// Position of PINC field.
	DMA1_CFGR7_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA1_CFGR7_PINC_Msk = 0x40
	// Bit PINC.
	DMA1_CFGR7_PINC = 0x40
	// Position of MINC field.
	DMA1_CFGR7_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA1_CFGR7_MINC_Msk = 0x80
	// Bit MINC.
	DMA1_CFGR7_MINC = 0x80
	// Position of PSIZE field.
	DMA1_CFGR7_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA1_CFGR7_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA1_CFGR7_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA1_CFGR7_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA1_CFGR7_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA1_CFGR7_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA1_CFGR7_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA1_CFGR7_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA1_CFGR7_MEM2MEM = 0x4000

	// CNTR7: DMA channel 7 number of data register
	// Position of NDT field.
	DMA1_CNTR7_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA1_CNTR7_NDT_Msk = 0xffff

	// PADDR7: DMA channel 7 peripheral address register
	// Position of PA field.
	DMA1_PADDR7_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA1_PADDR7_PA_Msk = 0xffffffff

	// MADDR7: DMA channel 7 memory address register
	// Position of MA field.
	DMA1_MADDR7_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA1_MADDR7_MA_Msk = 0xffffffff
)

// Constants for IWDG: Independent watchdog
const (
	// CTLR: Key register (IWDG_CTLR)
	// Position of KEY field.
	IWDG_CTLR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_CTLR_KEY_Msk = 0xffff

	// PSCR: Prescaler register (IWDG_PSCR)
	// Position of PR field.
	IWDG_PSCR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PSCR_PR_Msk = 0x7

	// RLDR: Reload register (IWDG_RLDR)
	// Position of RL field.
	IWDG_RLDR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLDR_RL_Msk = 0xfff

	// STATR: Status register (IWDG_SR)
	// Position of PVU field.
	IWDG_STATR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_STATR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_STATR_PVU = 0x1
	// Position of RVU field.
	IWDG_STATR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_STATR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_STATR_RVU = 0x2
)

// Constants for WWDG: Window watchdog
const (
	// CTLR: Control register (WWDG_CR)
	// Position of T field.
	WWDG_CTLR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CTLR_T_Msk = 0x7f
	// Position of WDGA field.
	WWDG_CTLR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CTLR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CTLR_WDGA = 0x80

	// CFGR: Configuration register (WWDG_CFR)
	// Position of W field.
	WWDG_CFGR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFGR_W_Msk = 0x7f
	// Position of WDGTB field.
	WWDG_CFGR_WDGTB_Pos = 0x7
	// Bit mask of WDGTB field.
	WWDG_CFGR_WDGTB_Msk = 0x180
	// Position of EWI field.
	WWDG_CFGR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFGR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFGR_EWI = 0x200

	// STATR: Status register (WWDG_SR)
	// Position of WEIF field.
	WWDG_STATR_WEIF_Pos = 0x0
	// Bit mask of WEIF field.
	WWDG_STATR_WEIF_Msk = 0x1
	// Bit WEIF.
	WWDG_STATR_WEIF = 0x1
)

// Constants for TIM1: Advanced timer
const (
	// CTLR1: control register 1
	// Position of TMR_CAP_LVL_EN field.
	TIM_CTLR1_TMR_CAP_LVL_EN_Pos = 0xf
	// Bit mask of TMR_CAP_LVL_EN field.
	TIM_CTLR1_TMR_CAP_LVL_EN_Msk = 0x8000
	// Bit TMR_CAP_LVL_EN.
	TIM_CTLR1_TMR_CAP_LVL_EN = 0x8000
	// Position of TMR_CAP_OV_EN field.
	TIM_CTLR1_TMR_CAP_OV_EN_Pos = 0xe
	// Bit mask of TMR_CAP_OV_EN field.
	TIM_CTLR1_TMR_CAP_OV_EN_Msk = 0x4000
	// Bit TMR_CAP_OV_EN.
	TIM_CTLR1_TMR_CAP_OV_EN = 0x4000
	// Position of CKD field.
	TIM_CTLR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CTLR1_CKD_Msk = 0x300
	// Position of ARPE field.
	TIM_CTLR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CTLR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CTLR1_ARPE = 0x80
	// Position of CMS field.
	TIM_CTLR1_CMS_Pos = 0x5
	// Bit mask of CMS field.
	TIM_CTLR1_CMS_Msk = 0x60
	// Position of DIR field.
	TIM_CTLR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TIM_CTLR1_DIR_Msk = 0x10
	// Bit DIR.
	TIM_CTLR1_DIR = 0x10
	// Position of OPM field.
	TIM_CTLR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CTLR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CTLR1_OPM = 0x8
	// Position of URS field.
	TIM_CTLR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CTLR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CTLR1_URS = 0x4
	// Position of UDIS field.
	TIM_CTLR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CTLR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CTLR1_UDIS = 0x2
	// Position of CEN field.
	TIM_CTLR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CTLR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CTLR1_CEN = 0x1

	// CTLR2: control register 2
	// Position of OIS4 field.
	TIM_CTLR2_OIS4_Pos = 0xe
	// Bit mask of OIS4 field.
	TIM_CTLR2_OIS4_Msk = 0x4000
	// Bit OIS4.
	TIM_CTLR2_OIS4 = 0x4000
	// Position of OIS3N field.
	TIM_CTLR2_OIS3N_Pos = 0xd
	// Bit mask of OIS3N field.
	TIM_CTLR2_OIS3N_Msk = 0x2000
	// Bit OIS3N.
	TIM_CTLR2_OIS3N = 0x2000
	// Position of OIS3 field.
	TIM_CTLR2_OIS3_Pos = 0xc
	// Bit mask of OIS3 field.
	TIM_CTLR2_OIS3_Msk = 0x1000
	// Bit OIS3.
	TIM_CTLR2_OIS3 = 0x1000
	// Position of OIS2N field.
	TIM_CTLR2_OIS2N_Pos = 0xb
	// Bit mask of OIS2N field.
	TIM_CTLR2_OIS2N_Msk = 0x800
	// Bit OIS2N.
	TIM_CTLR2_OIS2N = 0x800
	// Position of OIS2 field.
	TIM_CTLR2_OIS2_Pos = 0xa
	// Bit mask of OIS2 field.
	TIM_CTLR2_OIS2_Msk = 0x400
	// Bit OIS2.
	TIM_CTLR2_OIS2 = 0x400
	// Position of OIS1N field.
	TIM_CTLR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIM_CTLR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIM_CTLR2_OIS1N = 0x200
	// Position of OIS1 field.
	TIM_CTLR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIM_CTLR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIM_CTLR2_OIS1 = 0x100
	// Position of TI1S field.
	TIM_CTLR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIM_CTLR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIM_CTLR2_TI1S = 0x80
	// Position of MMS field.
	TIM_CTLR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIM_CTLR2_MMS_Msk = 0x70
	// Position of CCDS field.
	TIM_CTLR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CTLR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CTLR2_CCDS = 0x8
	// Position of CCUS field.
	TIM_CTLR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIM_CTLR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIM_CTLR2_CCUS = 0x4
	// Position of CCPC field.
	TIM_CTLR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIM_CTLR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIM_CTLR2_CCPC = 0x1

	// SMCFGR: slave mode control register
	// Position of ETP field.
	TIM_SMCFGR_ETP_Pos = 0xf
	// Bit mask of ETP field.
	TIM_SMCFGR_ETP_Msk = 0x8000
	// Bit ETP.
	TIM_SMCFGR_ETP = 0x8000
	// Position of ECE field.
	TIM_SMCFGR_ECE_Pos = 0xe
	// Bit mask of ECE field.
	TIM_SMCFGR_ECE_Msk = 0x4000
	// Bit ECE.
	TIM_SMCFGR_ECE = 0x4000
	// Position of ETPS field.
	TIM_SMCFGR_ETPS_Pos = 0xc
	// Bit mask of ETPS field.
	TIM_SMCFGR_ETPS_Msk = 0x3000
	// Position of ETF field.
	TIM_SMCFGR_ETF_Pos = 0x8
	// Bit mask of ETF field.
	TIM_SMCFGR_ETF_Msk = 0xf00
	// Position of MSM field.
	TIM_SMCFGR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIM_SMCFGR_MSM_Msk = 0x80
	// Bit MSM.
	TIM_SMCFGR_MSM = 0x80
	// Position of TS field.
	TIM_SMCFGR_TS_Pos = 0x4
	// Bit mask of TS field.
	TIM_SMCFGR_TS_Msk = 0x70
	// Position of SMS field.
	TIM_SMCFGR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIM_SMCFGR_SMS_Msk = 0x7

	// DMAINTENR: DMA/Interrupt enable register
	// Position of TDE field.
	TIM_DMAINTENR_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIM_DMAINTENR_TDE_Msk = 0x4000
	// Bit TDE.
	TIM_DMAINTENR_TDE = 0x4000
	// Position of COMDE field.
	TIM_DMAINTENR_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DMAINTENR_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DMAINTENR_COMDE = 0x2000
	// Position of CC4DE field.
	TIM_DMAINTENR_CC4DE_Pos = 0xc
	// Bit mask of CC4DE field.
	TIM_DMAINTENR_CC4DE_Msk = 0x1000
	// Bit CC4DE.
	TIM_DMAINTENR_CC4DE = 0x1000
	// Position of CC3DE field.
	TIM_DMAINTENR_CC3DE_Pos = 0xb
	// Bit mask of CC3DE field.
	TIM_DMAINTENR_CC3DE_Msk = 0x800
	// Bit CC3DE.
	TIM_DMAINTENR_CC3DE = 0x800
	// Position of CC2DE field.
	TIM_DMAINTENR_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIM_DMAINTENR_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIM_DMAINTENR_CC2DE = 0x400
	// Position of CC1DE field.
	TIM_DMAINTENR_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DMAINTENR_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DMAINTENR_CC1DE = 0x200
	// Position of UDE field.
	TIM_DMAINTENR_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DMAINTENR_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DMAINTENR_UDE = 0x100
	// Position of BIE field.
	TIM_DMAINTENR_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIM_DMAINTENR_BIE_Msk = 0x80
	// Bit BIE.
	TIM_DMAINTENR_BIE = 0x80
	// Position of TIE field.
	TIM_DMAINTENR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIM_DMAINTENR_TIE_Msk = 0x40
	// Bit TIE.
	TIM_DMAINTENR_TIE = 0x40
	// Position of COMIE field.
	TIM_DMAINTENR_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIM_DMAINTENR_COMIE_Msk = 0x20
	// Bit COMIE.
	TIM_DMAINTENR_COMIE = 0x20
	// Position of CC4IE field.
	TIM_DMAINTENR_CC4IE_Pos = 0x4
	// Bit mask of CC4IE field.
	TIM_DMAINTENR_CC4IE_Msk = 0x10
	// Bit CC4IE.
	TIM_DMAINTENR_CC4IE = 0x10
	// Position of CC3IE field.
	TIM_DMAINTENR_CC3IE_Pos = 0x3
	// Bit mask of CC3IE field.
	TIM_DMAINTENR_CC3IE_Msk = 0x8
	// Bit CC3IE.
	TIM_DMAINTENR_CC3IE = 0x8
	// Position of CC2IE field.
	TIM_DMAINTENR_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIM_DMAINTENR_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIM_DMAINTENR_CC2IE = 0x4
	// Position of CC1IE field.
	TIM_DMAINTENR_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DMAINTENR_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DMAINTENR_CC1IE = 0x2
	// Position of UIE field.
	TIM_DMAINTENR_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DMAINTENR_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DMAINTENR_UIE = 0x1

	// INTFR: status register
	// Position of CC4OF field.
	TIM_INTFR_CC4OF_Pos = 0xc
	// Bit mask of CC4OF field.
	TIM_INTFR_CC4OF_Msk = 0x1000
	// Bit CC4OF.
	TIM_INTFR_CC4OF = 0x1000
	// Position of CC3OF field.
	TIM_INTFR_CC3OF_Pos = 0xb
	// Bit mask of CC3OF field.
	TIM_INTFR_CC3OF_Msk = 0x800
	// Bit CC3OF.
	TIM_INTFR_CC3OF = 0x800
	// Position of CC2OF field.
	TIM_INTFR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIM_INTFR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIM_INTFR_CC2OF = 0x400
	// Position of CC1OF field.
	TIM_INTFR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_INTFR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_INTFR_CC1OF = 0x200
	// Position of BIF field.
	TIM_INTFR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIM_INTFR_BIF_Msk = 0x80
	// Bit BIF.
	TIM_INTFR_BIF = 0x80
	// Position of TIF field.
	TIM_INTFR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIM_INTFR_TIF_Msk = 0x40
	// Bit TIF.
	TIM_INTFR_TIF = 0x40
	// Position of COMIF field.
	TIM_INTFR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIM_INTFR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIM_INTFR_COMIF = 0x20
	// Position of CC4IF field.
	TIM_INTFR_CC4IF_Pos = 0x4
	// Bit mask of CC4IF field.
	TIM_INTFR_CC4IF_Msk = 0x10
	// Bit CC4IF.
	TIM_INTFR_CC4IF = 0x10
	// Position of CC3IF field.
	TIM_INTFR_CC3IF_Pos = 0x3
	// Bit mask of CC3IF field.
	TIM_INTFR_CC3IF_Msk = 0x8
	// Bit CC3IF.
	TIM_INTFR_CC3IF = 0x8
	// Position of CC2IF field.
	TIM_INTFR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIM_INTFR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIM_INTFR_CC2IF = 0x4
	// Position of CC1IF field.
	TIM_INTFR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_INTFR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_INTFR_CC1IF = 0x2
	// Position of UIF field.
	TIM_INTFR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_INTFR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_INTFR_UIF = 0x1

	// SWEVGR: event generation register
	// Position of BG field.
	TIM_SWEVGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIM_SWEVGR_BG_Msk = 0x80
	// Bit BG.
	TIM_SWEVGR_BG = 0x80
	// Position of TG field.
	TIM_SWEVGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIM_SWEVGR_TG_Msk = 0x40
	// Bit TG.
	TIM_SWEVGR_TG = 0x40
	// Position of COMG field.
	TIM_SWEVGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIM_SWEVGR_COMG_Msk = 0x20
	// Bit COMG.
	TIM_SWEVGR_COMG = 0x20
	// Position of CC4G field.
	TIM_SWEVGR_CC4G_Pos = 0x4
	// Bit mask of CC4G field.
	TIM_SWEVGR_CC4G_Msk = 0x10
	// Bit CC4G.
	TIM_SWEVGR_CC4G = 0x10
	// Position of CC3G field.
	TIM_SWEVGR_CC3G_Pos = 0x3
	// Bit mask of CC3G field.
	TIM_SWEVGR_CC3G_Msk = 0x8
	// Bit CC3G.
	TIM_SWEVGR_CC3G = 0x8
	// Position of CC2G field.
	TIM_SWEVGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIM_SWEVGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIM_SWEVGR_CC2G = 0x4
	// Position of CC1G field.
	TIM_SWEVGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_SWEVGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_SWEVGR_CC1G = 0x2
	// Position of UG field.
	TIM_SWEVGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_SWEVGR_UG_Msk = 0x1
	// Bit UG.
	TIM_SWEVGR_UG = 0x1

	// CHCTLR1_Output: capture/compare mode register (output mode)
	// Position of OC2CE field.
	TIM_CHCTLR1_Output_OC2CE_Pos = 0xf
	// Bit mask of OC2CE field.
	TIM_CHCTLR1_Output_OC2CE_Msk = 0x8000
	// Bit OC2CE.
	TIM_CHCTLR1_Output_OC2CE = 0x8000
	// Position of OC2M field.
	TIM_CHCTLR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIM_CHCTLR1_Output_OC2M_Msk = 0x7000
	// Position of OC2PE field.
	TIM_CHCTLR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIM_CHCTLR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIM_CHCTLR1_Output_OC2PE = 0x800
	// Position of OC2FE field.
	TIM_CHCTLR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIM_CHCTLR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIM_CHCTLR1_Output_OC2FE = 0x400
	// Position of CC2S field.
	TIM_CHCTLR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CHCTLR1_Output_CC2S_Msk = 0x300
	// Position of OC1CE field.
	TIM_CHCTLR1_Output_OC1CE_Pos = 0x7
	// Bit mask of OC1CE field.
	TIM_CHCTLR1_Output_OC1CE_Msk = 0x80
	// Bit OC1CE.
	TIM_CHCTLR1_Output_OC1CE = 0x80
	// Position of OC1M field.
	TIM_CHCTLR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CHCTLR1_Output_OC1M_Msk = 0x70
	// Position of OC1PE field.
	TIM_CHCTLR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CHCTLR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CHCTLR1_Output_OC1PE = 0x8
	// Position of OC1FE field.
	TIM_CHCTLR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CHCTLR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CHCTLR1_Output_OC1FE = 0x4
	// Position of CC1S field.
	TIM_CHCTLR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CHCTLR1_Output_CC1S_Msk = 0x3

	// CHCTLR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIM_CHCTLR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIM_CHCTLR1_Input_IC2F_Msk = 0xf000
	// Position of IC2PCS field.
	TIM_CHCTLR1_Input_IC2PCS_Pos = 0xa
	// Bit mask of IC2PCS field.
	TIM_CHCTLR1_Input_IC2PCS_Msk = 0xc00
	// Position of CC2S field.
	TIM_CHCTLR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CHCTLR1_Input_CC2S_Msk = 0x300
	// Position of IC1F field.
	TIM_CHCTLR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CHCTLR1_Input_IC1F_Msk = 0xf0
	// Position of IC1PSC field.
	TIM_CHCTLR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CHCTLR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIM_CHCTLR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CHCTLR1_Input_CC1S_Msk = 0x3

	// CHCTLR2_Output: capture/compare mode register (output mode)
	// Position of OC4CE field.
	TIM_CHCTLR2_Output_OC4CE_Pos = 0xf
	// Bit mask of OC4CE field.
	TIM_CHCTLR2_Output_OC4CE_Msk = 0x8000
	// Bit OC4CE.
	TIM_CHCTLR2_Output_OC4CE = 0x8000
	// Position of OC4M field.
	TIM_CHCTLR2_Output_OC4M_Pos = 0xc
	// Bit mask of OC4M field.
	TIM_CHCTLR2_Output_OC4M_Msk = 0x7000
	// Position of OC4PE field.
	TIM_CHCTLR2_Output_OC4PE_Pos = 0xb
	// Bit mask of OC4PE field.
	TIM_CHCTLR2_Output_OC4PE_Msk = 0x800
	// Bit OC4PE.
	TIM_CHCTLR2_Output_OC4PE = 0x800
	// Position of OC4FE field.
	TIM_CHCTLR2_Output_OC4FE_Pos = 0xa
	// Bit mask of OC4FE field.
	TIM_CHCTLR2_Output_OC4FE_Msk = 0x400
	// Bit OC4FE.
	TIM_CHCTLR2_Output_OC4FE = 0x400
	// Position of CC4S field.
	TIM_CHCTLR2_Output_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CHCTLR2_Output_CC4S_Msk = 0x300
	// Position of OC3CE field.
	TIM_CHCTLR2_Output_OC3CE_Pos = 0x7
	// Bit mask of OC3CE field.
	TIM_CHCTLR2_Output_OC3CE_Msk = 0x80
	// Bit OC3CE.
	TIM_CHCTLR2_Output_OC3CE = 0x80
	// Position of OC3M field.
	TIM_CHCTLR2_Output_OC3M_Pos = 0x4
	// Bit mask of OC3M field.
	TIM_CHCTLR2_Output_OC3M_Msk = 0x70
	// Position of OC3PE field.
	TIM_CHCTLR2_Output_OC3PE_Pos = 0x3
	// Bit mask of OC3PE field.
	TIM_CHCTLR2_Output_OC3PE_Msk = 0x8
	// Bit OC3PE.
	TIM_CHCTLR2_Output_OC3PE = 0x8
	// Position of OC3FE field.
	TIM_CHCTLR2_Output_OC3FE_Pos = 0x2
	// Bit mask of OC3FE field.
	TIM_CHCTLR2_Output_OC3FE_Msk = 0x4
	// Bit OC3FE.
	TIM_CHCTLR2_Output_OC3FE = 0x4
	// Position of CC3S field.
	TIM_CHCTLR2_Output_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CHCTLR2_Output_CC3S_Msk = 0x3

	// CHCTLR2_Input: capture/compare mode register 2 (input mode)
	// Position of IC4F field.
	TIM_CHCTLR2_Input_IC4F_Pos = 0xc
	// Bit mask of IC4F field.
	TIM_CHCTLR2_Input_IC4F_Msk = 0xf000
	// Position of IC4PSC field.
	TIM_CHCTLR2_Input_IC4PSC_Pos = 0xa
	// Bit mask of IC4PSC field.
	TIM_CHCTLR2_Input_IC4PSC_Msk = 0xc00
	// Position of CC4S field.
	TIM_CHCTLR2_Input_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CHCTLR2_Input_CC4S_Msk = 0x300
	// Position of IC3F field.
	TIM_CHCTLR2_Input_IC3F_Pos = 0x4
	// Bit mask of IC3F field.
	TIM_CHCTLR2_Input_IC3F_Msk = 0xf0
	// Position of IC3PSC field.
	TIM_CHCTLR2_Input_IC3PSC_Pos = 0x2
	// Bit mask of IC3PSC field.
	TIM_CHCTLR2_Input_IC3PSC_Msk = 0xc
	// Position of CC3S field.
	TIM_CHCTLR2_Input_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CHCTLR2_Input_CC3S_Msk = 0x3

	// CCER: capture/compare enable register
	// Position of CC4P field.
	TIM_CCER_CC4P_Pos = 0xd
	// Bit mask of CC4P field.
	TIM_CCER_CC4P_Msk = 0x2000
	// Bit CC4P.
	TIM_CCER_CC4P = 0x2000
	// Position of CC4E field.
	TIM_CCER_CC4E_Pos = 0xc
	// Bit mask of CC4E field.
	TIM_CCER_CC4E_Msk = 0x1000
	// Bit CC4E.
	TIM_CCER_CC4E = 0x1000
	// Position of CC3NP field.
	TIM_CCER_CC3NP_Pos = 0xb
	// Bit mask of CC3NP field.
	TIM_CCER_CC3NP_Msk = 0x800
	// Bit CC3NP.
	TIM_CCER_CC3NP = 0x800
	// Position of CC3NE field.
	TIM_CCER_CC3NE_Pos = 0xa
	// Bit mask of CC3NE field.
	TIM_CCER_CC3NE_Msk = 0x400
	// Bit CC3NE.
	TIM_CCER_CC3NE = 0x400
	// Position of CC3P field.
	TIM_CCER_CC3P_Pos = 0x9
	// Bit mask of CC3P field.
	TIM_CCER_CC3P_Msk = 0x200
	// Bit CC3P.
	TIM_CCER_CC3P = 0x200
	// Position of CC3E field.
	TIM_CCER_CC3E_Pos = 0x8
	// Bit mask of CC3E field.
	TIM_CCER_CC3E_Msk = 0x100
	// Bit CC3E.
	TIM_CCER_CC3E = 0x100
	// Position of CC2NP field.
	TIM_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIM_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIM_CCER_CC2NP = 0x80
	// Position of CC2NE field.
	TIM_CCER_CC2NE_Pos = 0x6
	// Bit mask of CC2NE field.
	TIM_CCER_CC2NE_Msk = 0x40
	// Bit CC2NE.
	TIM_CCER_CC2NE = 0x40
	// Position of CC2P field.
	TIM_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIM_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIM_CCER_CC2P = 0x20
	// Position of CC2E field.
	TIM_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIM_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIM_CCER_CC2E = 0x10
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// Position of CC1NE field.
	TIM_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIM_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIM_CCER_CC1NE = 0x4
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1

	// CNT: counter
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffff

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ATRLR: auto-reload register
	// Position of ATRLR field.
	TIM_ATRLR_ATRLR_Pos = 0x0
	// Bit mask of ATRLR field.
	TIM_ATRLR_ATRLR_Msk = 0xffff

	// RPTCR: repetition counter register
	// Position of RPTCR field.
	TIM_RPTCR_RPTCR_Pos = 0x0
	// Bit mask of RPTCR field.
	TIM_RPTCR_RPTCR_Msk = 0xff

	// CH1CVR: capture/compare register 1
	// Position of CH1CVR field.
	TIM_CH1CVR_CH1CVR_Pos = 0x0
	// Bit mask of CH1CVR field.
	TIM_CH1CVR_CH1CVR_Msk = 0xffff

	// CH2CVR: capture/compare register 2
	// Position of CH2CVR field.
	TIM_CH2CVR_CH2CVR_Pos = 0x0
	// Bit mask of CH2CVR field.
	TIM_CH2CVR_CH2CVR_Msk = 0xffff

	// CH3CVR: capture/compare register 3
	// Position of CH3CVR field.
	TIM_CH3CVR_CH3CVR_Pos = 0x0
	// Bit mask of CH3CVR field.
	TIM_CH3CVR_CH3CVR_Msk = 0xffff

	// CH4CVR: capture/compare register 4
	// Position of CH4CVR field.
	TIM_CH4CVR_CH4CVR_Pos = 0x0
	// Bit mask of CH4CVR field.
	TIM_CH4CVR_CH4CVR_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of MOE field.
	TIM_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIM_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIM_BDTR_MOE = 0x8000
	// Position of AOE field.
	TIM_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIM_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIM_BDTR_AOE = 0x4000
	// Position of BKP field.
	TIM_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIM_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIM_BDTR_BKP = 0x2000
	// Position of BKE field.
	TIM_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIM_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIM_BDTR_BKE = 0x1000
	// Position of OSSR field.
	TIM_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIM_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIM_BDTR_OSSR = 0x800
	// Position of OSSI field.
	TIM_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIM_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIM_BDTR_OSSI = 0x400
	// Position of LOCK field.
	TIM_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIM_BDTR_LOCK_Msk = 0x300
	// Position of DTG field.
	TIM_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIM_BDTR_DTG_Msk = 0xff

	// DMACFGR: DMA control register
	// Position of DBL field.
	TIM_DMACFGR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DMACFGR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DMACFGR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DMACFGR_DBA_Msk = 0x1f

	// DMAADR: DMA address for full transfer
	// Position of DMAADR field.
	TIM_DMAADR_DMAADR_Pos = 0x0
	// Bit mask of DMAADR field.
	TIM_DMAADR_DMAADR_Msk = 0xffff
)

// Constants for I2C1: Inter integrated circuit
const (
	// CTLR1: Control register 1
	// Position of SWRST field.
	I2C_CTLR1_SWRST_Pos = 0xf
	// Bit mask of SWRST field.
	I2C_CTLR1_SWRST_Msk = 0x8000
	// Bit SWRST.
	I2C_CTLR1_SWRST = 0x8000
	// Position of PEC field.
	I2C_CTLR1_PEC_Pos = 0xc
	// Bit mask of PEC field.
	I2C_CTLR1_PEC_Msk = 0x1000
	// Bit PEC.
	I2C_CTLR1_PEC = 0x1000
	// Position of POS field.
	I2C_CTLR1_POS_Pos = 0xb
	// Bit mask of POS field.
	I2C_CTLR1_POS_Msk = 0x800
	// Bit POS.
	I2C_CTLR1_POS = 0x800
	// Position of ACK field.
	I2C_CTLR1_ACK_Pos = 0xa
	// Bit mask of ACK field.
	I2C_CTLR1_ACK_Msk = 0x400
	// Bit ACK.
	I2C_CTLR1_ACK = 0x400
	// Position of STOP field.
	I2C_CTLR1_STOP_Pos = 0x9
	// Bit mask of STOP field.
	I2C_CTLR1_STOP_Msk = 0x200
	// Bit STOP.
	I2C_CTLR1_STOP = 0x200
	// Position of START field.
	I2C_CTLR1_START_Pos = 0x8
	// Bit mask of START field.
	I2C_CTLR1_START_Msk = 0x100
	// Bit START.
	I2C_CTLR1_START = 0x100
	// Position of NOSTRETCH field.
	I2C_CTLR1_NOSTRETCH_Pos = 0x7
	// Bit mask of NOSTRETCH field.
	I2C_CTLR1_NOSTRETCH_Msk = 0x80
	// Bit NOSTRETCH.
	I2C_CTLR1_NOSTRETCH = 0x80
	// Position of ENGC field.
	I2C_CTLR1_ENGC_Pos = 0x6
	// Bit mask of ENGC field.
	I2C_CTLR1_ENGC_Msk = 0x40
	// Bit ENGC.
	I2C_CTLR1_ENGC = 0x40
	// Position of ENPEC field.
	I2C_CTLR1_ENPEC_Pos = 0x5
	// Bit mask of ENPEC field.
	I2C_CTLR1_ENPEC_Msk = 0x20
	// Bit ENPEC.
	I2C_CTLR1_ENPEC = 0x20
	// Position of ENARP field.
	I2C_CTLR1_ENARP_Pos = 0x4
	// Bit mask of ENARP field.
	I2C_CTLR1_ENARP_Msk = 0x10
	// Bit ENARP.
	I2C_CTLR1_ENARP = 0x10
	// Position of PE field.
	I2C_CTLR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CTLR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CTLR1_PE = 0x1

	// CTLR2: Control register 2
	// Position of LAST field.
	I2C_CTLR2_LAST_Pos = 0xc
	// Bit mask of LAST field.
	I2C_CTLR2_LAST_Msk = 0x1000
	// Bit LAST.
	I2C_CTLR2_LAST = 0x1000
	// Position of DMAEN field.
	I2C_CTLR2_DMAEN_Pos = 0xb
	// Bit mask of DMAEN field.
	I2C_CTLR2_DMAEN_Msk = 0x800
	// Bit DMAEN.
	I2C_CTLR2_DMAEN = 0x800
	// Position of ITBUFEN field.
	I2C_CTLR2_ITBUFEN_Pos = 0xa
	// Bit mask of ITBUFEN field.
	I2C_CTLR2_ITBUFEN_Msk = 0x400
	// Bit ITBUFEN.
	I2C_CTLR2_ITBUFEN = 0x400
	// Position of ITEVTEN field.
	I2C_CTLR2_ITEVTEN_Pos = 0x9
	// Bit mask of ITEVTEN field.
	I2C_CTLR2_ITEVTEN_Msk = 0x200
	// Bit ITEVTEN.
	I2C_CTLR2_ITEVTEN = 0x200
	// Position of ITERREN field.
	I2C_CTLR2_ITERREN_Pos = 0x8
	// Bit mask of ITERREN field.
	I2C_CTLR2_ITERREN_Msk = 0x100
	// Bit ITERREN.
	I2C_CTLR2_ITERREN = 0x100
	// Position of FREQ field.
	I2C_CTLR2_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	I2C_CTLR2_FREQ_Msk = 0x3f

	// OADDR1: Own address register 1
	// Position of ADDMODE field.
	I2C_OADDR1_ADDMODE_Pos = 0xf
	// Bit mask of ADDMODE field.
	I2C_OADDR1_ADDMODE_Msk = 0x8000
	// Bit ADDMODE.
	I2C_OADDR1_ADDMODE = 0x8000
	// Position of ADD9_8 field.
	I2C_OADDR1_ADD9_8_Pos = 0x8
	// Bit mask of ADD9_8 field.
	I2C_OADDR1_ADD9_8_Msk = 0x300
	// Position of ADD7_1 field.
	I2C_OADDR1_ADD7_1_Pos = 0x1
	// Bit mask of ADD7_1 field.
	I2C_OADDR1_ADD7_1_Msk = 0xfe
	// Position of ADD0 field.
	I2C_OADDR1_ADD0_Pos = 0x0
	// Bit mask of ADD0 field.
	I2C_OADDR1_ADD0_Msk = 0x1
	// Bit ADD0.
	I2C_OADDR1_ADD0 = 0x1

	// OADDR2: Own address register 2
	// Position of ADD2 field.
	I2C_OADDR2_ADD2_Pos = 0x1
	// Bit mask of ADD2 field.
	I2C_OADDR2_ADD2_Msk = 0xfe
	// Position of ENDUAL field.
	I2C_OADDR2_ENDUAL_Pos = 0x0
	// Bit mask of ENDUAL field.
	I2C_OADDR2_ENDUAL_Msk = 0x1
	// Bit ENDUAL.
	I2C_OADDR2_ENDUAL = 0x1

	// DATAR: Data register
	// Position of DATAR field.
	I2C_DATAR_DATAR_Pos = 0x0
	// Bit mask of DATAR field.
	I2C_DATAR_DATAR_Msk = 0xff

	// STAR1: Status register 1
	// Position of PECERR field.
	I2C_STAR1_PECERR_Pos = 0xc
	// Bit mask of PECERR field.
	I2C_STAR1_PECERR_Msk = 0x1000
	// Bit PECERR.
	I2C_STAR1_PECERR = 0x1000
	// Position of OVR field.
	I2C_STAR1_OVR_Pos = 0xb
	// Bit mask of OVR field.
	I2C_STAR1_OVR_Msk = 0x800
	// Bit OVR.
	I2C_STAR1_OVR = 0x800
	// Position of AF field.
	I2C_STAR1_AF_Pos = 0xa
	// Bit mask of AF field.
	I2C_STAR1_AF_Msk = 0x400
	// Bit AF.
	I2C_STAR1_AF = 0x400
	// Position of ARLO field.
	I2C_STAR1_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_STAR1_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_STAR1_ARLO = 0x200
	// Position of BERR field.
	I2C_STAR1_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_STAR1_BERR_Msk = 0x100
	// Bit BERR.
	I2C_STAR1_BERR = 0x100
	// Position of TxE field.
	I2C_STAR1_TxE_Pos = 0x7
	// Bit mask of TxE field.
	I2C_STAR1_TxE_Msk = 0x80
	// Bit TxE.
	I2C_STAR1_TxE = 0x80
	// Position of RxNE field.
	I2C_STAR1_RxNE_Pos = 0x6
	// Bit mask of RxNE field.
	I2C_STAR1_RxNE_Msk = 0x40
	// Bit RxNE.
	I2C_STAR1_RxNE = 0x40
	// Position of STOPF field.
	I2C_STAR1_STOPF_Pos = 0x4
	// Bit mask of STOPF field.
	I2C_STAR1_STOPF_Msk = 0x10
	// Bit STOPF.
	I2C_STAR1_STOPF = 0x10
	// Position of ADD10 field.
	I2C_STAR1_ADD10_Pos = 0x3
	// Bit mask of ADD10 field.
	I2C_STAR1_ADD10_Msk = 0x8
	// Bit ADD10.
	I2C_STAR1_ADD10 = 0x8
	// Position of BTF field.
	I2C_STAR1_BTF_Pos = 0x2
	// Bit mask of BTF field.
	I2C_STAR1_BTF_Msk = 0x4
	// Bit BTF.
	I2C_STAR1_BTF = 0x4
	// Position of ADDR field.
	I2C_STAR1_ADDR_Pos = 0x1
	// Bit mask of ADDR field.
	I2C_STAR1_ADDR_Msk = 0x2
	// Bit ADDR.
	I2C_STAR1_ADDR = 0x2
	// Position of SB field.
	I2C_STAR1_SB_Pos = 0x0
	// Bit mask of SB field.
	I2C_STAR1_SB_Msk = 0x1
	// Bit SB.
	I2C_STAR1_SB = 0x1

	// STAR2: Status register 2
	// Position of PEC field.
	I2C_STAR2_PEC_Pos = 0x8
	// Bit mask of PEC field.
	I2C_STAR2_PEC_Msk = 0xff00
	// Position of DUALF field.
	I2C_STAR2_DUALF_Pos = 0x7
	// Bit mask of DUALF field.
	I2C_STAR2_DUALF_Msk = 0x80
	// Bit DUALF.
	I2C_STAR2_DUALF = 0x80
	// Position of GENCALL field.
	I2C_STAR2_GENCALL_Pos = 0x4
	// Bit mask of GENCALL field.
	I2C_STAR2_GENCALL_Msk = 0x10
	// Bit GENCALL.
	I2C_STAR2_GENCALL = 0x10
	// Position of TRA field.
	I2C_STAR2_TRA_Pos = 0x2
	// Bit mask of TRA field.
	I2C_STAR2_TRA_Msk = 0x4
	// Bit TRA.
	I2C_STAR2_TRA = 0x4
	// Position of BUSY field.
	I2C_STAR2_BUSY_Pos = 0x1
	// Bit mask of BUSY field.
	I2C_STAR2_BUSY_Msk = 0x2
	// Bit BUSY.
	I2C_STAR2_BUSY = 0x2
	// Position of MSL field.
	I2C_STAR2_MSL_Pos = 0x0
	// Bit mask of MSL field.
	I2C_STAR2_MSL_Msk = 0x1
	// Bit MSL.
	I2C_STAR2_MSL = 0x1

	// CKCFGR: Clock control register
	// Position of F_S field.
	I2C_CKCFGR_F_S_Pos = 0xf
	// Bit mask of F_S field.
	I2C_CKCFGR_F_S_Msk = 0x8000
	// Bit F_S.
	I2C_CKCFGR_F_S = 0x8000
	// Position of DUTY field.
	I2C_CKCFGR_DUTY_Pos = 0xe
	// Bit mask of DUTY field.
	I2C_CKCFGR_DUTY_Msk = 0x4000
	// Bit DUTY.
	I2C_CKCFGR_DUTY = 0x4000
	// Position of CCR field.
	I2C_CKCFGR_CCR_Pos = 0x0
	// Bit mask of CCR field.
	I2C_CKCFGR_CCR_Msk = 0xfff
)

// Constants for SPI1: Serial peripheral interface
const (
	// CTLR1: control register 1
	// Position of BIDIMODE field.
	SPI_CTLR1_BIDIMODE_Pos = 0xf
	// Bit mask of BIDIMODE field.
	SPI_CTLR1_BIDIMODE_Msk = 0x8000
	// Bit BIDIMODE.
	SPI_CTLR1_BIDIMODE = 0x8000
	// Position of BIDIOE field.
	SPI_CTLR1_BIDIOE_Pos = 0xe
	// Bit mask of BIDIOE field.
	SPI_CTLR1_BIDIOE_Msk = 0x4000
	// Bit BIDIOE.
	SPI_CTLR1_BIDIOE = 0x4000
	// Position of CRCEN field.
	SPI_CTLR1_CRCEN_Pos = 0xd
	// Bit mask of CRCEN field.
	SPI_CTLR1_CRCEN_Msk = 0x2000
	// Bit CRCEN.
	SPI_CTLR1_CRCEN = 0x2000
	// Position of CRCNEXT field.
	SPI_CTLR1_CRCNEXT_Pos = 0xc
	// Bit mask of CRCNEXT field.
	SPI_CTLR1_CRCNEXT_Msk = 0x1000
	// Bit CRCNEXT.
	SPI_CTLR1_CRCNEXT = 0x1000
	// Position of DFF field.
	SPI_CTLR1_DFF_Pos = 0xb
	// Bit mask of DFF field.
	SPI_CTLR1_DFF_Msk = 0x800
	// Bit DFF.
	SPI_CTLR1_DFF = 0x800
	// Position of RXONLY field.
	SPI_CTLR1_RXONLY_Pos = 0xa
	// Bit mask of RXONLY field.
	SPI_CTLR1_RXONLY_Msk = 0x400
	// Bit RXONLY.
	SPI_CTLR1_RXONLY = 0x400
	// Position of SSM field.
	SPI_CTLR1_SSM_Pos = 0x9
	// Bit mask of SSM field.
	SPI_CTLR1_SSM_Msk = 0x200
	// Bit SSM.
	SPI_CTLR1_SSM = 0x200
	// Position of SSI field.
	SPI_CTLR1_SSI_Pos = 0x8
	// Bit mask of SSI field.
	SPI_CTLR1_SSI_Msk = 0x100
	// Bit SSI.
	SPI_CTLR1_SSI = 0x100
	// Position of LSBFIRST field.
	SPI_CTLR1_LSBFIRST_Pos = 0x7
	// Bit mask of LSBFIRST field.
	SPI_CTLR1_LSBFIRST_Msk = 0x80
	// Bit LSBFIRST.
	SPI_CTLR1_LSBFIRST = 0x80
	// Position of SPE field.
	SPI_CTLR1_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI_CTLR1_SPE_Msk = 0x40
	// Bit SPE.
	SPI_CTLR1_SPE = 0x40
	// Position of BR field.
	SPI_CTLR1_BR_Pos = 0x3
	// Bit mask of BR field.
	SPI_CTLR1_BR_Msk = 0x38
	// Position of MSTR field.
	SPI_CTLR1_MSTR_Pos = 0x2
	// Bit mask of MSTR field.
	SPI_CTLR1_MSTR_Msk = 0x4
	// Bit MSTR.
	SPI_CTLR1_MSTR = 0x4
	// Position of CPOL field.
	SPI_CTLR1_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI_CTLR1_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI_CTLR1_CPOL = 0x2
	// Position of CPHA field.
	SPI_CTLR1_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI_CTLR1_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI_CTLR1_CPHA = 0x1

	// CTLR2: control register 2
	// Position of TXEIE field.
	SPI_CTLR2_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	SPI_CTLR2_TXEIE_Msk = 0x80
	// Bit TXEIE.
	SPI_CTLR2_TXEIE = 0x80
	// Position of RXNEIE field.
	SPI_CTLR2_RXNEIE_Pos = 0x6
	// Bit mask of RXNEIE field.
	SPI_CTLR2_RXNEIE_Msk = 0x40
	// Bit RXNEIE.
	SPI_CTLR2_RXNEIE = 0x40
	// Position of ERRIE field.
	SPI_CTLR2_ERRIE_Pos = 0x5
	// Bit mask of ERRIE field.
	SPI_CTLR2_ERRIE_Msk = 0x20
	// Bit ERRIE.
	SPI_CTLR2_ERRIE = 0x20
	// Position of SSOE field.
	SPI_CTLR2_SSOE_Pos = 0x2
	// Bit mask of SSOE field.
	SPI_CTLR2_SSOE_Msk = 0x4
	// Bit SSOE.
	SPI_CTLR2_SSOE = 0x4
	// Position of TXDMAEN field.
	SPI_CTLR2_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	SPI_CTLR2_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	SPI_CTLR2_TXDMAEN = 0x2
	// Position of RXDMAEN field.
	SPI_CTLR2_RXDMAEN_Pos = 0x0
	// Bit mask of RXDMAEN field.
	SPI_CTLR2_RXDMAEN_Msk = 0x1
	// Bit RXDMAEN.
	SPI_CTLR2_RXDMAEN = 0x1

	// STATR: status register
	// Position of BSY field.
	SPI_STATR_BSY_Pos = 0x7
	// Bit mask of BSY field.
	SPI_STATR_BSY_Msk = 0x80
	// Bit BSY.
	SPI_STATR_BSY = 0x80
	// Position of OVR field.
	SPI_STATR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_STATR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_STATR_OVR = 0x40
	// Position of MODF field.
	SPI_STATR_MODF_Pos = 0x5
	// Bit mask of MODF field.
	SPI_STATR_MODF_Msk = 0x20
	// Bit MODF.
	SPI_STATR_MODF = 0x20
	// Position of CRCERR field.
	SPI_STATR_CRCERR_Pos = 0x4
	// Bit mask of CRCERR field.
	SPI_STATR_CRCERR_Msk = 0x10
	// Bit CRCERR.
	SPI_STATR_CRCERR = 0x10
	// Position of CHSID field.
	SPI_STATR_CHSID_Pos = 0x2
	// Bit mask of CHSID field.
	SPI_STATR_CHSID_Msk = 0x4
	// Bit CHSID.
	SPI_STATR_CHSID = 0x4
	// Position of UDR field.
	SPI_STATR_UDR_Pos = 0x3
	// Bit mask of UDR field.
	SPI_STATR_UDR_Msk = 0x8
	// Bit UDR.
	SPI_STATR_UDR = 0x8
	// Position of TXE field.
	SPI_STATR_TXE_Pos = 0x1
	// Bit mask of TXE field.
	SPI_STATR_TXE_Msk = 0x2
	// Bit TXE.
	SPI_STATR_TXE = 0x2
	// Position of RXNE field.
	SPI_STATR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPI_STATR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPI_STATR_RXNE = 0x1

	// DATAR: data register
	// Position of DATAR field.
	SPI_DATAR_DATAR_Pos = 0x0
	// Bit mask of DATAR field.
	SPI_DATAR_DATAR_Msk = 0xffff

	// CRCR: CRCR polynomial register
	// Position of CRCPOLY field.
	SPI_CRCR_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCR_CRCPOLY_Msk = 0xffff

	// RCRCR: RX CRC register
	// Position of RXCRC field.
	SPI_RCRCR_RXCRC_Pos = 0x0
	// Bit mask of RXCRC field.
	SPI_RCRCR_RXCRC_Msk = 0xffff

	// TCRCR: send CRC register
	// Position of TXCRC field.
	SPI_TCRCR_TXCRC_Pos = 0x0
	// Bit mask of TXCRC field.
	SPI_TCRCR_TXCRC_Msk = 0xffff

	// HSCR: high speed control register
	// Position of HSRXEN field.
	SPI_HSCR_HSRXEN_Pos = 0x0
	// Bit mask of HSRXEN field.
	SPI_HSCR_HSRXEN_Msk = 0x1
	// Bit HSRXEN.
	SPI_HSCR_HSRXEN = 0x1
)

// Constants for USART1: Universal synchronous asynchronous receiver transmitter
const (
	// STATR: Status register
	// Position of CTS field.
	USART_STATR_CTS_Pos = 0x9
	// Bit mask of CTS field.
	USART_STATR_CTS_Msk = 0x200
	// Bit CTS.
	USART_STATR_CTS = 0x200
	// Position of LBD field.
	USART_STATR_LBD_Pos = 0x8
	// Bit mask of LBD field.
	USART_STATR_LBD_Msk = 0x100
	// Bit LBD.
	USART_STATR_LBD = 0x100
	// Position of TXE field.
	USART_STATR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	USART_STATR_TXE_Msk = 0x80
	// Bit TXE.
	USART_STATR_TXE = 0x80
	// Position of TC field.
	USART_STATR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_STATR_TC_Msk = 0x40
	// Bit TC.
	USART_STATR_TC = 0x40
	// Position of RXNE field.
	USART_STATR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	USART_STATR_RXNE_Msk = 0x20
	// Bit RXNE.
	USART_STATR_RXNE = 0x20
	// Position of IDLE field.
	USART_STATR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_STATR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_STATR_IDLE = 0x10
	// Position of ORE field.
	USART_STATR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_STATR_ORE_Msk = 0x8
	// Bit ORE.
	USART_STATR_ORE = 0x8
	// Position of NE field.
	USART_STATR_NE_Pos = 0x2
	// Bit mask of NE field.
	USART_STATR_NE_Msk = 0x4
	// Bit NE.
	USART_STATR_NE = 0x4
	// Position of FE field.
	USART_STATR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_STATR_FE_Msk = 0x2
	// Bit FE.
	USART_STATR_FE = 0x2
	// Position of PE field.
	USART_STATR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_STATR_PE_Msk = 0x1
	// Bit PE.
	USART_STATR_PE = 0x1

	// DATAR: Data register
	// Position of DR field.
	USART_DATAR_DR_Pos = 0x0
	// Bit mask of DR field.
	USART_DATAR_DR_Msk = 0x1ff

	// BRR: Baud rate register
	// Position of DIV_Mantissa field.
	USART_BRR_DIV_Mantissa_Pos = 0x4
	// Bit mask of DIV_Mantissa field.
	USART_BRR_DIV_Mantissa_Msk = 0xfff0
	// Position of DIV_Fraction field.
	USART_BRR_DIV_Fraction_Pos = 0x0
	// Bit mask of DIV_Fraction field.
	USART_BRR_DIV_Fraction_Msk = 0xf

	// CTLR1: Control register 1
	// Position of UE field.
	USART_CTLR1_UE_Pos = 0xd
	// Bit mask of UE field.
	USART_CTLR1_UE_Msk = 0x2000
	// Bit UE.
	USART_CTLR1_UE = 0x2000
	// Position of M field.
	USART_CTLR1_M_Pos = 0xc
	// Bit mask of M field.
	USART_CTLR1_M_Msk = 0x1000
	// Bit M.
	USART_CTLR1_M = 0x1000
	// Position of WAKE field.
	USART_CTLR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CTLR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CTLR1_WAKE = 0x800
	// Position of PCE field.
	USART_CTLR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CTLR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CTLR1_PCE = 0x400
	// Position of PS field.
	USART_CTLR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CTLR1_PS_Msk = 0x200
	// Bit PS.
	USART_CTLR1_PS = 0x200
	// Position of PEIE field.
	USART_CTLR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CTLR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CTLR1_PEIE = 0x100
	// Position of TXEIE field.
	USART_CTLR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CTLR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CTLR1_TXEIE = 0x80
	// Position of TCIE field.
	USART_CTLR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CTLR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CTLR1_TCIE = 0x40
	// Position of RXNEIE field.
	USART_CTLR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CTLR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CTLR1_RXNEIE = 0x20
	// Position of IDLEIE field.
	USART_CTLR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CTLR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CTLR1_IDLEIE = 0x10
	// Position of TE field.
	USART_CTLR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CTLR1_TE_Msk = 0x8
	// Bit TE.
	USART_CTLR1_TE = 0x8
	// Position of RE field.
	USART_CTLR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CTLR1_RE_Msk = 0x4
	// Bit RE.
	USART_CTLR1_RE = 0x4
	// Position of RWU field.
	USART_CTLR1_RWU_Pos = 0x1
	// Bit mask of RWU field.
	USART_CTLR1_RWU_Msk = 0x2
	// Bit RWU.
	USART_CTLR1_RWU = 0x2
	// Position of SBK field.
	USART_CTLR1_SBK_Pos = 0x0
	// Bit mask of SBK field.
	USART_CTLR1_SBK_Msk = 0x1
	// Bit SBK.
	USART_CTLR1_SBK = 0x1

	// CTLR2: Control register 2
	// Position of LINEN field.
	USART_CTLR2_LINEN_Pos = 0xe
	// Bit mask of LINEN field.
	USART_CTLR2_LINEN_Msk = 0x4000
	// Bit LINEN.
	USART_CTLR2_LINEN = 0x4000
	// Position of STOP field.
	USART_CTLR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CTLR2_STOP_Msk = 0x3000
	// Position of CLKEN field.
	USART_CTLR2_CLKEN_Pos = 0xb
	// Bit mask of CLKEN field.
	USART_CTLR2_CLKEN_Msk = 0x800
	// Bit CLKEN.
	USART_CTLR2_CLKEN = 0x800
	// Position of CPOL field.
	USART_CTLR2_CPOL_Pos = 0xa
	// Bit mask of CPOL field.
	USART_CTLR2_CPOL_Msk = 0x400
	// Bit CPOL.
	USART_CTLR2_CPOL = 0x400
	// Position of CPHA field.
	USART_CTLR2_CPHA_Pos = 0x9
	// Bit mask of CPHA field.
	USART_CTLR2_CPHA_Msk = 0x200
	// Bit CPHA.
	USART_CTLR2_CPHA = 0x200
	// Position of LBCL field.
	USART_CTLR2_LBCL_Pos = 0x8
	// Bit mask of LBCL field.
	USART_CTLR2_LBCL_Msk = 0x100
	// Bit LBCL.
	USART_CTLR2_LBCL = 0x100
	// Position of LBDIE field.
	USART_CTLR2_LBDIE_Pos = 0x6
	// Bit mask of LBDIE field.
	USART_CTLR2_LBDIE_Msk = 0x40
	// Bit LBDIE.
	USART_CTLR2_LBDIE = 0x40
	// Position of LBDL field.
	USART_CTLR2_LBDL_Pos = 0x5
	// Bit mask of LBDL field.
	USART_CTLR2_LBDL_Msk = 0x20
	// Bit LBDL.
	USART_CTLR2_LBDL = 0x20
	// Position of ADD field.
	USART_CTLR2_ADD_Pos = 0x0
	// Bit mask of ADD field.
	USART_CTLR2_ADD_Msk = 0xf

	// CTLR3: Control register 3
	// Position of CTSIE field.
	USART_CTLR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CTLR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CTLR3_CTSIE = 0x400
	// Position of CTSE field.
	USART_CTLR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CTLR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CTLR3_CTSE = 0x200
	// Position of RTSE field.
	USART_CTLR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CTLR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CTLR3_RTSE = 0x100
	// Position of DMAT field.
	USART_CTLR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CTLR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CTLR3_DMAT = 0x80
	// Position of DMAR field.
	USART_CTLR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CTLR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CTLR3_DMAR = 0x40
	// Position of SCEN field.
	USART_CTLR3_SCEN_Pos = 0x5
	// Bit mask of SCEN field.
	USART_CTLR3_SCEN_Msk = 0x20
	// Bit SCEN.
	USART_CTLR3_SCEN = 0x20
	// Position of NACK field.
	USART_CTLR3_NACK_Pos = 0x4
	// Bit mask of NACK field.
	USART_CTLR3_NACK_Msk = 0x10
	// Bit NACK.
	USART_CTLR3_NACK = 0x10
	// Position of HDSEL field.
	USART_CTLR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CTLR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CTLR3_HDSEL = 0x8
	// Position of IRLP field.
	USART_CTLR3_IRLP_Pos = 0x2
	// Bit mask of IRLP field.
	USART_CTLR3_IRLP_Msk = 0x4
	// Bit IRLP.
	USART_CTLR3_IRLP = 0x4
	// Position of IREN field.
	USART_CTLR3_IREN_Pos = 0x1
	// Bit mask of IREN field.
	USART_CTLR3_IREN_Msk = 0x2
	// Bit IREN.
	USART_CTLR3_IREN = 0x2
	// Position of EIE field.
	USART_CTLR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CTLR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CTLR3_EIE = 0x1

	// GPR: Guard time and prescaler register
	// Position of GT field.
	USART_GPR_GT_Pos = 0x8
	// Bit mask of GT field.
	USART_GPR_GT_Msk = 0xff00
	// Position of PSC field.
	USART_GPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	USART_GPR_PSC_Msk = 0xff
)

// Constants for ADC1: Analog to digital converter
const (
	// STATR: status register
	// Position of STRT field.
	ADC1_STATR_STRT_Pos = 0x4
	// Bit mask of STRT field.
	ADC1_STATR_STRT_Msk = 0x10
	// Bit STRT.
	ADC1_STATR_STRT = 0x10
	// Position of JSTRT field.
	ADC1_STATR_JSTRT_Pos = 0x3
	// Bit mask of JSTRT field.
	ADC1_STATR_JSTRT_Msk = 0x8
	// Bit JSTRT.
	ADC1_STATR_JSTRT = 0x8
	// Position of JEOC field.
	ADC1_STATR_JEOC_Pos = 0x2
	// Bit mask of JEOC field.
	ADC1_STATR_JEOC_Msk = 0x4
	// Bit JEOC.
	ADC1_STATR_JEOC = 0x4
	// Position of EOC field.
	ADC1_STATR_EOC_Pos = 0x1
	// Bit mask of EOC field.
	ADC1_STATR_EOC_Msk = 0x2
	// Bit EOC.
	ADC1_STATR_EOC = 0x2
	// Position of AWD field.
	ADC1_STATR_AWD_Pos = 0x0
	// Bit mask of AWD field.
	ADC1_STATR_AWD_Msk = 0x1
	// Bit AWD.
	ADC1_STATR_AWD = 0x1

	// CTLR1: control register 1/TKEY_V_CTLR
	// Position of ADC_CAL_VOL field.
	ADC1_CTLR1_ADC_CAL_VOL_Pos = 0x19
	// Bit mask of ADC_CAL_VOL field.
	ADC1_CTLR1_ADC_CAL_VOL_Msk = 0x6000000
	// Position of AWDEN field.
	ADC1_CTLR1_AWDEN_Pos = 0x17
	// Bit mask of AWDEN field.
	ADC1_CTLR1_AWDEN_Msk = 0x800000
	// Bit AWDEN.
	ADC1_CTLR1_AWDEN = 0x800000
	// Position of JAWDEN field.
	ADC1_CTLR1_JAWDEN_Pos = 0x16
	// Bit mask of JAWDEN field.
	ADC1_CTLR1_JAWDEN_Msk = 0x400000
	// Bit JAWDEN.
	ADC1_CTLR1_JAWDEN = 0x400000
	// Position of DISCNUM field.
	ADC1_CTLR1_DISCNUM_Pos = 0xd
	// Bit mask of DISCNUM field.
	ADC1_CTLR1_DISCNUM_Msk = 0xe000
	// Position of JDISCEN field.
	ADC1_CTLR1_JDISCEN_Pos = 0xc
	// Bit mask of JDISCEN field.
	ADC1_CTLR1_JDISCEN_Msk = 0x1000
	// Bit JDISCEN.
	ADC1_CTLR1_JDISCEN = 0x1000
	// Position of DISCEN field.
	ADC1_CTLR1_DISCEN_Pos = 0xb
	// Bit mask of DISCEN field.
	ADC1_CTLR1_DISCEN_Msk = 0x800
	// Bit DISCEN.
	ADC1_CTLR1_DISCEN = 0x800
	// Position of JAUTO field.
	ADC1_CTLR1_JAUTO_Pos = 0xa
	// Bit mask of JAUTO field.
	ADC1_CTLR1_JAUTO_Msk = 0x400
	// Bit JAUTO.
	ADC1_CTLR1_JAUTO = 0x400
	// Position of AWDSGL field.
	ADC1_CTLR1_AWDSGL_Pos = 0x9
	// Bit mask of AWDSGL field.
	ADC1_CTLR1_AWDSGL_Msk = 0x200
	// Bit AWDSGL.
	ADC1_CTLR1_AWDSGL = 0x200
	// Position of SCAN field.
	ADC1_CTLR1_SCAN_Pos = 0x8
	// Bit mask of SCAN field.
	ADC1_CTLR1_SCAN_Msk = 0x100
	// Bit SCAN.
	ADC1_CTLR1_SCAN = 0x100
	// Position of JEOCIE field.
	ADC1_CTLR1_JEOCIE_Pos = 0x7
	// Bit mask of JEOCIE field.
	ADC1_CTLR1_JEOCIE_Msk = 0x80
	// Bit JEOCIE.
	ADC1_CTLR1_JEOCIE = 0x80
	// Position of AWDIE field.
	ADC1_CTLR1_AWDIE_Pos = 0x6
	// Bit mask of AWDIE field.
	ADC1_CTLR1_AWDIE_Msk = 0x40
	// Bit AWDIE.
	ADC1_CTLR1_AWDIE = 0x40
	// Position of EOCIE field.
	ADC1_CTLR1_EOCIE_Pos = 0x5
	// Bit mask of EOCIE field.
	ADC1_CTLR1_EOCIE_Msk = 0x20
	// Bit EOCIE.
	ADC1_CTLR1_EOCIE = 0x20
	// Position of AWDCH field.
	ADC1_CTLR1_AWDCH_Pos = 0x0
	// Bit mask of AWDCH field.
	ADC1_CTLR1_AWDCH_Msk = 0x1f

	// CTLR2: control register 2
	// Position of SWSTART field.
	ADC1_CTLR2_SWSTART_Pos = 0x16
	// Bit mask of SWSTART field.
	ADC1_CTLR2_SWSTART_Msk = 0x400000
	// Bit SWSTART.
	ADC1_CTLR2_SWSTART = 0x400000
	// Position of JSWSTART field.
	ADC1_CTLR2_JSWSTART_Pos = 0x15
	// Bit mask of JSWSTART field.
	ADC1_CTLR2_JSWSTART_Msk = 0x200000
	// Bit JSWSTART.
	ADC1_CTLR2_JSWSTART = 0x200000
	// Position of EXTTRIG field.
	ADC1_CTLR2_EXTTRIG_Pos = 0x14
	// Bit mask of EXTTRIG field.
	ADC1_CTLR2_EXTTRIG_Msk = 0x100000
	// Bit EXTTRIG.
	ADC1_CTLR2_EXTTRIG = 0x100000
	// Position of EXTSEL field.
	ADC1_CTLR2_EXTSEL_Pos = 0x11
	// Bit mask of EXTSEL field.
	ADC1_CTLR2_EXTSEL_Msk = 0xe0000
	// Position of JEXTTRIG field.
	ADC1_CTLR2_JEXTTRIG_Pos = 0xf
	// Bit mask of JEXTTRIG field.
	ADC1_CTLR2_JEXTTRIG_Msk = 0x8000
	// Bit JEXTTRIG.
	ADC1_CTLR2_JEXTTRIG = 0x8000
	// Position of JEXTSEL field.
	ADC1_CTLR2_JEXTSEL_Pos = 0xc
	// Bit mask of JEXTSEL field.
	ADC1_CTLR2_JEXTSEL_Msk = 0x7000
	// Position of ALIGN field.
	ADC1_CTLR2_ALIGN_Pos = 0xb
	// Bit mask of ALIGN field.
	ADC1_CTLR2_ALIGN_Msk = 0x800
	// Bit ALIGN.
	ADC1_CTLR2_ALIGN = 0x800
	// Position of DMA field.
	ADC1_CTLR2_DMA_Pos = 0x8
	// Bit mask of DMA field.
	ADC1_CTLR2_DMA_Msk = 0x100
	// Bit DMA.
	ADC1_CTLR2_DMA = 0x100
	// Position of RSTCAL field.
	ADC1_CTLR2_RSTCAL_Pos = 0x3
	// Bit mask of RSTCAL field.
	ADC1_CTLR2_RSTCAL_Msk = 0x8
	// Bit RSTCAL.
	ADC1_CTLR2_RSTCAL = 0x8
	// Position of CAL field.
	ADC1_CTLR2_CAL_Pos = 0x2
	// Bit mask of CAL field.
	ADC1_CTLR2_CAL_Msk = 0x4
	// Bit CAL.
	ADC1_CTLR2_CAL = 0x4
	// Position of CONT field.
	ADC1_CTLR2_CONT_Pos = 0x1
	// Bit mask of CONT field.
	ADC1_CTLR2_CONT_Msk = 0x2
	// Bit CONT.
	ADC1_CTLR2_CONT = 0x2
	// Position of ADON field.
	ADC1_CTLR2_ADON_Pos = 0x0
	// Bit mask of ADON field.
	ADC1_CTLR2_ADON_Msk = 0x1
	// Bit ADON.
	ADC1_CTLR2_ADON = 0x1

	// SAMPTR1_CHARGE1: sample time register 1
	// Position of SMP10_TKCG10 field.
	ADC1_SAMPTR1_CHARGE1_SMP10_TKCG10_Pos = 0x0
	// Bit mask of SMP10_TKCG10 field.
	ADC1_SAMPTR1_CHARGE1_SMP10_TKCG10_Msk = 0x7
	// Position of SMP11_TKCG11 field.
	ADC1_SAMPTR1_CHARGE1_SMP11_TKCG11_Pos = 0x3
	// Bit mask of SMP11_TKCG11 field.
	ADC1_SAMPTR1_CHARGE1_SMP11_TKCG11_Msk = 0x38
	// Position of SMP12_TKCG12 field.
	ADC1_SAMPTR1_CHARGE1_SMP12_TKCG12_Pos = 0x6
	// Bit mask of SMP12_TKCG12 field.
	ADC1_SAMPTR1_CHARGE1_SMP12_TKCG12_Msk = 0x1c0
	// Position of SMP13_TKCG13 field.
	ADC1_SAMPTR1_CHARGE1_SMP13_TKCG13_Pos = 0x9
	// Bit mask of SMP13_TKCG13 field.
	ADC1_SAMPTR1_CHARGE1_SMP13_TKCG13_Msk = 0xe00
	// Position of SMP14_TKCG14 field.
	ADC1_SAMPTR1_CHARGE1_SMP14_TKCG14_Pos = 0xc
	// Bit mask of SMP14_TKCG14 field.
	ADC1_SAMPTR1_CHARGE1_SMP14_TKCG14_Msk = 0x7000
	// Position of SMP15_TKCG15 field.
	ADC1_SAMPTR1_CHARGE1_SMP15_TKCG15_Pos = 0xf
	// Bit mask of SMP15_TKCG15 field.
	ADC1_SAMPTR1_CHARGE1_SMP15_TKCG15_Msk = 0x38000

	// SAMPTR2_CHARGE2: sample time register 2
	// Position of SMP0_TKCG0 field.
	ADC1_SAMPTR2_CHARGE2_SMP0_TKCG0_Pos = 0x0
	// Bit mask of SMP0_TKCG0 field.
	ADC1_SAMPTR2_CHARGE2_SMP0_TKCG0_Msk = 0x7
	// Position of SMP1_TKCG1 field.
	ADC1_SAMPTR2_CHARGE2_SMP1_TKCG1_Pos = 0x3
	// Bit mask of SMP1_TKCG1 field.
	ADC1_SAMPTR2_CHARGE2_SMP1_TKCG1_Msk = 0x38
	// Position of SMP2_TKCG2 field.
	ADC1_SAMPTR2_CHARGE2_SMP2_TKCG2_Pos = 0x6
	// Bit mask of SMP2_TKCG2 field.
	ADC1_SAMPTR2_CHARGE2_SMP2_TKCG2_Msk = 0x1c0
	// Position of SMP3_TKCG3 field.
	ADC1_SAMPTR2_CHARGE2_SMP3_TKCG3_Pos = 0x9
	// Bit mask of SMP3_TKCG3 field.
	ADC1_SAMPTR2_CHARGE2_SMP3_TKCG3_Msk = 0xe00
	// Position of SMP4_TKCG4 field.
	ADC1_SAMPTR2_CHARGE2_SMP4_TKCG4_Pos = 0xc
	// Bit mask of SMP4_TKCG4 field.
	ADC1_SAMPTR2_CHARGE2_SMP4_TKCG4_Msk = 0x7000
	// Position of SMP5_TKCG5 field.
	ADC1_SAMPTR2_CHARGE2_SMP5_TKCG5_Pos = 0xf
	// Bit mask of SMP5_TKCG5 field.
	ADC1_SAMPTR2_CHARGE2_SMP5_TKCG5_Msk = 0x38000
	// Position of SMP6_TKCG6 field.
	ADC1_SAMPTR2_CHARGE2_SMP6_TKCG6_Pos = 0x12
	// Bit mask of SMP6_TKCG6 field.
	ADC1_SAMPTR2_CHARGE2_SMP6_TKCG6_Msk = 0x1c0000
	// Position of SMP7_TKCG7 field.
	ADC1_SAMPTR2_CHARGE2_SMP7_TKCG7_Pos = 0x15
	// Bit mask of SMP7_TKCG7 field.
	ADC1_SAMPTR2_CHARGE2_SMP7_TKCG7_Msk = 0xe00000
	// Position of SMP8_TKCG8 field.
	ADC1_SAMPTR2_CHARGE2_SMP8_TKCG8_Pos = 0x18
	// Bit mask of SMP8_TKCG8 field.
	ADC1_SAMPTR2_CHARGE2_SMP8_TKCG8_Msk = 0x7000000
	// Position of SMP9_TKCG9 field.
	ADC1_SAMPTR2_CHARGE2_SMP9_TKCG9_Pos = 0x1b
	// Bit mask of SMP9_TKCG9 field.
	ADC1_SAMPTR2_CHARGE2_SMP9_TKCG9_Msk = 0x38000000

	// IOFR1: injected channel data offset register x
	// Position of JOFFSET1 field.
	ADC1_IOFR1_JOFFSET1_Pos = 0x0
	// Bit mask of JOFFSET1 field.
	ADC1_IOFR1_JOFFSET1_Msk = 0x3ff

	// IOFR2: injected channel data offset register x
	// Position of JOFFSET2 field.
	ADC1_IOFR2_JOFFSET2_Pos = 0x0
	// Bit mask of JOFFSET2 field.
	ADC1_IOFR2_JOFFSET2_Msk = 0x3ff

	// IOFR3: injected channel data offset register x
	// Position of JOFFSET3 field.
	ADC1_IOFR3_JOFFSET3_Pos = 0x0
	// Bit mask of JOFFSET3 field.
	ADC1_IOFR3_JOFFSET3_Msk = 0x3ff

	// IOFR4: injected channel data offset register x
	// Position of JOFFSET4 field.
	ADC1_IOFR4_JOFFSET4_Pos = 0x0
	// Bit mask of JOFFSET4 field.
	ADC1_IOFR4_JOFFSET4_Msk = 0x3ff

	// WDHTR: watchdog higher threshold register
	// Position of HT field.
	ADC1_WDHTR_HT_Pos = 0x0
	// Bit mask of HT field.
	ADC1_WDHTR_HT_Msk = 0x3ff

	// WDLTR: watchdog lower threshold register
	// Position of LT field.
	ADC1_WDLTR_LT_Pos = 0x0
	// Bit mask of LT field.
	ADC1_WDLTR_LT_Msk = 0x3ff

	// RSQR1: regular sequence register 1
	// Position of L field.
	ADC1_RSQR1_L_Pos = 0x14
	// Bit mask of L field.
	ADC1_RSQR1_L_Msk = 0xf00000
	// Position of SQ16 field.
	ADC1_RSQR1_SQ16_Pos = 0xf
	// Bit mask of SQ16 field.
	ADC1_RSQR1_SQ16_Msk = 0xf8000
	// Position of SQ15 field.
	ADC1_RSQR1_SQ15_Pos = 0xa
	// Bit mask of SQ15 field.
	ADC1_RSQR1_SQ15_Msk = 0x7c00
	// Position of SQ14 field.
	ADC1_RSQR1_SQ14_Pos = 0x5
	// Bit mask of SQ14 field.
	ADC1_RSQR1_SQ14_Msk = 0x3e0
	// Position of SQ13 field.
	ADC1_RSQR1_SQ13_Pos = 0x0
	// Bit mask of SQ13 field.
	ADC1_RSQR1_SQ13_Msk = 0x1f

	// RSQR2: regular sequence register 2
	// Position of SQ12 field.
	ADC1_RSQR2_SQ12_Pos = 0x19
	// Bit mask of SQ12 field.
	ADC1_RSQR2_SQ12_Msk = 0x3e000000
	// Position of SQ11 field.
	ADC1_RSQR2_SQ11_Pos = 0x14
	// Bit mask of SQ11 field.
	ADC1_RSQR2_SQ11_Msk = 0x1f00000
	// Position of SQ10 field.
	ADC1_RSQR2_SQ10_Pos = 0xf
	// Bit mask of SQ10 field.
	ADC1_RSQR2_SQ10_Msk = 0xf8000
	// Position of SQ9 field.
	ADC1_RSQR2_SQ9_Pos = 0xa
	// Bit mask of SQ9 field.
	ADC1_RSQR2_SQ9_Msk = 0x7c00
	// Position of SQ8 field.
	ADC1_RSQR2_SQ8_Pos = 0x5
	// Bit mask of SQ8 field.
	ADC1_RSQR2_SQ8_Msk = 0x3e0
	// Position of SQ7 field.
	ADC1_RSQR2_SQ7_Pos = 0x0
	// Bit mask of SQ7 field.
	ADC1_RSQR2_SQ7_Msk = 0x1f

	// RSQR3: regular sequence register 3
	// Position of SQ6 field.
	ADC1_RSQR3_SQ6_Pos = 0x19
	// Bit mask of SQ6 field.
	ADC1_RSQR3_SQ6_Msk = 0x3e000000
	// Position of SQ5 field.
	ADC1_RSQR3_SQ5_Pos = 0x14
	// Bit mask of SQ5 field.
	ADC1_RSQR3_SQ5_Msk = 0x1f00000
	// Position of SQ4 field.
	ADC1_RSQR3_SQ4_Pos = 0xf
	// Bit mask of SQ4 field.
	ADC1_RSQR3_SQ4_Msk = 0xf8000
	// Position of SQ3 field.
	ADC1_RSQR3_SQ3_Pos = 0xa
	// Bit mask of SQ3 field.
	ADC1_RSQR3_SQ3_Msk = 0x7c00
	// Position of SQ2 field.
	ADC1_RSQR3_SQ2_Pos = 0x5
	// Bit mask of SQ2 field.
	ADC1_RSQR3_SQ2_Msk = 0x3e0
	// Position of SQ1 field.
	ADC1_RSQR3_SQ1_Pos = 0x0
	// Bit mask of SQ1 field.
	ADC1_RSQR3_SQ1_Msk = 0x1f

	// ISQR: injected sequence register
	// Position of JL field.
	ADC1_ISQR_JL_Pos = 0x14
	// Bit mask of JL field.
	ADC1_ISQR_JL_Msk = 0x300000
	// Position of JSQ4 field.
	ADC1_ISQR_JSQ4_Pos = 0xf
	// Bit mask of JSQ4 field.
	ADC1_ISQR_JSQ4_Msk = 0xf8000
	// Position of JSQ3 field.
	ADC1_ISQR_JSQ3_Pos = 0xa
	// Bit mask of JSQ3 field.
	ADC1_ISQR_JSQ3_Msk = 0x7c00
	// Position of JSQ2 field.
	ADC1_ISQR_JSQ2_Pos = 0x5
	// Bit mask of JSQ2 field.
	ADC1_ISQR_JSQ2_Msk = 0x3e0
	// Position of JSQ1 field.
	ADC1_ISQR_JSQ1_Pos = 0x0
	// Bit mask of JSQ1 field.
	ADC1_ISQR_JSQ1_Msk = 0x1f

	// IDATAR1: injected data register 1
	// Position of IDATA field.
	ADC1_IDATAR1_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	ADC1_IDATAR1_IDATA_Msk = 0xffff

	// IDATAR2: injected data register 2
	// Position of IDATA field.
	ADC1_IDATAR2_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	ADC1_IDATAR2_IDATA_Msk = 0xffff

	// IDATAR3: injected data register 3
	// Position of IDATA field.
	ADC1_IDATAR3_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	ADC1_IDATAR3_IDATA_Msk = 0xffff

	// IDATAR4: injected data register 4
	// Position of IDATA field.
	ADC1_IDATAR4_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	ADC1_IDATAR4_IDATA_Msk = 0xffff

	// RDATAR: regular data register
	// Position of DATA field.
	ADC1_RDATAR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC1_RDATAR_DATA_Msk = 0xffffffff

	// DLYR: delay data register
	// Position of DLYVLU field.
	ADC1_DLYR_DLYVLU_Pos = 0x0
	// Bit mask of DLYVLU field.
	ADC1_DLYR_DLYVLU_Msk = 0x1ff
	// Position of DLYSRC field.
	ADC1_DLYR_DLYSRC_Pos = 0x9
	// Bit mask of DLYSRC field.
	ADC1_DLYR_DLYSRC_Msk = 0x200
	// Bit DLYSRC.
	ADC1_DLYR_DLYSRC = 0x200
)

// Constants for DBG: Debug support
const (
	// CFGR1: DBGMCU_CFGR1
	// Position of DEG_IWDG field.
	DBG_CFGR1_DEG_IWDG_Pos = 0x0
	// Bit mask of DEG_IWDG field.
	DBG_CFGR1_DEG_IWDG_Msk = 0x1
	// Bit DEG_IWDG.
	DBG_CFGR1_DEG_IWDG = 0x1
	// Position of DEG_WWDG field.
	DBG_CFGR1_DEG_WWDG_Pos = 0x1
	// Bit mask of DEG_WWDG field.
	DBG_CFGR1_DEG_WWDG_Msk = 0x2
	// Bit DEG_WWDG.
	DBG_CFGR1_DEG_WWDG = 0x2
	// Position of DEG_I2C1 field.
	DBG_CFGR1_DEG_I2C1_Pos = 0x2
	// Bit mask of DEG_I2C1 field.
	DBG_CFGR1_DEG_I2C1_Msk = 0x4
	// Bit DEG_I2C1.
	DBG_CFGR1_DEG_I2C1 = 0x4
	// Position of DEG_TIM1 field.
	DBG_CFGR1_DEG_TIM1_Pos = 0x4
	// Bit mask of DEG_TIM1 field.
	DBG_CFGR1_DEG_TIM1_Msk = 0x10
	// Bit DEG_TIM1.
	DBG_CFGR1_DEG_TIM1 = 0x10
	// Position of DEG_TIM2 field.
	DBG_CFGR1_DEG_TIM2_Pos = 0x5
	// Bit mask of DEG_TIM2 field.
	DBG_CFGR1_DEG_TIM2_Msk = 0x20
	// Bit DEG_TIM2.
	DBG_CFGR1_DEG_TIM2 = 0x20

	// CFGR2: DBGMCU_CFGR2
	// Position of DBG_SLEEP field.
	DBG_CFGR2_DBG_SLEEP_Pos = 0x0
	// Bit mask of DBG_SLEEP field.
	DBG_CFGR2_DBG_SLEEP_Msk = 0x1
	// Bit DBG_SLEEP.
	DBG_CFGR2_DBG_SLEEP = 0x1
	// Position of DBG_STOP field.
	DBG_CFGR2_DBG_STOP_Pos = 0x1
	// Bit mask of DBG_STOP field.
	DBG_CFGR2_DBG_STOP_Msk = 0x2
	// Bit DBG_STOP.
	DBG_CFGR2_DBG_STOP = 0x2
	// Position of DBG_STANDBY field.
	DBG_CFGR2_DBG_STANDBY_Pos = 0x2
	// Bit mask of DBG_STANDBY field.
	DBG_CFGR2_DBG_STANDBY_Msk = 0x4
	// Bit DBG_STANDBY.
	DBG_CFGR2_DBG_STANDBY = 0x4
)

// Constants for ESIG: Device electronic signature
const (
	// FLACAP: Flash capacity register
	// Position of FLASHSIZE field.
	ESIG_FLACAP_FLASHSIZE_Pos = 0x0
	// Bit mask of FLASHSIZE field.
	ESIG_FLACAP_FLASHSIZE_Msk = 0xffff

	// UNIID1: Unique identity 1
	// Position of U_ID field.
	ESIG_UNIID1_U_ID_Pos = 0x0
	// Bit mask of U_ID field.
	ESIG_UNIID1_U_ID_Msk = 0xffffffff

	// UNIID2: Unique identity 2
	// Position of U_ID field.
	ESIG_UNIID2_U_ID_Pos = 0x0
	// Bit mask of U_ID field.
	ESIG_UNIID2_U_ID_Msk = 0xffffffff

	// UNIID3: Unique identity 3
	// Position of U_ID field.
	ESIG_UNIID3_U_ID_Pos = 0x0
	// Bit mask of U_ID field.
	ESIG_UNIID3_U_ID_Msk = 0xffffffff
)

// Constants for FLASH: FLASH
const (
	// ACTLR: Flash key register
	// Position of LATENCY field.
	FLASH_ACTLR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	FLASH_ACTLR_LATENCY_Msk = 0x1
	// Bit LATENCY.
	FLASH_ACTLR_LATENCY = 0x1

	// KEYR: Flash key register
	// Position of KEYR field.
	FLASH_KEYR_KEYR_Pos = 0x0
	// Bit mask of KEYR field.
	FLASH_KEYR_KEYR_Msk = 0xffffffff

	// OBKEYR: Flash option key register
	// Position of OPTKEY field.
	FLASH_OBKEYR_OPTKEY_Pos = 0x0
	// Bit mask of OPTKEY field.
	FLASH_OBKEYR_OPTKEY_Msk = 0xffffffff

	// STATR: Status register
	// Position of BOOT_LOCK field.
	FLASH_STATR_BOOT_LOCK_Pos = 0xf
	// Bit mask of BOOT_LOCK field.
	FLASH_STATR_BOOT_LOCK_Msk = 0x8000
	// Bit BOOT_LOCK.
	FLASH_STATR_BOOT_LOCK = 0x8000
	// Position of BOOT_MODE field.
	FLASH_STATR_BOOT_MODE_Pos = 0xe
	// Bit mask of BOOT_MODE field.
	FLASH_STATR_BOOT_MODE_Msk = 0x4000
	// Bit BOOT_MODE.
	FLASH_STATR_BOOT_MODE = 0x4000
	// Position of EOP field.
	FLASH_STATR_EOP_Pos = 0x5
	// Bit mask of EOP field.
	FLASH_STATR_EOP_Msk = 0x20
	// Bit EOP.
	FLASH_STATR_EOP = 0x20
	// Position of WRPRTERR field.
	FLASH_STATR_WRPRTERR_Pos = 0x4
	// Bit mask of WRPRTERR field.
	FLASH_STATR_WRPRTERR_Msk = 0x10
	// Bit WRPRTERR.
	FLASH_STATR_WRPRTERR = 0x10
	// Position of BSY field.
	FLASH_STATR_BSY_Pos = 0x0
	// Bit mask of BSY field.
	FLASH_STATR_BSY_Msk = 0x1
	// Bit BSY.
	FLASH_STATR_BSY = 0x1

	// CTLR: Control register
	// Position of PG field.
	FLASH_CTLR_PG_Pos = 0x0
	// Bit mask of PG field.
	FLASH_CTLR_PG_Msk = 0x1
	// Bit PG.
	FLASH_CTLR_PG = 0x1
	// Position of PER field.
	FLASH_CTLR_PER_Pos = 0x1
	// Bit mask of PER field.
	FLASH_CTLR_PER_Msk = 0x2
	// Bit PER.
	FLASH_CTLR_PER = 0x2
	// Position of MER field.
	FLASH_CTLR_MER_Pos = 0x2
	// Bit mask of MER field.
	FLASH_CTLR_MER_Msk = 0x4
	// Bit MER.
	FLASH_CTLR_MER = 0x4
	// Position of OBPG field.
	FLASH_CTLR_OBPG_Pos = 0x4
	// Bit mask of OBPG field.
	FLASH_CTLR_OBPG_Msk = 0x10
	// Bit OBPG.
	FLASH_CTLR_OBPG = 0x10
	// Position of OBER field.
	FLASH_CTLR_OBER_Pos = 0x5
	// Bit mask of OBER field.
	FLASH_CTLR_OBER_Msk = 0x20
	// Bit OBER.
	FLASH_CTLR_OBER = 0x20
	// Position of STRT field.
	FLASH_CTLR_STRT_Pos = 0x6
	// Bit mask of STRT field.
	FLASH_CTLR_STRT_Msk = 0x40
	// Bit STRT.
	FLASH_CTLR_STRT = 0x40
	// Position of LOCK field.
	FLASH_CTLR_LOCK_Pos = 0x7
	// Bit mask of LOCK field.
	FLASH_CTLR_LOCK_Msk = 0x80
	// Bit LOCK.
	FLASH_CTLR_LOCK = 0x80
	// Position of OBWRE field.
	FLASH_CTLR_OBWRE_Pos = 0x9
	// Bit mask of OBWRE field.
	FLASH_CTLR_OBWRE_Msk = 0x200
	// Bit OBWRE.
	FLASH_CTLR_OBWRE = 0x200
	// Position of ERRIE field.
	FLASH_CTLR_ERRIE_Pos = 0xa
	// Bit mask of ERRIE field.
	FLASH_CTLR_ERRIE_Msk = 0x400
	// Bit ERRIE.
	FLASH_CTLR_ERRIE = 0x400
	// Position of EOPIE field.
	FLASH_CTLR_EOPIE_Pos = 0xc
	// Bit mask of EOPIE field.
	FLASH_CTLR_EOPIE_Msk = 0x1000
	// Bit EOPIE.
	FLASH_CTLR_EOPIE = 0x1000
	// Position of FLOCK field.
	FLASH_CTLR_FLOCK_Pos = 0xf
	// Bit mask of FLOCK field.
	FLASH_CTLR_FLOCK_Msk = 0x8000
	// Bit FLOCK.
	FLASH_CTLR_FLOCK = 0x8000
	// Position of PAGE_PG field.
	FLASH_CTLR_PAGE_PG_Pos = 0x10
	// Bit mask of PAGE_PG field.
	FLASH_CTLR_PAGE_PG_Msk = 0x10000
	// Bit PAGE_PG.
	FLASH_CTLR_PAGE_PG = 0x10000
	// Position of PAGE_ER field.
	FLASH_CTLR_PAGE_ER_Pos = 0x11
	// Bit mask of PAGE_ER field.
	FLASH_CTLR_PAGE_ER_Msk = 0x20000
	// Bit PAGE_ER.
	FLASH_CTLR_PAGE_ER = 0x20000
	// Position of BUFLOAD field.
	FLASH_CTLR_BUFLOAD_Pos = 0x12
	// Bit mask of BUFLOAD field.
	FLASH_CTLR_BUFLOAD_Msk = 0x40000
	// Bit BUFLOAD.
	FLASH_CTLR_BUFLOAD = 0x40000
	// Position of BUFRST field.
	FLASH_CTLR_BUFRST_Pos = 0x13
	// Bit mask of BUFRST field.
	FLASH_CTLR_BUFRST_Msk = 0x80000
	// Bit BUFRST.
	FLASH_CTLR_BUFRST = 0x80000

	// ADDR: Flash address register
	// Position of ADDR field.
	FLASH_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	FLASH_ADDR_ADDR_Msk = 0xffffffff

	// OBR: Option byte register
	// Position of OBERR field.
	FLASH_OBR_OBERR_Pos = 0x0
	// Bit mask of OBERR field.
	FLASH_OBR_OBERR_Msk = 0x1
	// Bit OBERR.
	FLASH_OBR_OBERR = 0x1
	// Position of RDPRT field.
	FLASH_OBR_RDPRT_Pos = 0x1
	// Bit mask of RDPRT field.
	FLASH_OBR_RDPRT_Msk = 0x2
	// Bit RDPRT.
	FLASH_OBR_RDPRT = 0x2
	// Position of IWDG_SW field.
	FLASH_OBR_IWDG_SW_Pos = 0x2
	// Bit mask of IWDG_SW field.
	FLASH_OBR_IWDG_SW_Msk = 0x4
	// Bit IWDG_SW.
	FLASH_OBR_IWDG_SW = 0x4
	// Position of STOP_RST field.
	FLASH_OBR_STOP_RST_Pos = 0x3
	// Bit mask of STOP_RST field.
	FLASH_OBR_STOP_RST_Msk = 0x8
	// Bit STOP_RST.
	FLASH_OBR_STOP_RST = 0x8
	// Position of STANDY_RST field.
	FLASH_OBR_STANDY_RST_Pos = 0x4
	// Bit mask of STANDY_RST field.
	FLASH_OBR_STANDY_RST_Msk = 0x10
	// Bit STANDY_RST.
	FLASH_OBR_STANDY_RST = 0x10
	// Position of CFG_RST_MODE field.
	FLASH_OBR_CFG_RST_MODE_Pos = 0x5
	// Bit mask of CFG_RST_MODE field.
	FLASH_OBR_CFG_RST_MODE_Msk = 0x60
	// Position of DATA0 field.
	FLASH_OBR_DATA0_Pos = 0xa
	// Bit mask of DATA0 field.
	FLASH_OBR_DATA0_Msk = 0x3fc00
	// Position of DATA1 field.
	FLASH_OBR_DATA1_Pos = 0x12
	// Bit mask of DATA1 field.
	FLASH_OBR_DATA1_Msk = 0x3fc0000

	// WPR: Write protection register
	// Position of WRP field.
	FLASH_WPR_WRP_Pos = 0x0
	// Bit mask of WRP field.
	FLASH_WPR_WRP_Msk = 0xffffffff

	// MODEKEYR: Mode select register
	// Position of MODEKEYR field.
	FLASH_MODEKEYR_MODEKEYR_Pos = 0x0
	// Bit mask of MODEKEYR field.
	FLASH_MODEKEYR_MODEKEYR_Msk = 0xffffffff

	// BOOT_MODEKEYP: Boot mode key register
	// Position of MODEKEYR field.
	FLASH_BOOT_MODEKEYP_MODEKEYR_Pos = 0x0
	// Bit mask of MODEKEYR field.
	FLASH_BOOT_MODEKEYP_MODEKEYR_Msk = 0xffffffff
)

// Constants for PFIC: Programmable Fast Interrupt Controller
const (
	// ISR1: Interrupt Status Register
	// Position of INTENSTA2_3 field.
	PFIC_ISR1_INTENSTA2_3_Pos = 0x2
	// Bit mask of INTENSTA2_3 field.
	PFIC_ISR1_INTENSTA2_3_Msk = 0xc
	// Position of INTENSTA12_31 field.
	PFIC_ISR1_INTENSTA12_31_Pos = 0xc
	// Bit mask of INTENSTA12_31 field.
	PFIC_ISR1_INTENSTA12_31_Msk = 0xfffff000

	// ISR2: Interrupt Status Register
	// Position of INTENSTA field.
	PFIC_ISR2_INTENSTA_Pos = 0x0
	// Bit mask of INTENSTA field.
	PFIC_ISR2_INTENSTA_Msk = 0xffffffff

	// ISR3: Interrupt Status Register
	// Position of INTENSTA field.
	PFIC_ISR3_INTENSTA_Pos = 0x0
	// Bit mask of INTENSTA field.
	PFIC_ISR3_INTENSTA_Msk = 0xffffffff

	// ISR4: Interrupt Status Register
	// Position of INTENSTA field.
	PFIC_ISR4_INTENSTA_Pos = 0x0
	// Bit mask of INTENSTA field.
	PFIC_ISR4_INTENSTA_Msk = 0xff

	// IPR1: Interrupt Pending Register
	// Position of PENDSTA2_3 field.
	PFIC_IPR1_PENDSTA2_3_Pos = 0x2
	// Bit mask of PENDSTA2_3 field.
	PFIC_IPR1_PENDSTA2_3_Msk = 0xc
	// Position of PENDSTA12_31 field.
	PFIC_IPR1_PENDSTA12_31_Pos = 0xc
	// Bit mask of PENDSTA12_31 field.
	PFIC_IPR1_PENDSTA12_31_Msk = 0xfffff000

	// IPR2: Interrupt Pending Register
	// Position of PENDSTA field.
	PFIC_IPR2_PENDSTA_Pos = 0x0
	// Bit mask of PENDSTA field.
	PFIC_IPR2_PENDSTA_Msk = 0xffffffff

	// IPR3: Interrupt Pending Register
	// Position of PENDSTA field.
	PFIC_IPR3_PENDSTA_Pos = 0x0
	// Bit mask of PENDSTA field.
	PFIC_IPR3_PENDSTA_Msk = 0xffffffff

	// IPR4: Interrupt Pending Register
	// Position of PENDSTA field.
	PFIC_IPR4_PENDSTA_Pos = 0x0
	// Bit mask of PENDSTA field.
	PFIC_IPR4_PENDSTA_Msk = 0xff

	// ITHRESDR: Interrupt Priority Register
	// Position of THRESHOLD field.
	PFIC_ITHRESDR_THRESHOLD_Pos = 0x0
	// Bit mask of THRESHOLD field.
	PFIC_ITHRESDR_THRESHOLD_Msk = 0xff

	// CFGR: Interrupt Config Register
	// Position of RESETSYS field.
	PFIC_CFGR_RESETSYS_Pos = 0x7
	// Bit mask of RESETSYS field.
	PFIC_CFGR_RESETSYS_Msk = 0x80
	// Bit RESETSYS.
	PFIC_CFGR_RESETSYS = 0x80
	// Position of KEYCODE field.
	PFIC_CFGR_KEYCODE_Pos = 0x10
	// Bit mask of KEYCODE field.
	PFIC_CFGR_KEYCODE_Msk = 0xffff0000

	// GISR: Interrupt Global Register
	// Position of NESTSTA field.
	PFIC_GISR_NESTSTA_Pos = 0x0
	// Bit mask of NESTSTA field.
	PFIC_GISR_NESTSTA_Msk = 0xff
	// Position of GACTSTA field.
	PFIC_GISR_GACTSTA_Pos = 0x8
	// Bit mask of GACTSTA field.
	PFIC_GISR_GACTSTA_Msk = 0x100
	// Bit GACTSTA.
	PFIC_GISR_GACTSTA = 0x100
	// Position of GPENDSTA field.
	PFIC_GISR_GPENDSTA_Pos = 0x9
	// Bit mask of GPENDSTA field.
	PFIC_GISR_GPENDSTA_Msk = 0x200
	// Bit GPENDSTA.
	PFIC_GISR_GPENDSTA = 0x200

	// VTFIDR: ID Config Register
	// Position of VTFID0 field.
	PFIC_VTFIDR_VTFID0_Pos = 0x0
	// Bit mask of VTFID0 field.
	PFIC_VTFIDR_VTFID0_Msk = 0xff
	// Position of VTFID1 field.
	PFIC_VTFIDR_VTFID1_Pos = 0x8
	// Bit mask of VTFID1 field.
	PFIC_VTFIDR_VTFID1_Msk = 0xff00
	// Position of VTFID2 field.
	PFIC_VTFIDR_VTFID2_Pos = 0x10
	// Bit mask of VTFID2 field.
	PFIC_VTFIDR_VTFID2_Msk = 0xff0000
	// Position of VTFID3 field.
	PFIC_VTFIDR_VTFID3_Pos = 0x18
	// Bit mask of VTFID3 field.
	PFIC_VTFIDR_VTFID3_Msk = 0xff000000

	// VTFADDRR0: Interrupt 0 address Register
	// Position of VTF0EN field.
	PFIC_VTFADDRR0_VTF0EN_Pos = 0x0
	// Bit mask of VTF0EN field.
	PFIC_VTFADDRR0_VTF0EN_Msk = 0x1
	// Bit VTF0EN.
	PFIC_VTFADDRR0_VTF0EN = 0x1
	// Position of _ADDR0 field.
	PFIC_VTFADDRR0__ADDR0_Pos = 0x1
	// Bit mask of _ADDR0 field.
	PFIC_VTFADDRR0__ADDR0_Msk = 0xfffffffe

	// VTFADDRR1: Interrupt 1 address Register
	// Position of VTF1EN field.
	PFIC_VTFADDRR1_VTF1EN_Pos = 0x0
	// Bit mask of VTF1EN field.
	PFIC_VTFADDRR1_VTF1EN_Msk = 0x1
	// Bit VTF1EN.
	PFIC_VTFADDRR1_VTF1EN = 0x1
	// Position of _ADDR1 field.
	PFIC_VTFADDRR1__ADDR1_Pos = 0x1
	// Bit mask of _ADDR1 field.
	PFIC_VTFADDRR1__ADDR1_Msk = 0xfffffffe

	// VTFADDRR2: Interrupt 2 address Register
	// Position of VTF2EN field.
	PFIC_VTFADDRR2_VTF2EN_Pos = 0x0
	// Bit mask of VTF2EN field.
	PFIC_VTFADDRR2_VTF2EN_Msk = 0x1
	// Bit VTF2EN.
	PFIC_VTFADDRR2_VTF2EN = 0x1
	// Position of _ADDR2 field.
	PFIC_VTFADDRR2__ADDR2_Pos = 0x1
	// Bit mask of _ADDR2 field.
	PFIC_VTFADDRR2__ADDR2_Msk = 0xfffffffe

	// VTFADDRR3: Interrupt 3 address Register
	// Position of VTF3EN field.
	PFIC_VTFADDRR3_VTF3EN_Pos = 0x0
	// Bit mask of VTF3EN field.
	PFIC_VTFADDRR3_VTF3EN_Msk = 0x1
	// Bit VTF3EN.
	PFIC_VTFADDRR3_VTF3EN = 0x1
	// Position of _ADDR3 field.
	PFIC_VTFADDRR3__ADDR3_Pos = 0x1
	// Bit mask of _ADDR3 field.
	PFIC_VTFADDRR3__ADDR3_Msk = 0xfffffffe

	// IENR1: Interrupt Setting Register
	// Position of INTEN field.
	PFIC_IENR1_INTEN_Pos = 0xc
	// Bit mask of INTEN field.
	PFIC_IENR1_INTEN_Msk = 0xfffff000

	// IENR2: Interrupt Setting Register
	// Position of INTEN field.
	PFIC_IENR2_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	PFIC_IENR2_INTEN_Msk = 0xffffffff

	// IENR3: Interrupt Setting Register
	// Position of INTEN field.
	PFIC_IENR3_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	PFIC_IENR3_INTEN_Msk = 0xffffffff

	// IENR4: Interrupt Setting Register
	// Position of INTEN field.
	PFIC_IENR4_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	PFIC_IENR4_INTEN_Msk = 0xff

	// IRER1: Interrupt Clear Register
	// Position of INTRSET field.
	PFIC_IRER1_INTRSET_Pos = 0xc
	// Bit mask of INTRSET field.
	PFIC_IRER1_INTRSET_Msk = 0xfffff000

	// IRER2: Interrupt Clear Register
	// Position of INTRSET field.
	PFIC_IRER2_INTRSET_Pos = 0x0
	// Bit mask of INTRSET field.
	PFIC_IRER2_INTRSET_Msk = 0xffffffff

	// IRER3: Interrupt Clear Register
	// Position of INTRSET field.
	PFIC_IRER3_INTRSET_Pos = 0x0
	// Bit mask of INTRSET field.
	PFIC_IRER3_INTRSET_Msk = 0xffffffff

	// IRER4: Interrupt Clear Register
	// Position of INTRSET field.
	PFIC_IRER4_INTRSET_Pos = 0x0
	// Bit mask of INTRSET field.
	PFIC_IRER4_INTRSET_Msk = 0xff

	// IPSR1: Interrupt Pending Register
	// Position of PENDSET2_3 field.
	PFIC_IPSR1_PENDSET2_3_Pos = 0x2
	// Bit mask of PENDSET2_3 field.
	PFIC_IPSR1_PENDSET2_3_Msk = 0xc
	// Position of PENDSET12_31 field.
	PFIC_IPSR1_PENDSET12_31_Pos = 0xc
	// Bit mask of PENDSET12_31 field.
	PFIC_IPSR1_PENDSET12_31_Msk = 0xfffff000

	// IPSR2: Interrupt Pending Register
	// Position of PENDSET field.
	PFIC_IPSR2_PENDSET_Pos = 0x0
	// Bit mask of PENDSET field.
	PFIC_IPSR2_PENDSET_Msk = 0xffffffff

	// IPSR3: Interrupt Pending Register
	// Position of PENDSET field.
	PFIC_IPSR3_PENDSET_Pos = 0x0
	// Bit mask of PENDSET field.
	PFIC_IPSR3_PENDSET_Msk = 0xffffffff

	// IPSR4: Interrupt Pending Register
	// Position of PENDSET field.
	PFIC_IPSR4_PENDSET_Pos = 0x0
	// Bit mask of PENDSET field.
	PFIC_IPSR4_PENDSET_Msk = 0xff

	// IPRR1: Interrupt Pending Clear Register
	// Position of PENDRESET2_3 field.
	PFIC_IPRR1_PENDRESET2_3_Pos = 0x2
	// Bit mask of PENDRESET2_3 field.
	PFIC_IPRR1_PENDRESET2_3_Msk = 0xc
	// Position of PENDRESET12_31 field.
	PFIC_IPRR1_PENDRESET12_31_Pos = 0xc
	// Bit mask of PENDRESET12_31 field.
	PFIC_IPRR1_PENDRESET12_31_Msk = 0xfffff000

	// IPRR2: Interrupt Pending Clear Register
	// Position of PENDRESET field.
	PFIC_IPRR2_PENDRESET_Pos = 0x0
	// Bit mask of PENDRESET field.
	PFIC_IPRR2_PENDRESET_Msk = 0xffffffff

	// IPRR3: Interrupt Pending Clear Register
	// Position of PENDRESET field.
	PFIC_IPRR3_PENDRESET_Pos = 0x0
	// Bit mask of PENDRESET field.
	PFIC_IPRR3_PENDRESET_Msk = 0xffffffff

	// IPRR4: Interrupt Pending Clear Register
	// Position of PENDRESET field.
	PFIC_IPRR4_PENDRESET_Pos = 0x0
	// Bit mask of PENDRESET field.
	PFIC_IPRR4_PENDRESET_Msk = 0xff

	// IACTR1: Interrupt ACTIVE Register
	// Position of IACTS2_3 field.
	PFIC_IACTR1_IACTS2_3_Pos = 0x2
	// Bit mask of IACTS2_3 field.
	PFIC_IACTR1_IACTS2_3_Msk = 0xc
	// Position of IACTS12_31 field.
	PFIC_IACTR1_IACTS12_31_Pos = 0xc
	// Bit mask of IACTS12_31 field.
	PFIC_IACTR1_IACTS12_31_Msk = 0xfffff000

	// IACTR2: Interrupt ACTIVE Register
	// Position of IACTS field.
	PFIC_IACTR2_IACTS_Pos = 0x0
	// Bit mask of IACTS field.
	PFIC_IACTR2_IACTS_Msk = 0xffffffff

	// IACTR3: Interrupt ACTIVE Register
	// Position of IACTS field.
	PFIC_IACTR3_IACTS_Pos = 0x0
	// Bit mask of IACTS field.
	PFIC_IACTR3_IACTS_Msk = 0xffffffff

	// IACTR4: Interrupt ACTIVE Register
	// Position of IACTS field.
	PFIC_IACTR4_IACTS_Pos = 0x0
	// Bit mask of IACTS field.
	PFIC_IACTR4_IACTS_Msk = 0xff

	// SCTLR: System Control Register
	// Position of SLEEPONEXIT field.
	PFIC_SCTLR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	PFIC_SCTLR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	PFIC_SCTLR_SLEEPONEXIT = 0x2
	// Position of SLEEPDEEP field.
	PFIC_SCTLR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	PFIC_SCTLR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	PFIC_SCTLR_SLEEPDEEP = 0x4
	// Position of WFITOWFE field.
	PFIC_SCTLR_WFITOWFE_Pos = 0x3
	// Bit mask of WFITOWFE field.
	PFIC_SCTLR_WFITOWFE_Msk = 0x8
	// Bit WFITOWFE.
	PFIC_SCTLR_WFITOWFE = 0x8
	// Position of SEVONPEND field.
	PFIC_SCTLR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	PFIC_SCTLR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	PFIC_SCTLR_SEVONPEND = 0x10
	// Position of SETEVENT field.
	PFIC_SCTLR_SETEVENT_Pos = 0x5
	// Bit mask of SETEVENT field.
	PFIC_SCTLR_SETEVENT_Msk = 0x20
	// Bit SETEVENT.
	PFIC_SCTLR_SETEVENT = 0x20
	// Position of SYSRESET field.
	PFIC_SCTLR_SYSRESET_Pos = 0x1f
	// Bit mask of SYSRESET field.
	PFIC_SCTLR_SYSRESET_Msk = 0x80000000
	// Bit SYSRESET.
	PFIC_SCTLR_SYSRESET = 0x80000000

	// STK_CTLR: System counter control register
	// Position of STE field.
	PFIC_STK_CTLR_STE_Pos = 0x0
	// Bit mask of STE field.
	PFIC_STK_CTLR_STE_Msk = 0x1
	// Bit STE.
	PFIC_STK_CTLR_STE = 0x1
	// Position of STIE field.
	PFIC_STK_CTLR_STIE_Pos = 0x1
	// Bit mask of STIE field.
	PFIC_STK_CTLR_STIE_Msk = 0x2
	// Bit STIE.
	PFIC_STK_CTLR_STIE = 0x2
	// Position of STCLK field.
	PFIC_STK_CTLR_STCLK_Pos = 0x2
	// Bit mask of STCLK field.
	PFIC_STK_CTLR_STCLK_Msk = 0x4
	// Bit STCLK.
	PFIC_STK_CTLR_STCLK = 0x4
	// Position of STRE field.
	PFIC_STK_CTLR_STRE_Pos = 0x3
	// Bit mask of STRE field.
	PFIC_STK_CTLR_STRE_Msk = 0x8
	// Bit STRE.
	PFIC_STK_CTLR_STRE = 0x8
	// Position of MODE field.
	PFIC_STK_CTLR_MODE_Pos = 0x4
	// Bit mask of MODE field.
	PFIC_STK_CTLR_MODE_Msk = 0x10
	// Bit MODE.
	PFIC_STK_CTLR_MODE = 0x10
	// Position of INIT field.
	PFIC_STK_CTLR_INIT_Pos = 0x5
	// Bit mask of INIT field.
	PFIC_STK_CTLR_INIT_Msk = 0x20
	// Bit INIT.
	PFIC_STK_CTLR_INIT = 0x20
	// Position of SWIE field.
	PFIC_STK_CTLR_SWIE_Pos = 0x1f
	// Bit mask of SWIE field.
	PFIC_STK_CTLR_SWIE_Msk = 0x80000000
	// Bit SWIE.
	PFIC_STK_CTLR_SWIE = 0x80000000

	// STK_SR: System START
	// Position of CNTIF field.
	PFIC_STK_SR_CNTIF_Pos = 0x0
	// Bit mask of CNTIF field.
	PFIC_STK_SR_CNTIF_Msk = 0x1
	// Bit CNTIF.
	PFIC_STK_SR_CNTIF = 0x1

	// STK_CNTL: System counter low register
	// Position of CNTL field.
	PFIC_STK_CNTL_CNTL_Pos = 0x0
	// Bit mask of CNTL field.
	PFIC_STK_CNTL_CNTL_Msk = 0xffffffff

	// STK_CMPLR: System compare low register
	// Position of CMPL field.
	PFIC_STK_CMPLR_CMPL_Pos = 0x0
	// Bit mask of CMPL field.
	PFIC_STK_CMPLR_CMPL_Msk = 0xffffffff
)
